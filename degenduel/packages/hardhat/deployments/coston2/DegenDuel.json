{
  "address": "0x835574875C1CB9003c1638E799f3d7c504808960",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "duelId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "randomNumber",
          "type": "uint256"
        }
      ],
      "name": "BonusTriggered",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "duelId",
          "type": "uint256"
        }
      ],
      "name": "DuelCancelled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "duelId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "creator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "enum DegenDuel.DuelType",
          "name": "duelType",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "stakeAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes21",
          "name": "feedId",
          "type": "bytes21"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "threshold",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "prediction",
          "type": "bool"
        }
      ],
      "name": "DuelCreated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "duelId",
          "type": "uint256"
        }
      ],
      "name": "DuelExpired",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "duelId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "joiner",
          "type": "address"
        }
      ],
      "name": "DuelJoined",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "duelId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "winner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "payout",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "settledValue",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "bonusApplied",
          "type": "bool"
        }
      ],
      "name": "DuelSettled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "duelId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes21",
          "name": "feedId",
          "type": "bytes21"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "int8",
          "name": "decimals",
          "type": "int8"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "timestamp",
          "type": "uint64"
        }
      ],
      "name": "PriceRead",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "BONUS_CHANCE",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MAX_DURATION",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MIN_STAKE",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "PROTOCOL_FEE_BPS",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "activeDuelIds",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "duelId",
          "type": "uint256"
        }
      ],
      "name": "cancelDuel",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "dataThreshold",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "prediction",
          "type": "bool"
        }
      ],
      "name": "createDataDuel",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "duelId",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes21",
          "name": "feedId",
          "type": "bytes21"
        },
        {
          "internalType": "uint256",
          "name": "priceThreshold",
          "type": "uint256"
        },
        {
          "internalType": "int8",
          "name": "priceDecimals",
          "type": "int8"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "prediction",
          "type": "bool"
        }
      ],
      "name": "createPriceDuel",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "duelId",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "duels",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "internalType": "enum DegenDuel.DuelType",
          "name": "duelType",
          "type": "uint8"
        },
        {
          "internalType": "enum DegenDuel.DuelStatus",
          "name": "status",
          "type": "uint8"
        },
        {
          "internalType": "address",
          "name": "playerA",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "playerB",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "stakeAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "playerAPrediction",
          "type": "bool"
        },
        {
          "internalType": "address",
          "name": "winner",
          "type": "address"
        },
        {
          "internalType": "bytes21",
          "name": "feedId",
          "type": "bytes21"
        },
        {
          "internalType": "uint256",
          "name": "priceThreshold",
          "type": "uint256"
        },
        {
          "internalType": "int8",
          "name": "priceDecimals",
          "type": "int8"
        },
        {
          "internalType": "uint256",
          "name": "dataThreshold",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "settledValue",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "payout",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "bonusApplied",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "duelId",
          "type": "uint256"
        }
      ],
      "name": "expireDuel",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getActiveDuels",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "id",
              "type": "uint256"
            },
            {
              "internalType": "enum DegenDuel.DuelType",
              "name": "duelType",
              "type": "uint8"
            },
            {
              "internalType": "enum DegenDuel.DuelStatus",
              "name": "status",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "playerA",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "playerB",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "stakeAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "deadline",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "playerAPrediction",
              "type": "bool"
            },
            {
              "internalType": "address",
              "name": "winner",
              "type": "address"
            },
            {
              "internalType": "bytes21",
              "name": "feedId",
              "type": "bytes21"
            },
            {
              "internalType": "uint256",
              "name": "priceThreshold",
              "type": "uint256"
            },
            {
              "internalType": "int8",
              "name": "priceDecimals",
              "type": "int8"
            },
            {
              "internalType": "uint256",
              "name": "dataThreshold",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "settledValue",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "payout",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "bonusApplied",
              "type": "bool"
            }
          ],
          "internalType": "struct DegenDuel.Duel[]",
          "name": "",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes21",
          "name": "feedId",
          "type": "bytes21"
        }
      ],
      "name": "getCurrentPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "internalType": "int8",
          "name": "decimals",
          "type": "int8"
        },
        {
          "internalType": "uint64",
          "name": "timestamp",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "duelId",
          "type": "uint256"
        }
      ],
      "name": "getDuel",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "id",
              "type": "uint256"
            },
            {
              "internalType": "enum DegenDuel.DuelType",
              "name": "duelType",
              "type": "uint8"
            },
            {
              "internalType": "enum DegenDuel.DuelStatus",
              "name": "status",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "playerA",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "playerB",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "stakeAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "deadline",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "playerAPrediction",
              "type": "bool"
            },
            {
              "internalType": "address",
              "name": "winner",
              "type": "address"
            },
            {
              "internalType": "bytes21",
              "name": "feedId",
              "type": "bytes21"
            },
            {
              "internalType": "uint256",
              "name": "priceThreshold",
              "type": "uint256"
            },
            {
              "internalType": "int8",
              "name": "priceDecimals",
              "type": "int8"
            },
            {
              "internalType": "uint256",
              "name": "dataThreshold",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "settledValue",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "payout",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "bonusApplied",
              "type": "bool"
            }
          ],
          "internalType": "struct DegenDuel.Duel",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getOpenDuels",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "id",
              "type": "uint256"
            },
            {
              "internalType": "enum DegenDuel.DuelType",
              "name": "duelType",
              "type": "uint8"
            },
            {
              "internalType": "enum DegenDuel.DuelStatus",
              "name": "status",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "playerA",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "playerB",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "stakeAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "deadline",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "playerAPrediction",
              "type": "bool"
            },
            {
              "internalType": "address",
              "name": "winner",
              "type": "address"
            },
            {
              "internalType": "bytes21",
              "name": "feedId",
              "type": "bytes21"
            },
            {
              "internalType": "uint256",
              "name": "priceThreshold",
              "type": "uint256"
            },
            {
              "internalType": "int8",
              "name": "priceDecimals",
              "type": "int8"
            },
            {
              "internalType": "uint256",
              "name": "dataThreshold",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "settledValue",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "payout",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "bonusApplied",
              "type": "bool"
            }
          ],
          "internalType": "struct DegenDuel.Duel[]",
          "name": "",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "player",
          "type": "address"
        }
      ],
      "name": "getPlayerDuels",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "id",
              "type": "uint256"
            },
            {
              "internalType": "enum DegenDuel.DuelType",
              "name": "duelType",
              "type": "uint8"
            },
            {
              "internalType": "enum DegenDuel.DuelStatus",
              "name": "status",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "playerA",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "playerB",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "stakeAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "deadline",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "playerAPrediction",
              "type": "bool"
            },
            {
              "internalType": "address",
              "name": "winner",
              "type": "address"
            },
            {
              "internalType": "bytes21",
              "name": "feedId",
              "type": "bytes21"
            },
            {
              "internalType": "uint256",
              "name": "priceThreshold",
              "type": "uint256"
            },
            {
              "internalType": "int8",
              "name": "priceDecimals",
              "type": "int8"
            },
            {
              "internalType": "uint256",
              "name": "dataThreshold",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "settledValue",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "payout",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "bonusApplied",
              "type": "bool"
            }
          ],
          "internalType": "struct DegenDuel.Duel[]",
          "name": "",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "player",
          "type": "address"
        }
      ],
      "name": "getPlayerStats",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "wins",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "earnings",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes21[]",
          "name": "feedIds",
          "type": "bytes21[]"
        }
      ],
      "name": "getPrices",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "values",
          "type": "uint256[]"
        },
        {
          "internalType": "int8[]",
          "name": "decimals",
          "type": "int8[]"
        },
        {
          "internalType": "uint64",
          "name": "timestamp",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getProtocolStats",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "created",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "settled",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "volume",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "fees",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getRandomNumber",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "randomNumber",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "isSecure",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "randomTimestamp",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "duelId",
          "type": "uint256"
        }
      ],
      "name": "joinDuel",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "nextDuelId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "openDuelIds",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "playerDuels",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "playerEarnings",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "playerWins",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "protocolFeePool",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "duelId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "bytes32[]",
              "name": "merkleProof",
              "type": "bytes32[]"
            },
            {
              "components": [
                {
                  "internalType": "bytes32",
                  "name": "attestationType",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "sourceId",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint64",
                  "name": "votingRound",
                  "type": "uint64"
                },
                {
                  "internalType": "uint64",
                  "name": "lowestUsedTimestamp",
                  "type": "uint64"
                },
                {
                  "components": [
                    {
                      "internalType": "string",
                      "name": "url",
                      "type": "string"
                    },
                    {
                      "internalType": "string",
                      "name": "httpMethod",
                      "type": "string"
                    },
                    {
                      "internalType": "string",
                      "name": "headers",
                      "type": "string"
                    },
                    {
                      "internalType": "string",
                      "name": "queryParams",
                      "type": "string"
                    },
                    {
                      "internalType": "string",
                      "name": "body",
                      "type": "string"
                    },
                    {
                      "internalType": "string",
                      "name": "postProcessJq",
                      "type": "string"
                    },
                    {
                      "internalType": "string",
                      "name": "abiSignature",
                      "type": "string"
                    }
                  ],
                  "internalType": "struct IWeb2Json.RequestBody",
                  "name": "requestBody",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "bytes",
                      "name": "abiEncodedData",
                      "type": "bytes"
                    }
                  ],
                  "internalType": "struct IWeb2Json.ResponseBody",
                  "name": "responseBody",
                  "type": "tuple"
                }
              ],
              "internalType": "struct IWeb2Json.Response",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct IWeb2Json.Proof",
          "name": "proof",
          "type": "tuple"
        }
      ],
      "name": "settleDataDuel",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "duelId",
          "type": "uint256"
        }
      ],
      "name": "settlePriceDuel",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalDuelsCreated",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalDuelsSettled",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalVolume",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "withdrawFees",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0x22fdba9d807e21c4a365dfe13c47588f94f60f6b6d6638403c7af08a76cdc30b",
  "receipt": {
    "to": null,
    "from": "0x332a479FA9E548CFb90e7aF8504534e37E27E764",
    "contractAddress": "0x835574875C1CB9003c1638E799f3d7c504808960",
    "transactionIndex": 1,
    "gasUsed": "2305058",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x729c2b1346798a979b35c427dfee53cb3416a7b8b0ba5a02f5a7d12dc8e98e74",
    "transactionHash": "0x22fdba9d807e21c4a365dfe13c47588f94f60f6b6d6638403c7af08a76cdc30b",
    "logs": [],
    "blockNumber": 26987490,
    "cumulativeGasUsed": "2522681",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "82bb180a8646b0b0a192599aa2eaeaa3",
  "metadata": "{\"compiler\":{\"version\":\"0.8.30+commit.73712a01\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"duelId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"randomNumber\",\"type\":\"uint256\"}],\"name\":\"BonusTriggered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"duelId\",\"type\":\"uint256\"}],\"name\":\"DuelCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"duelId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum DegenDuel.DuelType\",\"name\":\"duelType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes21\",\"name\":\"feedId\",\"type\":\"bytes21\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"prediction\",\"type\":\"bool\"}],\"name\":\"DuelCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"duelId\",\"type\":\"uint256\"}],\"name\":\"DuelExpired\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"duelId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"joiner\",\"type\":\"address\"}],\"name\":\"DuelJoined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"duelId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"settledValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"bonusApplied\",\"type\":\"bool\"}],\"name\":\"DuelSettled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"duelId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes21\",\"name\":\"feedId\",\"type\":\"bytes21\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int8\",\"name\":\"decimals\",\"type\":\"int8\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"}],\"name\":\"PriceRead\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BONUS_CHANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_STAKE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROTOCOL_FEE_BPS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"activeDuelIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"duelId\",\"type\":\"uint256\"}],\"name\":\"cancelDuel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dataThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"prediction\",\"type\":\"bool\"}],\"name\":\"createDataDuel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"duelId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes21\",\"name\":\"feedId\",\"type\":\"bytes21\"},{\"internalType\":\"uint256\",\"name\":\"priceThreshold\",\"type\":\"uint256\"},{\"internalType\":\"int8\",\"name\":\"priceDecimals\",\"type\":\"int8\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"prediction\",\"type\":\"bool\"}],\"name\":\"createPriceDuel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"duelId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"duels\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"enum DegenDuel.DuelType\",\"name\":\"duelType\",\"type\":\"uint8\"},{\"internalType\":\"enum DegenDuel.DuelStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"playerA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"playerB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"playerAPrediction\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"bytes21\",\"name\":\"feedId\",\"type\":\"bytes21\"},{\"internalType\":\"uint256\",\"name\":\"priceThreshold\",\"type\":\"uint256\"},{\"internalType\":\"int8\",\"name\":\"priceDecimals\",\"type\":\"int8\"},{\"internalType\":\"uint256\",\"name\":\"dataThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"settledValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"bonusApplied\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"duelId\",\"type\":\"uint256\"}],\"name\":\"expireDuel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getActiveDuels\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"enum DegenDuel.DuelType\",\"name\":\"duelType\",\"type\":\"uint8\"},{\"internalType\":\"enum DegenDuel.DuelStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"playerA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"playerB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"playerAPrediction\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"bytes21\",\"name\":\"feedId\",\"type\":\"bytes21\"},{\"internalType\":\"uint256\",\"name\":\"priceThreshold\",\"type\":\"uint256\"},{\"internalType\":\"int8\",\"name\":\"priceDecimals\",\"type\":\"int8\"},{\"internalType\":\"uint256\",\"name\":\"dataThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"settledValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"bonusApplied\",\"type\":\"bool\"}],\"internalType\":\"struct DegenDuel.Duel[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes21\",\"name\":\"feedId\",\"type\":\"bytes21\"}],\"name\":\"getCurrentPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"int8\",\"name\":\"decimals\",\"type\":\"int8\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"duelId\",\"type\":\"uint256\"}],\"name\":\"getDuel\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"enum DegenDuel.DuelType\",\"name\":\"duelType\",\"type\":\"uint8\"},{\"internalType\":\"enum DegenDuel.DuelStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"playerA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"playerB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"playerAPrediction\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"bytes21\",\"name\":\"feedId\",\"type\":\"bytes21\"},{\"internalType\":\"uint256\",\"name\":\"priceThreshold\",\"type\":\"uint256\"},{\"internalType\":\"int8\",\"name\":\"priceDecimals\",\"type\":\"int8\"},{\"internalType\":\"uint256\",\"name\":\"dataThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"settledValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"bonusApplied\",\"type\":\"bool\"}],\"internalType\":\"struct DegenDuel.Duel\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOpenDuels\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"enum DegenDuel.DuelType\",\"name\":\"duelType\",\"type\":\"uint8\"},{\"internalType\":\"enum DegenDuel.DuelStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"playerA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"playerB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"playerAPrediction\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"bytes21\",\"name\":\"feedId\",\"type\":\"bytes21\"},{\"internalType\":\"uint256\",\"name\":\"priceThreshold\",\"type\":\"uint256\"},{\"internalType\":\"int8\",\"name\":\"priceDecimals\",\"type\":\"int8\"},{\"internalType\":\"uint256\",\"name\":\"dataThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"settledValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"bonusApplied\",\"type\":\"bool\"}],\"internalType\":\"struct DegenDuel.Duel[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getPlayerDuels\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"enum DegenDuel.DuelType\",\"name\":\"duelType\",\"type\":\"uint8\"},{\"internalType\":\"enum DegenDuel.DuelStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"playerA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"playerB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"playerAPrediction\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"bytes21\",\"name\":\"feedId\",\"type\":\"bytes21\"},{\"internalType\":\"uint256\",\"name\":\"priceThreshold\",\"type\":\"uint256\"},{\"internalType\":\"int8\",\"name\":\"priceDecimals\",\"type\":\"int8\"},{\"internalType\":\"uint256\",\"name\":\"dataThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"settledValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"bonusApplied\",\"type\":\"bool\"}],\"internalType\":\"struct DegenDuel.Duel[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getPlayerStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"wins\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"earnings\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes21[]\",\"name\":\"feedIds\",\"type\":\"bytes21[]\"}],\"name\":\"getPrices\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"int8[]\",\"name\":\"decimals\",\"type\":\"int8[]\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProtocolStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"created\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"settled\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"volume\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRandomNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"randomNumber\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSecure\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"randomTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"duelId\",\"type\":\"uint256\"}],\"name\":\"joinDuel\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextDuelId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"openDuelIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerDuels\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerWins\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFeePool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"duelId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"attestationType\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"sourceId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"votingRound\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"lowestUsedTimestamp\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"url\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"httpMethod\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"headers\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"queryParams\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"body\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"postProcessJq\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"abiSignature\",\"type\":\"string\"}],\"internalType\":\"struct IWeb2Json.RequestBody\",\"name\":\"requestBody\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"abiEncodedData\",\"type\":\"bytes\"}],\"internalType\":\"struct IWeb2Json.ResponseBody\",\"name\":\"responseBody\",\"type\":\"tuple\"}],\"internalType\":\"struct IWeb2Json.Response\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct IWeb2Json.Proof\",\"name\":\"proof\",\"type\":\"tuple\"}],\"name\":\"settleDataDuel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"duelId\",\"type\":\"uint256\"}],\"name\":\"settlePriceDuel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDuelsCreated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDuelsSettled\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalVolume\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"details\":\"Built for ETH Oxford 2026 hackathon on Coston2 testnet\",\"kind\":\"dev\",\"methods\":{},\"title\":\"DegenDuel\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"cancelDuel(uint256)\":{\"notice\":\"Cancel an open duel (creator only, before anyone joins)\"},\"createDataDuel(uint256,uint256,bool)\":{\"notice\":\"Create a data-based duel settled by FDC Web2Json proof\"},\"createPriceDuel(bytes21,uint256,int8,uint256,bool)\":{\"notice\":\"Create a price-based duel settled by FTSO\"},\"expireDuel(uint256)\":{\"notice\":\"Expire a duel that passed deadline + 24h without settlement\"},\"getActiveDuels()\":{\"notice\":\"Get all active duels\"},\"getCurrentPrice(bytes21)\":{\"notice\":\"Get current FTSO price for a feed (for UI display)\"},\"getDuel(uint256)\":{\"notice\":\"Get a single duel by ID\"},\"getOpenDuels()\":{\"notice\":\"Get all open duels\"},\"getPlayerDuels(address)\":{\"notice\":\"Get duels for a specific player\"},\"getPlayerStats(address)\":{\"notice\":\"Get player stats for leaderboard\"},\"getPrices(bytes21[])\":{\"notice\":\"Get multiple FTSO prices at once (for UI ticker)\"},\"getProtocolStats()\":{\"notice\":\"Get protocol stats\"},\"getRandomNumber()\":{\"notice\":\"Get a random number from Flare's Secure RNG\"},\"joinDuel(uint256)\":{\"notice\":\"Join an open duel (takes the opposite prediction)\"},\"settleDataDuel(uint256,(bytes32[],(bytes32,bytes32,uint64,uint64,(string,string,string,string,string,string,string),(bytes))))\":{\"notice\":\"Settle a data duel with a verified FDC Web2Json proof\"},\"settlePriceDuel(uint256)\":{\"notice\":\"Settle a price duel by reading current FTSO price\"},\"withdrawFees()\":{\"notice\":\"Withdraw accumulated protocol fees\"}},\"notice\":\"PvP prediction duel game using all 3 Flare protocols: FTSO + FDC + RNG\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/DegenDuel.sol\":\"DegenDuel\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@flarenetwork/flare-periphery-contracts/coston2/ContractRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.25;\\n\\nimport {IFlareContractRegistry} from \\\"./IFlareContractRegistry.sol\\\";\\n// AUTO GENERATED - DO NOT EDIT BELOW THIS LINE\\nimport {IPriceSubmitter} from \\\"./IPriceSubmitter.sol\\\";\\nimport {IGovernanceSettings} from \\\"./IGovernanceSettings.sol\\\";\\nimport {IFtsoRewardManager} from \\\"./IFtsoRewardManager.sol\\\";\\nimport {IFtsoRegistry} from \\\"./IFtsoRegistry.sol\\\";\\nimport {IVoterWhitelister} from \\\"./IVoterWhitelister.sol\\\";\\nimport {IFtsoManager} from \\\"./IFtsoManager.sol\\\";\\nimport {IWNat} from \\\"./IWNat.sol\\\";\\nimport {IGovernanceVotePower} from \\\"./IGovernanceVotePower.sol\\\";\\nimport {IClaimSetupManager} from \\\"./IClaimSetupManager.sol\\\";\\nimport {IFlareAssetRegistry} from \\\"./IFlareAssetRegistry.sol\\\";\\nimport {IFlareContractRegistry} from \\\"./IFlareContractRegistry.sol\\\";\\nimport {ISubmission} from \\\"./ISubmission.sol\\\";\\nimport {IEntityManager} from \\\"./IEntityManager.sol\\\";\\nimport {IVoterRegistry} from \\\"./IVoterRegistry.sol\\\";\\nimport {IFlareSystemsCalculator} from \\\"./IFlareSystemsCalculator.sol\\\";\\nimport {IFlareSystemsManager} from \\\"./IFlareSystemsManager.sol\\\";\\nimport {IRewardManager} from \\\"./IRewardManager.sol\\\";\\nimport {IRelay} from \\\"./IRelay.sol\\\";\\nimport {IWNatDelegationFee} from \\\"./IWNatDelegationFee.sol\\\";\\nimport {IFtsoInflationConfigurations} from \\\"./IFtsoInflationConfigurations.sol\\\";\\nimport {IFtsoRewardOffersManager} from \\\"./IFtsoRewardOffersManager.sol\\\";\\nimport {IFtsoFeedDecimals} from \\\"./IFtsoFeedDecimals.sol\\\";\\nimport {IFtsoFeedPublisher} from \\\"./IFtsoFeedPublisher.sol\\\";\\nimport {IFtsoFeedIdConverter} from \\\"./IFtsoFeedIdConverter.sol\\\";\\nimport {IFastUpdateIncentiveManager} from \\\"./IFastUpdateIncentiveManager.sol\\\";\\nimport {IFastUpdater} from \\\"./IFastUpdater.sol\\\";\\nimport {IFastUpdatesConfiguration} from \\\"./IFastUpdatesConfiguration.sol\\\";\\nimport {IFeeCalculator} from \\\"./IFeeCalculator.sol\\\";\\nimport {FtsoV2Interface} from \\\"./FtsoV2Interface.sol\\\";\\nimport {TestFtsoV2Interface} from \\\"./TestFtsoV2Interface.sol\\\";\\nimport {ProtocolsV2Interface} from \\\"./ProtocolsV2Interface.sol\\\";\\nimport {RandomNumberV2Interface} from \\\"./RandomNumberV2Interface.sol\\\";\\nimport {RewardsV2Interface} from \\\"./RewardsV2Interface.sol\\\";\\nimport {IFdcVerification} from \\\"./IFdcVerification.sol\\\";\\nimport {IFdcHub} from \\\"./IFdcHub.sol\\\";\\nimport {IFdcRequestFeeConfigurations} from \\\"./IFdcRequestFeeConfigurations.sol\\\";\\nimport {IAssetManagerController} from \\\"./IAssetManagerController.sol\\\";\\nimport {IAssetManager} from \\\"./IAssetManager.sol\\\";\\nimport {IJsonApiVerification} from \\\"./IJsonApiVerification.sol\\\";\\nimport {IGenericRewardManager} from \\\"./IGenericRewardManager.sol\\\";\\n// END AUTO GENERATED - DO NOT EDIT ABOVE THIS LINE\\n\\n// Library is intended to be used inline, so the strings are all memory allocated (instead of calldata)\\nlibrary ContractRegistry {\\n    address internal constant FLARE_CONTRACT_REGISTRY_ADDRESS =\\n        0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019;\\n\\n    IFlareContractRegistry internal constant FLARE_CONTRACT_REGISTRY =\\n        IFlareContractRegistry(FLARE_CONTRACT_REGISTRY_ADDRESS);\\n\\n    /**\\n     * @notice Returns contract address for the given name - might be address(0)\\n     * @param _name             name of the contract\\n     */\\n    function getContractAddressByName(\\n        string memory _name\\n    ) internal view returns (address) {\\n        return FLARE_CONTRACT_REGISTRY.getContractAddressByName(_name);\\n    }\\n\\n    /**\\n     * @notice Returns contract address for the given name hash - might be address(0)\\n     * @param _nameHash         hash of the contract name (keccak256(abi.encode(name))\\n     */\\n    function getContractAddressByHash(\\n        bytes32 _nameHash\\n    ) internal view returns (address) {\\n        return FLARE_CONTRACT_REGISTRY.getContractAddressByHash(_nameHash);\\n    }\\n\\n    /**\\n     * @notice Returns contract addresses for the given names - might be address(0)\\n     * @param _names            names of the contracts\\n     */\\n    function getContractAddressesByName(\\n        string[] memory _names\\n    ) internal view returns (address[] memory) {\\n        return FLARE_CONTRACT_REGISTRY.getContractAddressesByName(_names);\\n    }\\n\\n    /**\\n     * @notice Returns contract addresses for the given name hashes - might be address(0)\\n     * @param _nameHashes       hashes of the contract names (keccak256(abi.encode(name))\\n     */\\n    function getContractAddressesByHash(\\n        bytes32[] memory _nameHashes\\n    ) internal view returns (address[] memory) {\\n        return FLARE_CONTRACT_REGISTRY.getContractAddressesByHash(_nameHashes);\\n    }\\n\\n    /**\\n     * @notice Returns all contract names and corresponding addresses\\n     */\\n    function getAllContracts()\\n        internal\\n        view\\n        returns (string[] memory _names, address[] memory _addresses)\\n    {\\n        return FLARE_CONTRACT_REGISTRY.getAllContracts();\\n    }\\n\\n    // Nice typed getters for all the important contracts\\n    // AUTO GENERATED - DO NOT EDIT BELOW THIS LINE\\n    function getPriceSubmitter() internal view returns (IPriceSubmitter) {\\n        return\\n            IPriceSubmitter(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"PriceSubmitter\\\"))\\n                )\\n            );\\n    }\\n\\n    function getGovernanceSettings()\\n        internal\\n        view\\n        returns (IGovernanceSettings)\\n    {\\n        return\\n            IGovernanceSettings(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"GovernanceSettings\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFtsoRewardManager() internal view returns (IFtsoRewardManager) {\\n        return\\n            IFtsoRewardManager(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FtsoRewardManager\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFtsoRegistry() internal view returns (IFtsoRegistry) {\\n        return\\n            IFtsoRegistry(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FtsoRegistry\\\"))\\n                )\\n            );\\n    }\\n\\n    function getVoterWhitelister() internal view returns (IVoterWhitelister) {\\n        return\\n            IVoterWhitelister(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"VoterWhitelister\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFtsoManager() internal view returns (IFtsoManager) {\\n        return\\n            IFtsoManager(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FtsoManager\\\"))\\n                )\\n            );\\n    }\\n\\n    function getWNat() internal view returns (IWNat) {\\n        return\\n            IWNat(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"WNat\\\"))\\n                )\\n            );\\n    }\\n\\n    function getGovernanceVotePower()\\n        internal\\n        view\\n        returns (IGovernanceVotePower)\\n    {\\n        return\\n            IGovernanceVotePower(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"GovernanceVotePower\\\"))\\n                )\\n            );\\n    }\\n\\n    function getClaimSetupManager() internal view returns (IClaimSetupManager) {\\n        return\\n            IClaimSetupManager(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"ClaimSetupManager\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFlareAssetRegistry()\\n        internal\\n        view\\n        returns (IFlareAssetRegistry)\\n    {\\n        return\\n            IFlareAssetRegistry(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FlareAssetRegistry\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFlareContractRegistry()\\n        internal\\n        view\\n        returns (IFlareContractRegistry)\\n    {\\n        return\\n            IFlareContractRegistry(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FlareContractRegistry\\\"))\\n                )\\n            );\\n    }\\n\\n    function getSubmission() internal view returns (ISubmission) {\\n        return\\n            ISubmission(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"Submission\\\"))\\n                )\\n            );\\n    }\\n\\n    function getEntityManager() internal view returns (IEntityManager) {\\n        return\\n            IEntityManager(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"EntityManager\\\"))\\n                )\\n            );\\n    }\\n\\n    function getVoterRegistry() internal view returns (IVoterRegistry) {\\n        return\\n            IVoterRegistry(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"VoterRegistry\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFlareSystemsCalculator()\\n        internal\\n        view\\n        returns (IFlareSystemsCalculator)\\n    {\\n        return\\n            IFlareSystemsCalculator(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FlareSystemsCalculator\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFlareSystemsManager()\\n        internal\\n        view\\n        returns (IFlareSystemsManager)\\n    {\\n        return\\n            IFlareSystemsManager(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FlareSystemsManager\\\"))\\n                )\\n            );\\n    }\\n\\n    function getRewardManager() internal view returns (IRewardManager) {\\n        return\\n            IRewardManager(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"RewardManager\\\"))\\n                )\\n            );\\n    }\\n\\n    function getRelay() internal view returns (IRelay) {\\n        return\\n            IRelay(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"Relay\\\"))\\n                )\\n            );\\n    }\\n\\n    function getWNatDelegationFee() internal view returns (IWNatDelegationFee) {\\n        return\\n            IWNatDelegationFee(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"WNatDelegationFee\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFtsoInflationConfigurations()\\n        internal\\n        view\\n        returns (IFtsoInflationConfigurations)\\n    {\\n        return\\n            IFtsoInflationConfigurations(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FtsoInflationConfigurations\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFtsoRewardOffersManager()\\n        internal\\n        view\\n        returns (IFtsoRewardOffersManager)\\n    {\\n        return\\n            IFtsoRewardOffersManager(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FtsoRewardOffersManager\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFtsoFeedDecimals() internal view returns (IFtsoFeedDecimals) {\\n        return\\n            IFtsoFeedDecimals(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FtsoFeedDecimals\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFtsoFeedPublisher() internal view returns (IFtsoFeedPublisher) {\\n        return\\n            IFtsoFeedPublisher(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FtsoFeedPublisher\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFtsoFeedIdConverter()\\n        internal\\n        view\\n        returns (IFtsoFeedIdConverter)\\n    {\\n        return\\n            IFtsoFeedIdConverter(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FtsoFeedIdConverter\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFastUpdateIncentiveManager()\\n        internal\\n        view\\n        returns (IFastUpdateIncentiveManager)\\n    {\\n        return\\n            IFastUpdateIncentiveManager(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FastUpdateIncentiveManager\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFastUpdater() internal view returns (IFastUpdater) {\\n        return\\n            IFastUpdater(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FastUpdater\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFastUpdatesConfiguration()\\n        internal\\n        view\\n        returns (IFastUpdatesConfiguration)\\n    {\\n        return\\n            IFastUpdatesConfiguration(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FastUpdatesConfiguration\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFeeCalculator() internal view returns (IFeeCalculator) {\\n        return\\n            IFeeCalculator(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FeeCalculator\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFtsoV2() internal view returns (FtsoV2Interface) {\\n        return\\n            FtsoV2Interface(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FtsoV2\\\"))\\n                )\\n            );\\n    }\\n\\n    function getTestFtsoV2() internal view returns (TestFtsoV2Interface) {\\n        return\\n            TestFtsoV2Interface(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FtsoV2\\\"))\\n                )\\n            );\\n    }\\n\\n    function getProtocolsV2() internal view returns (ProtocolsV2Interface) {\\n        return\\n            ProtocolsV2Interface(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"ProtocolsV2\\\"))\\n                )\\n            );\\n    }\\n\\n    function getRandomNumberV2()\\n        internal\\n        view\\n        returns (RandomNumberV2Interface)\\n    {\\n        return\\n            RandomNumberV2Interface(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"RandomNumberV2\\\"))\\n                )\\n            );\\n    }\\n\\n    function getRewardsV2() internal view returns (RewardsV2Interface) {\\n        return\\n            RewardsV2Interface(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"RewardsV2\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFdcVerification() internal view returns (IFdcVerification) {\\n        return\\n            IFdcVerification(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FdcVerification\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFdcHub() internal view returns (IFdcHub) {\\n        return\\n            IFdcHub(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FdcHub\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFdcRequestFeeConfigurations()\\n        internal\\n        view\\n        returns (IFdcRequestFeeConfigurations)\\n    {\\n        return\\n            IFdcRequestFeeConfigurations(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FdcRequestFeeConfigurations\\\"))\\n                )\\n            );\\n    }\\n\\n    function getAssetManagerController()\\n        internal\\n        view\\n        returns (IAssetManagerController)\\n    {\\n        return\\n            IAssetManagerController(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"AssetManagerController\\\"))\\n                )\\n            );\\n    }\\n\\n    function getAssetManagerFXRP() internal view returns (IAssetManager) {\\n        return\\n            IAssetManager(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"AssetManagerFXRP\\\"))\\n                )\\n            );\\n    }\\n\\n    function auxiliaryGetIJsonApiVerification()\\n        internal\\n        pure\\n        returns (IJsonApiVerification)\\n    {\\n        return IJsonApiVerification(0x07ad8508C9173DC845817472Ca0484035AbFA3c8);\\n    }\\n\\n    function getValidatorRewardManager()\\n        internal\\n        view\\n        returns (IGenericRewardManager)\\n    {\\n        return\\n            IGenericRewardManager(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"ValidatorRewardManager\\\"))\\n                )\\n            );\\n    }\\n\\n    // END AUTO GENERATED - DO NOT EDIT ABOVE THIS LINE\\n}\\n\",\"keccak256\":\"0x76677918f3475eff37d1426f427c4cc8c1e3a41f58935f03a0cdeeb860373b11\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/FtsoV2Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * FtsoV2 long term support interface.\\n */\\ninterface FtsoV2Interface {\\n    /// Feed data structure\\n    struct FeedData {\\n        uint32 votingRoundId;\\n        bytes21 id;\\n        int32 value;\\n        uint16 turnoutBIPS;\\n        int8 decimals;\\n    }\\n\\n    /// Feed data with proof structure\\n    struct FeedDataWithProof {\\n        bytes32[] proof;\\n        FeedData body;\\n    }\\n\\n    /// Feed id change structure\\n    struct FeedIdChange {\\n        bytes21 oldFeedId;\\n        bytes21 newFeedId;\\n    }\\n\\n    /// Event emitted when a feed id is changed (e.g. feed renamed).\\n    event FeedIdChanged(bytes21 indexed oldFeedId, bytes21 indexed newFeedId);\\n\\n    /**\\n     * Returns the FTSO protocol id.\\n     */\\n    function getFtsoProtocolId() external view returns (uint256);\\n\\n    /**\\n     * Returns the list of supported feed ids (currently active feed ids).\\n     * To get the list of all available feed ids, combine with `getFeedIdChanges()`.\\n     * @return _feedIds The list of supported feed ids.\\n     */\\n    function getSupportedFeedIds()\\n        external\\n        view\\n        returns (bytes21[] memory _feedIds);\\n\\n    /**\\n     * Returns the list of feed id changes.\\n     * @return _feedIdChanges The list of changed feed id pairs (old and new feed id).\\n     */\\n    function getFeedIdChanges()\\n        external\\n        view\\n        returns (FeedIdChange[] memory _feedIdChanges);\\n\\n    /**\\n     * Calculates the fee for fetching a feed.\\n     * @param _feedId The id of the feed.\\n     * @return _fee The fee for fetching the feed.\\n     */\\n    function calculateFeeById(\\n        bytes21 _feedId\\n    ) external view returns (uint256 _fee);\\n\\n    /**\\n     * Calculates the fee for fetching feeds.\\n     * @param _feedIds The list of feed ids.\\n     * @return _fee The fee for fetching the feeds.\\n     */\\n    function calculateFeeByIds(\\n        bytes21[] memory _feedIds\\n    ) external view returns (uint256 _fee);\\n\\n    /**\\n     * Returns stored data of a feed.\\n     * A fee (calculated by the FeeCalculator contract) may need to be paid.\\n     * @param _feedId The id of the feed.\\n     * @return _value The value for the requested feed.\\n     * @return _decimals The decimal places for the requested feed.\\n     * @return _timestamp The timestamp of the last update.\\n     */\\n    function getFeedById(\\n        bytes21 _feedId\\n    )\\n        external\\n        payable\\n        returns (uint256 _value, int8 _decimals, uint64 _timestamp);\\n\\n    /**\\n     * Returns stored data of each feed.\\n     * A fee (calculated by the FeeCalculator contract) may need to be paid.\\n     * @param _feedIds The list of feed ids.\\n     * @return _values The list of values for the requested feeds.\\n     * @return _decimals The list of decimal places for the requested feeds.\\n     * @return _timestamp The timestamp of the last update.\\n     */\\n    function getFeedsById(\\n        bytes21[] memory _feedIds\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256[] memory _values,\\n            int8[] memory _decimals,\\n            uint64 _timestamp\\n        );\\n\\n    /**\\n     * Returns value in wei and timestamp of a feed.\\n     * A fee (calculated by the FeeCalculator contract) may need to be paid.\\n     * @param _feedId The id of the feed.\\n     * @return _value The value for the requested feed in wei (i.e. with 18 decimal places).\\n     * @return _timestamp The timestamp of the last update.\\n     */\\n    function getFeedByIdInWei(\\n        bytes21 _feedId\\n    ) external payable returns (uint256 _value, uint64 _timestamp);\\n\\n    /** Returns value of each feed and a timestamp.\\n     * For some feeds, a fee (calculated by the FeeCalculator contract) may need to be paid.\\n     * @param _feedIds Ids of the feeds.\\n     * @return _values The list of values for the requested feeds in wei (i.e. with 18 decimal places).\\n     * @return _timestamp The timestamp of the last update.\\n     */\\n    function getFeedsByIdInWei(\\n        bytes21[] memory _feedIds\\n    ) external payable returns (uint256[] memory _values, uint64 _timestamp);\\n\\n    /**\\n     * Checks if the feed data is valid (i.e. is part of the confirmed Merkle tree).\\n     * @param _feedData Structure containing data about the feed (FeedData structure) and Merkle proof.\\n     * @return true if the feed data is valid.\\n     */\\n    function verifyFeedData(\\n        FeedDataWithProof calldata _feedData\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x37f741e27175c4aeef8454ad747e3eca919a74c57146f650f28e1ffd72185221\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IAddressValidity.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * @custom:name IAddressValidity\\n * @custom:id 0x05\\n * @custom:supported BTC, DOGE, XRP\\n * @author Flare\\n * @notice An assertion whether a string represents a valid address on an external chain.\\n * @custom:verification The address is checked against all validity criteria of the chain with `sourceId`.\\n * Indicator of validity is provided.\\n * If the address is valid, its standard form and standard hash are computed.\\n * Validity criteria for each supported chain:\\n * - [BTC](/specs/attestations/external-chains/address-validity/BTC.md)\\n * - [DOGE](/specs/attestations/external-chains/address-validity/DOGE.md)\\n * - [XRPL](/specs/attestations/external-chains/address-validity/XRPL.md)\\n * @custom:lut `0xffffffffffffffff` ($2^{64}-1$ in hex)\\n * @custom:lutlimit `0xffffffffffffffff`, `0xffffffffffffffff`, `0xffffffffffffffff`\\n */\\ninterface IAddressValidity {\\n    /**\\n     * @notice Toplevel request\\n     * @param attestationType ID of the attestation type.\\n     * @param sourceId Id of the data source.\\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.\\n     * @param requestBody Data defining the request. Type and interpretation is determined by the `attestationType`.\\n     */\\n    struct Request {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        bytes32 messageIntegrityCode;\\n        RequestBody requestBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel response\\n     * @param attestationType Extracted from the request.\\n     * @param sourceId Extracted from the request.\\n     * @param votingRound The ID of the State Connector round in which the request was considered.\\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\\n     * @param requestBody Extracted from the request.\\n     * @param responseBody Data defining the response. The verification rules for the construction of the\\n     * response body and the type are defined per specific `attestationType`.\\n     */\\n    struct Response {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        uint64 votingRound;\\n        uint64 lowestUsedTimestamp;\\n        RequestBody requestBody;\\n        ResponseBody responseBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel proof\\n     * @param merkleProof Merkle proof corresponding to the attestation response.\\n     * @param data Attestation response.\\n     */\\n    struct Proof {\\n        bytes32[] merkleProof;\\n        Response data;\\n    }\\n\\n    /**\\n     * @notice Request body for IAddressValidity attestation type\\n     * @param addressStr Address to be verified.\\n     */\\n    struct RequestBody {\\n        string addressStr;\\n    }\\n\\n    /**\\n     * @notice Response body for IAddressValidity attestation type\\n     * @param isValid Boolean indicator of the address validity.\\n     * @param standardAddress If `isValid`, standard form of the validated address. Otherwise an empty string.\\n     * @param standardAddressHash If `isValid`, standard address hash of the validated address.\\n     * Otherwise a zero bytes32 string.\\n     */\\n    struct ResponseBody {\\n        bool isValid;\\n        string standardAddress;\\n        bytes32 standardAddressHash;\\n    }\\n}\\n\",\"keccak256\":\"0x5dfa0afc7251c6db95b2303acb9e7d917187ba614eb330d642bd6d639cbbce72\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IAddressValidityVerification.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IAddressValidity.sol\\\";\\n\\ninterface IAddressValidityVerification {\\n    function verifyAddressValidity(\\n        IAddressValidity.Proof calldata _proof\\n    ) external view returns (bool _proved);\\n}\\n\",\"keccak256\":\"0x86da8ce1362f4e01daca1aaf02c04358471940f37459790348f06cc83a7a49f8\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IAgentAlwaysAllowedMinters.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\ninterface IAgentAlwaysAllowedMinters {\\n    function addAlwaysAllowedMinterForAgent(\\n        address _agentVault,\\n        address _minter\\n    ) external;\\n\\n    function removeAlwaysAllowedMinterForAgent(\\n        address _agentVault,\\n        address _minter\\n    ) external;\\n\\n    function alwaysAllowedMintersForAgent(\\n        address _agentVault\\n    ) external view returns (address[] memory);\\n}\\n\",\"keccak256\":\"0x289556e5ec795b73dbc655fb877959b07788356556017cbd8a6165040b4cde52\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IAgentPing.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\ninterface IAgentPing {\\n    /**\\n     * Agent bot liveness check.\\n     * @param agentVault the agent vault whose owner bot to ping\\n     * @param sender the account that triggered ping; helps bot decide whether it is important to answer\\n     * @param query off-chain defined id of the query\\n     */\\n    event AgentPing(\\n        address indexed agentVault,\\n        address indexed sender,\\n        uint256 query\\n    );\\n\\n    /**\\n     * Response to agent bot liveness check.\\n     * @param agentVault the pinged agent vault\\n     * @param owner owner of the agent vault (management address)\\n     * @param query repeated `query` from the AgentPing event\\n     * @param response response data to the query\\n     */\\n    event AgentPingResponse(\\n        address indexed agentVault,\\n        address indexed owner,\\n        uint256 query,\\n        string response\\n    );\\n\\n    /**\\n     * Used for liveness checks, simply emits AgentPing event.\\n     * @param _agentVault the agent vault whose owner bot to ping\\n     * @param _query off-chain defined id of the query\\n     */\\n    function agentPing(address _agentVault, uint256 _query) external;\\n\\n    /**\\n     * Used for liveness checks, the bot's response to AgentPing event.\\n     * Simply emits AgentPingResponse event identifying the owner.\\n     * NOTE: may only be called by the agent vault owner\\n     * @param _agentVault the pinged agent vault\\n     * @param _query repeated `_query` from the agentPing\\n     * @param _response response data to the query\\n     */\\n    function agentPingResponse(\\n        address _agentVault,\\n        uint256 _query,\\n        string memory _response\\n    ) external;\\n}\\n\",\"keccak256\":\"0xe594e6bd2a9329f82c552262e4ec837f371fe291f7b35c9a27b3cf9a786716e3\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IAssetManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport {IConfirmedBlockHeightExists, IPayment, IAddressValidity, IReferencedPaymentNonexistence, IBalanceDecreasingTransaction} from \\\".//IFdcVerification.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport {IDiamondLoupe} from \\\"./diamond/interfaces/IDiamondLoupe.sol\\\";\\nimport {AssetManagerSettings} from \\\"./data/AssetManagerSettings.sol\\\";\\nimport {CollateralType} from \\\"./data/CollateralType.sol\\\";\\nimport {AgentInfo} from \\\"./data/AgentInfo.sol\\\";\\nimport {AgentSettings} from \\\"./data/AgentSettings.sol\\\";\\nimport {AvailableAgentInfo} from \\\"./data/AvailableAgentInfo.sol\\\";\\nimport {RedemptionTicketInfo} from \\\"./data/RedemptionTicketInfo.sol\\\";\\nimport {RedemptionRequestInfo} from \\\"./data/RedemptionRequestInfo.sol\\\";\\nimport {CollateralReservationInfo} from \\\"./data/CollateralReservationInfo.sol\\\";\\nimport {EmergencyPause} from \\\"./data/EmergencyPause.sol\\\";\\nimport {IAssetManagerEvents} from \\\"./IAssetManagerEvents.sol\\\";\\nimport {IAgentPing} from \\\"./IAgentPing.sol\\\";\\nimport {IRedemptionTimeExtension} from \\\"./IRedemptionTimeExtension.sol\\\";\\nimport {ICoreVaultClient} from \\\"./ICoreVaultClient.sol\\\";\\nimport {ICoreVaultClientSettings} from \\\"./ICoreVaultClientSettings.sol\\\";\\nimport {IAgentAlwaysAllowedMinters} from \\\"./IAgentAlwaysAllowedMinters.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * Asset manager publicly callable methods.\\n */\\ninterface IAssetManager is\\n    IERC165,\\n    IDiamondLoupe,\\n    IAssetManagerEvents,\\n    IAgentPing,\\n    IRedemptionTimeExtension,\\n    ICoreVaultClient,\\n    ICoreVaultClientSettings,\\n    IAgentAlwaysAllowedMinters\\n{\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Basic system information\\n\\n    /**\\n     * Get the asset manager controller, the only address that can change settings.\\n     * Asset manager must be attached to the asset manager controller in the system contract registry.\\n     */\\n    function assetManagerController() external view returns (address);\\n\\n    /**\\n     * Get the f-asset contract managed by this asset manager instance.\\n     */\\n    function fAsset() external view returns (IERC20);\\n\\n    /**\\n     * Get the price reader contract used by this asset manager instance.\\n     */\\n    function priceReader() external view returns (address);\\n\\n    /**\\n     * Return lot size in UBA (underlying base amount - smallest amount on underlying chain, e.g. satoshi).\\n     */\\n    function lotSize() external view returns (uint256 _lotSizeUBA);\\n\\n    /**\\n     * Return asset minting granularity - smallest unit of f-asset stored internally\\n     * within this asset manager instance.\\n     */\\n    function assetMintingGranularityUBA() external view returns (uint256);\\n\\n    /**\\n     * Return asset minting decimals - the number of decimals of precision for minting.\\n\\n     */\\n    function assetMintingDecimals() external view returns (uint256);\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // System settings\\n\\n    /**\\n     * Get complete current settings.\\n     * @return the current settings\\n     */\\n    function getSettings()\\n        external\\n        view\\n        returns (AssetManagerSettings.Data memory);\\n\\n    /**\\n     * When `controllerAttached` is true, asset manager has been added to the asset manager controller.\\n     * This is required for the asset manager to be operational (create agent and minting don't work otherwise).\\n     */\\n    function controllerAttached() external view returns (bool);\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Emergency pause\\n\\n    /**\\n     * If true, the system is in emergency pause mode and most operations (mint, redeem, liquidate) are disabled.\\n     */\\n    function emergencyPaused() external view returns (bool);\\n\\n    /**\\n     * Emergency pause level defines which operations are paused:\\n     * NONE - pause is not active,\\n     * START_OPERATIONS - prevent starting mint, redeem, liquidation (start/liquidate) and core vault transfer/return,\\n     * FULL - everything from START_OPERATIONS, plus prevent finishing or defulating already started mints and redeems,\\n     * FULL_AND_TRANSFER - everything from FULL, plus prevent FAsset transfers.\\n     */\\n    function emergencyPauseLevel() external view returns (EmergencyPause.Level);\\n\\n    /**\\n     * The time when emergency pause mode will end automatically.\\n     */\\n    function emergencyPausedUntil() external view returns (uint256);\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Asset manager upgrading state\\n\\n    /**\\n     * True if the asset manager is paused.\\n     * In the paused state, minting is disabled, but all other operations (e.g. redemptions, liquidation) still work.\\n     * Paused asset manager can be later unpaused.\\n     */\\n    function mintingPaused() external view returns (bool);\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Timekeeping for underlying chain\\n\\n    /**\\n     * Prove that a block with given number and timestamp exists and\\n     * update the current underlying block info if the provided data is higher.\\n     * This method should be called by minters before minting and by agent's regularly\\n     * to prevent current block being too outdated, which gives too short time for\\n     * minting or redemption payment.\\n     * NOTE: anybody can call.\\n     * @param _proof proof that a block with given number and timestamp exists\\n     */\\n    function updateCurrentBlock(\\n        IConfirmedBlockHeightExists.Proof calldata _proof\\n    ) external;\\n\\n    /**\\n     * Get block number and timestamp of the current underlying block known to the f-asset system.\\n     * @return _blockNumber current underlying block number tracked by asset manager\\n     * @return _blockTimestamp current underlying block timestamp tracked by asset manager\\n     * @return _lastUpdateTs the timestamp on this chain when the current underlying block was last updated\\n     */\\n    function currentUnderlyingBlock()\\n        external\\n        view\\n        returns (\\n            uint256 _blockNumber,\\n            uint256 _blockTimestamp,\\n            uint256 _lastUpdateTs\\n        );\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Available collateral types\\n\\n    /**\\n     * Get collateral  information about a token.\\n     */\\n    function getCollateralType(\\n        CollateralType.Class _collateralClass,\\n        IERC20 _token\\n    ) external view returns (CollateralType.Data memory);\\n\\n    /**\\n     * Get the list of all available tokens used for collateral.\\n     */\\n    function getCollateralTypes()\\n        external\\n        view\\n        returns (CollateralType.Data[] memory);\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Agent create / destroy\\n\\n    /**\\n     * Create an agent vault.\\n     * The agent will always be identified by `_agentVault` address.\\n     * (Externally, one account may own several agent vaults,\\n     *  but in fasset system, each agent vault acts as an independent agent.)\\n     * NOTE: may only be called by an agent on the allowed agent list.\\n     * Can be called from the management or the work agent owner address.\\n     * @return _agentVault new agent vault address\\n     */\\n    function createAgentVault(\\n        IAddressValidity.Proof calldata _addressProof,\\n        AgentSettings.Data calldata _settings\\n    ) external returns (address _agentVault);\\n\\n    /**\\n     * Announce that the agent is going to be destroyed. At this time, the agent must not have any mintings\\n     * or collateral reservations and must not be on the available agents list.\\n     * NOTE: may only be called by the agent vault owner.\\n     * @return _destroyAllowedAt the timestamp at which the destroy can be executed\\n     */\\n    function announceDestroyAgent(\\n        address _agentVault\\n    ) external returns (uint256 _destroyAllowedAt);\\n\\n    /**\\n     * Delete all agent data, self destruct agent vault and send remaining collateral to the `_recipient`.\\n     * Procedure for destroying agent:\\n     * - exit available agents list\\n     * - wait until all assets are redeemed or perform self-close\\n     * - announce destroy (and wait the required time)\\n     * - call destroyAgent()\\n     * NOTE: may only be called by the agent vault owner.\\n     * NOTE: the remaining funds from the vault will be transferred to the provided recipient.\\n     * @param _agentVault address of the agent's vault to destroy\\n     * @param _recipient address that receives the remaining funds and possible vault balance\\n     */\\n    function destroyAgent(\\n        address _agentVault,\\n        address payable _recipient\\n    ) external;\\n\\n    /**\\n     * When agent vault, collateral pool or collateral pool token factory is upgraded, new agent vaults\\n     * automatically get the new implementation from the factory. But the existing agent vaults must\\n     * be upgraded by their owners using this method.\\n     * NOTE: may only be called by the agent vault owner.\\n     * @param _agentVault address of the agent's vault; both vault, its corresponding pool, and\\n     *  its pool token will be upgraded to the newest implementations\\n     */\\n    function upgradeAgentVaultAndPool(address _agentVault) external;\\n\\n    /**\\n     * Check if the collateral pool token has been used already by some vault.\\n     * @param _suffix the suffix to check\\n     */\\n    function isPoolTokenSuffixReserved(\\n        string memory _suffix\\n    ) external view returns (bool);\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Agent settings update\\n\\n    /**\\n     * Due to the effect on the pool, all agent settings are timelocked.\\n     * This method announces a setting change. The change can be executed after the timelock expires.\\n     * NOTE: may only be called by the agent vault owner.\\n     * @param _agentVault agent vault address\\n     * @param _name setting name, same as for `getAgentSetting`\\n     * @return _updateAllowedAt the timestamp at which the update can be executed\\n     */\\n    function announceAgentSettingUpdate(\\n        address _agentVault,\\n        string memory _name,\\n        uint256 _value\\n    ) external returns (uint256 _updateAllowedAt);\\n\\n    /**\\n     * Due to the effect on the pool, all agent settings are timelocked.\\n     * This method executes a setting change after the timelock expires.\\n     * NOTE: may only be called by the agent vault owner.\\n     * @param _agentVault agent vault address\\n     * @param _name setting name, same as for `getAgentSetting`\\n     */\\n    function executeAgentSettingUpdate(\\n        address _agentVault,\\n        string memory _name\\n    ) external;\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Collateral withdrawal announcement\\n\\n    /**\\n     * The agent is going to withdraw `_valueNATWei` amount of collateral from the agent vault.\\n     * This has to be announced and the agent must then wait `withdrawalWaitMinSeconds` time.\\n     * After that time, the agent can call `withdrawCollateral(_vaultCollateralToken, _valueNATWei)`\\n     * on the agent vault.\\n     * NOTE: may only be called by the agent vault owner.\\n     * @param _agentVault agent vault address\\n     * @param _valueNATWei the amount to be withdrawn\\n     * @return _withdrawalAllowedAt the timestamp when the withdrawal can be made\\n     */\\n    function announceVaultCollateralWithdrawal(\\n        address _agentVault,\\n        uint256 _valueNATWei\\n    ) external returns (uint256 _withdrawalAllowedAt);\\n\\n    /**\\n     * The agent is going to redeem `_valueWei` collateral pool tokens in the agent vault.\\n     * This has to be announced and the agent must then wait `withdrawalWaitMinSeconds` time.\\n     * After that time, the agent can call `redeemCollateralPoolTokens(_valueNATWei)` on the agent vault.\\n     * NOTE: may only be called by the agent vault owner.\\n     * @param _agentVault agent vault address\\n     * @param _valueNATWei the amount to be withdrawn\\n     * @return _redemptionAllowedAt the timestamp when the redemption can be made\\n     */\\n    function announceAgentPoolTokenRedemption(\\n        address _agentVault,\\n        uint256 _valueNATWei\\n    ) external returns (uint256 _redemptionAllowedAt);\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Underlying balance topup\\n\\n    /**\\n     * When the agent tops up his underlying address, it has to be confirmed by calling this method,\\n     * which updates the underlying free balance value.\\n     * NOTE: may only be called by the agent vault owner.\\n     * @param _payment proof of the underlying payment; must include payment\\n     *      reference of the form `0x4642505266410011000...0<agents_vault_address>`\\n     * @param _agentVault agent vault address\\n     */\\n    function confirmTopupPayment(\\n        IPayment.Proof calldata _payment,\\n        address _agentVault\\n    ) external;\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Underlying withdrawal announcements\\n\\n    /**\\n     * Announce withdrawal of underlying currency.\\n     * In the event UnderlyingWithdrawalAnnounced the agent receives payment reference, which must be\\n     * added to the payment, otherwise it can be challenged as illegal.\\n     * Until the announced withdrawal is performed and confirmed or canceled, no other withdrawal can be announced.\\n     * NOTE: may only be called by the agent vault owner.\\n     * @param _agentVault agent vault address\\n     */\\n    function announceUnderlyingWithdrawal(address _agentVault) external;\\n\\n    /**\\n     * Agent must provide confirmation of performed underlying withdrawal, which updates free balance with used gas\\n     * and releases announcement so that a new one can be made.\\n     * If the agent doesn't call this method, anyone can call it after a time (`confirmationByOthersAfterSeconds`).\\n     * NOTE: may only be called by the owner of the agent vault\\n     *   except if enough time has passed without confirmation - then it can be called by anybody.\\n     * @param _payment proof of the underlying payment\\n     * @param _agentVault agent vault address\\n     */\\n    function confirmUnderlyingWithdrawal(\\n        IPayment.Proof calldata _payment,\\n        address _agentVault\\n    ) external;\\n\\n    /**\\n     * Cancel ongoing withdrawal of underlying currency.\\n     * Needed in order to reset announcement timestamp, so that others cannot front-run the agent at\\n     * `confirmUnderlyingWithdrawal` call. This could happen if withdrawal would be performed more\\n     * than `confirmationByOthersAfterSeconds` seconds after announcement.\\n     * NOTE: may only be called by the agent vault owner.\\n     * @param _agentVault agent vault address\\n     */\\n    function cancelUnderlyingWithdrawal(address _agentVault) external;\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Agent information\\n\\n    /**\\n     * Get (a part of) the list of all agents.\\n     * The list must be retrieved in parts since retrieving the whole list can consume too much gas for one block.\\n     * @param _start first index to return from the available agent's list\\n     * @param _end end index (one above last) to return from the available agent's list\\n     */\\n    function getAllAgents(\\n        uint256 _start,\\n        uint256 _end\\n    ) external view returns (address[] memory _agents, uint256 _totalLength);\\n\\n    /**\\n     * Return detailed info about an agent, typically needed by a minter.\\n     * @param _agentVault agent vault address\\n     * @return structure containing agent's minting fee (BIPS), min collateral ratio (BIPS),\\n     *      and current free collateral (lots)\\n     */\\n    function getAgentInfo(\\n        address _agentVault\\n    ) external view returns (AgentInfo.Info memory);\\n\\n    /**\\n     * Get agent's setting by name.\\n     * This allows reading individual settings.\\n     * @param _agentVault agent vault address\\n     * @param _name setting name, one of: `feeBIPS`, `poolFeeShareBIPS`, `redemptionPoolFeeShareBIPS`,\\n     *  `mintingVaultCollateralRatioBIPS`, `mintingPoolCollateralRatioBIPS`,`buyFAssetByAgentFactorBIPS`,\\n     *  `poolExitCollateralRatioBIPS`\\n     */\\n    function getAgentSetting(\\n        address _agentVault,\\n        string memory _name\\n    ) external view returns (uint256);\\n\\n    /**\\n     * Returns the collateral pool address of the agent identified by `_agentVault`.\\n     */\\n    function getCollateralPool(\\n        address _agentVault\\n    ) external view returns (address);\\n\\n    /**\\n     * Return the management address of the owner of the agent identified by `_agentVault`.\\n     */\\n    function getAgentVaultOwner(\\n        address _agentVault\\n    ) external view returns (address _ownerManagementAddress);\\n\\n    /**\\n     * Return vault collateral ERC20 token chosen by the agent identified by `_agentVault`.\\n     */\\n    function getAgentVaultCollateralToken(\\n        address _agentVault\\n    ) external view returns (IERC20);\\n\\n    /**\\n     * Return full vault collateral (free + locked) deposited in the vault `_agentVault`.\\n     */\\n    function getAgentFullVaultCollateral(\\n        address _agentVault\\n    ) external view returns (uint256);\\n\\n    /**\\n     * Return full pool NAT collateral (free + locked) deposited in the vault `_agentVault`.\\n     */\\n    function getAgentFullPoolCollateral(\\n        address _agentVault\\n    ) external view returns (uint256);\\n\\n    /**\\n     * Return the current liquidation factors and max liquidation amount of the agent\\n     * identified by `_agentVault`.\\n     */\\n    function getAgentLiquidationFactorsAndMaxAmount(\\n        address _agentVault\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 liquidationPaymentFactorVaultBIPS,\\n            uint256 liquidationPaymentFactorPoolBIPS,\\n            uint256 maxLiquidationAmountUBA\\n        );\\n\\n    /**\\n     * Return the minimum collateral ratio of the pool collateral owned by vault `_agentVault`.\\n     */\\n    function getAgentMinPoolCollateralRatioBIPS(\\n        address _agentVault\\n    ) external view returns (uint256);\\n\\n    /**\\n     * Return the minimum collateral ratio of the vault collateral owned by vault `_agentVault`.\\n     */\\n    function getAgentMinVaultCollateralRatioBIPS(\\n        address _agentVault\\n    ) external view returns (uint256);\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // List of available agents (i.e. publicly available for minting).\\n\\n    /**\\n     * Add the agent to the list of publicly available agents.\\n     * Other agents can only self-mint.\\n     * NOTE: may only be called by the agent vault owner.\\n     * @param _agentVault agent vault address\\n     */\\n    function makeAgentAvailable(address _agentVault) external;\\n\\n    /**\\n     * Announce exit from the publicly available agents list.\\n     * NOTE: may only be called by the agent vault owner.\\n     * @param _agentVault agent vault address\\n     * @return _exitAllowedAt the timestamp when the agent can exit\\n     */\\n    function announceExitAvailableAgentList(\\n        address _agentVault\\n    ) external returns (uint256 _exitAllowedAt);\\n\\n    /**\\n     * Exit the publicly available agents list.\\n     * NOTE: may only be called by the agent vault owner and after announcement.\\n     * @param _agentVault agent vault address\\n     */\\n    function exitAvailableAgentList(address _agentVault) external;\\n\\n    /**\\n     * Get (a part of) the list of available agents.\\n     * The list must be retrieved in parts since retrieving the whole list can consume too much gas for one block.\\n     * @param _start first index to return from the available agent's list\\n     * @param _end end index (one above last) to return from the available agent's list\\n     */\\n    function getAvailableAgentsList(\\n        uint256 _start,\\n        uint256 _end\\n    ) external view returns (address[] memory _agents, uint256 _totalLength);\\n\\n    /**\\n     * Get (a part of) the list of available agents with extra information about agents' fee, min collateral ratio\\n     * and available collateral (in lots).\\n     * The list must be retrieved in parts since retrieving the whole list can consume too much gas for one block.\\n     * NOTE: agent's available collateral can change anytime due to price changes, minting, or changes\\n     * in agent's min collateral ratio, so it is only to be used as an estimate.\\n     * @param _start first index to return from the available agent's list\\n     * @param _end end index (one above last) to return from the available agent's list\\n     */\\n    function getAvailableAgentsDetailedList(\\n        uint256 _start,\\n        uint256 _end\\n    )\\n        external\\n        view\\n        returns (\\n            AvailableAgentInfo.Data[] memory _agents,\\n            uint256 _totalLength\\n        );\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Minting\\n\\n    /**\\n     * Before paying underlying assets for minting, minter has to reserve collateral and\\n     * pay collateral reservation fee. Collateral is reserved at ratio of agent's agentMinCollateralRatio\\n     * to requested lots NAT market price.\\n     * The minter receives instructions for underlying payment\\n     * (value, fee and payment reference) in event CollateralReserved.\\n     * Then the minter has to pay `value + fee` on the underlying chain.\\n     * If the minter pays the underlying amount, minter obtains f-assets.\\n     * The collateral reservation fee is split between the agent and the collateral pool.\\n     * NOTE: the owner of the agent vault must be in the AgentOwnerRegistry.\\n     * @param _agentVault agent vault address\\n     * @param _lots the number of lots for which to reserve collateral\\n     * @param _maxMintingFeeBIPS maximum minting fee (BIPS) that can be charged by the agent - best is just to\\n     *      copy current agent's published fee; used to prevent agent from front-running reservation request\\n     *      and increasing fee (that would mean that the minter would have to pay raised fee or forfeit\\n     *      collateral reservation fee)\\n     * @param _executor the account that is allowed to execute minting (besides minter and agent)\\n     */\\n    function reserveCollateral(\\n        address _agentVault,\\n        uint256 _lots,\\n        uint256 _maxMintingFeeBIPS,\\n        address payable _executor\\n    ) external payable returns (uint256 _collateralReservationId);\\n\\n    /**\\n     * Return the collateral reservation fee amount that has to be passed to the `reserveCollateral` method.\\n     * NOTE: the amount paid may be larger than the required amount, but the difference is not returned.\\n     * It is advised that the minter pays the exact amount, but when the amount is so small that the revert\\n     * would cost more than the lost difference, the minter may want to send a slightly larger amount to compensate\\n     * for the possibility of a FTSO price change between obtaining this value and calling `reserveCollateral`.\\n     * @param _lots the number of lots for which to reserve collateral\\n     * @return _reservationFeeNATWei the amount of reservation fee in NAT wei\\n     */\\n    function collateralReservationFee(\\n        uint256 _lots\\n    ) external view returns (uint256 _reservationFeeNATWei);\\n\\n    /**\\n     * Returns the data about the collateral reservation for an ongoing minting.\\n     * Note: once the minting is executed or defaulted, the collateral reservation is deleted and this method fails.\\n     * @param _collateralReservationId the collateral reservation id, as used for executing or defaulting the minting\\n     */\\n    function collateralReservationInfo(\\n        uint256 _collateralReservationId\\n    ) external view returns (CollateralReservationInfo.Data memory);\\n\\n    /**\\n     * After obtaining proof of underlying payment, the minter calls this method to finish the minting\\n     * and collect the minted f-assets.\\n     * NOTE: may only be called by the minter (= creator of CR, the collateral reservation request),\\n     *   the executor appointed by the minter, or the agent owner (= owner of the agent vault in CR).\\n     * @param _payment proof of the underlying payment (must contain exact `value + fee` amount and correct\\n     *      payment reference)\\n     * @param _collateralReservationId collateral reservation id\\n     */\\n    function executeMinting(\\n        IPayment.Proof calldata _payment,\\n        uint256 _collateralReservationId\\n    ) external;\\n\\n    /**\\n     * When the time for the minter to pay the underlying amount is over (i.e. the last underlying block has passed),\\n     * the agent can declare payment default. Then the agent collects the collateral reservation fee\\n     * (it goes directly to the vault), and the reserved collateral is unlocked.\\n     * NOTE: The attestation request must be done with `checkSourceAddresses=false`.\\n     * NOTE: may only be called by the owner of the agent vault in the collateral reservation request.\\n     * @param _proof proof that the minter didn't pay with correct payment reference on the underlying chain\\n     * @param _collateralReservationId id of a collateral reservation created by the minter\\n     */\\n    function mintingPaymentDefault(\\n        IReferencedPaymentNonexistence.Proof calldata _proof,\\n        uint256 _collateralReservationId\\n    ) external;\\n\\n    /**\\n     * The minter can make several mistakes in the underlying payment:\\n     * - the payment is too late and is already defaulted before executing\\n     * - the payment is too small so executeMinting reverts\\n     * - the payment is performed twice\\n     * In all of these cases the paid amount ends up on the agent vault's underlying account, but it is not\\n     * confirmed and therefore the agent cannot withdraw it without triggering full liquidation (of course\\n     * the agent can legally withdraw it once the vault is closed).\\n     * This method enables the agent to confirm such payments, converting the deposited amount to agent's\\n     * free underlying.\\n     * NOTE: may only be called by the agent vault owner.\\n     * @param _payment proof of the underlying payment (must have correct payment reference)\\n     * @param _collateralReservationId collateral reservation id\\n     */\\n    function confirmClosedMintingPayment(\\n        IPayment.Proof calldata _payment,\\n        uint256 _collateralReservationId\\n    ) external;\\n\\n    /**\\n     * If a collateral reservation request exists for more than 24 hours, payment or non-payment proof are no longer\\n     * available. In this case the agent can call this method, which burns reserved collateral at market price\\n     * and releases the remaining collateral (CRF is also burned).\\n     * NOTE: may only be called by the owner of the agent vault in the collateral reservation request.\\n     * NOTE: the agent (management address) receives the vault collateral and NAT is burned instead. Therefore\\n     *      this method is `payable` and the caller must provide enough NAT to cover the received vault collateral\\n     *      amount multiplied by `vaultCollateralBuyForFlareFactorBIPS`.\\n     * @param _proof proof that the attestation query window can not not contain\\n     *      the payment/non-payment proof anymore\\n     * @param _collateralReservationId collateral reservation id\\n     */\\n    function unstickMinting(\\n        IConfirmedBlockHeightExists.Proof calldata _proof,\\n        uint256 _collateralReservationId\\n    ) external payable;\\n\\n    /**\\n     * Agent can mint against himself.\\n     * This is a one-step process, skipping collateral reservation and collateral reservation fee payment.\\n     * Moreover, the agent doesn't have to be on the publicly available agents list to self-mint.\\n     * NOTE: may only be called by the agent vault owner.\\n     * NOTE: the caller must be a whitelisted agent.\\n     * @param _payment proof of the underlying payment; must contain payment reference of the form\\n     *      `0x4642505266410012000...0<agent_vault_address>`\\n     * @param _agentVault agent vault address\\n     * @param _lots number of lots to mint\\n     */\\n    function selfMint(\\n        IPayment.Proof calldata _payment,\\n        address _agentVault,\\n        uint256 _lots\\n    ) external;\\n\\n    /**\\n     * If an agent has enough free underlying, they can mint immediately without any underlying payment.\\n     * This is a one-step process, skipping collateral reservation and collateral reservation fee payment.\\n     * Moreover, the agent doesn't have to be on the publicly available agents list to self-mint.\\n     * NOTE: may only be called by the agent vault owner.\\n     * NOTE: the caller must be a whitelisted agent.\\n     * @param _agentVault agent vault address\\n     * @param _lots number of lots to mint\\n     */\\n    function mintFromFreeUnderlying(address _agentVault, uint64 _lots) external;\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Redemption\\n\\n    /**\\n     * Redeem (up to) `_lots` lots of f-assets. The corresponding amount of the f-assets belonging\\n     * to the redeemer will be burned and the redeemer will get paid by the agent in underlying currency\\n     * (or, in case of agent's payment default, by agent's collateral with a premium).\\n     * NOTE: in some cases not all sent f-assets can be redeemed (either there are not enough tickets or\\n     * more than a fixed limit of tickets should be redeemed). In this case only part of the approved assets\\n     * are burned and redeemed and the redeemer can execute this method again for the remaining lots.\\n     * In such a case the `RedemptionRequestIncomplete` event will be emitted, indicating the number\\n     * of remaining lots.\\n     * Agent receives redemption request id and instructions for underlying payment in\\n     * RedemptionRequested event and has to pay `value - fee` and use the provided payment reference.\\n     * @param _lots number of lots to redeem\\n     * @param _redeemerUnderlyingAddressString the address to which the agent must transfer underlying amount\\n     * @param _executor the account that is allowed to execute redemption default (besides redeemer and agent)\\n     * @return _redeemedAmountUBA the actual redeemed amount; may be less than requested if there are not enough\\n     *      redemption tickets available or the maximum redemption ticket limit is reached\\n     */\\n    function redeem(\\n        uint256 _lots,\\n        string memory _redeemerUnderlyingAddressString,\\n        address payable _executor\\n    ) external payable returns (uint256 _redeemedAmountUBA);\\n\\n    /**\\n     * If the redeemer provides invalid address, the agent should provide the proof of address invalidity from the\\n     * Flare data connector. With this, the agent's obligations are fulfilled and they can keep the underlying.\\n     * NOTE: may only be called by the owner of the agent vault in the redemption request\\n     * NOTE: also checks that redeemer's address is normalized, so the redeemer must normalize their address,\\n     *   otherwise it will be rejected!\\n     * @param _proof proof that the address is invalid\\n     * @param _redemptionRequestId id of an existing redemption request\\n     */\\n    function rejectInvalidRedemption(\\n        IAddressValidity.Proof calldata _proof,\\n        uint256 _redemptionRequestId\\n    ) external;\\n\\n    /**\\n     * After paying to the redeemer, the agent must call this method to unlock the collateral\\n     * and to make sure that the redeemer cannot demand payment in collateral on timeout.\\n     * The same method must be called for any payment status (SUCCESS, FAILED, BLOCKED).\\n     * In case of FAILED, it just releases the agent's underlying funds and the redeemer gets paid in collateral\\n     * after calling redemptionPaymentDefault.\\n     * In case of SUCCESS or BLOCKED, remaining underlying funds and collateral are released to the agent.\\n     * If the agent doesn't confirm payment in enough time (several hours, setting\\n     * `confirmationByOthersAfterSeconds`), anybody can do it and get rewarded from the agent's vault.\\n     * NOTE: may only be called by the owner of the agent vault in the redemption request\\n     *   except if enough time has passed without confirmation - then it can be called by anybody\\n     * @param _payment proof of the underlying payment (must contain exact `value - fee` amount and correct\\n     *      payment reference)\\n     * @param _redemptionRequestId id of an existing redemption request\\n     */\\n    function confirmRedemptionPayment(\\n        IPayment.Proof calldata _payment,\\n        uint256 _redemptionRequestId\\n    ) external;\\n\\n    /**\\n     * If the agent doesn't transfer the redeemed underlying assets in time (until the last allowed block on\\n     * the underlying chain), the redeemer calls this method and receives payment in collateral (with some extra).\\n     * The agent can also call default if the redeemer is unresponsive, to payout the redeemer and free the\\n     * remaining collateral.\\n     * NOTE: The attestation request must be done with `checkSourceAddresses=false`.\\n     * NOTE: may only be called by the redeemer (= creator of the redemption request),\\n     *   the executor appointed by the redeemer,\\n     *   or the agent owner (= owner of the agent vault in the redemption request)\\n     * @param _proof proof that the agent didn't pay with correct payment reference on the underlying chain\\n     * @param _redemptionRequestId id of an existing redemption request\\n     */\\n    function redemptionPaymentDefault(\\n        IReferencedPaymentNonexistence.Proof calldata _proof,\\n        uint256 _redemptionRequestId\\n    ) external;\\n\\n    /**\\n     * If the agent hasn't performed the payment, the agent can close the redemption request to free underlying funds.\\n     * It can be done immediately after the redeemer or agent calls `redemptionPaymentDefault`,\\n     * or this method can trigger the default payment without proof, but only after enough time has passed so that\\n     * attestation proof of non-payment is not available any more.\\n     * NOTE: may only be called by the owner of the agent vault in the redemption request.\\n     * @param _proof proof that the attestation query window can not not contain\\n     *      the payment/non-payment proof anymore\\n     * @param _redemptionRequestId id of an existing, but already defaulted, redemption request\\n     */\\n    function finishRedemptionWithoutPayment(\\n        IConfirmedBlockHeightExists.Proof calldata _proof,\\n        uint256 _redemptionRequestId\\n    ) external;\\n\\n    /**\\n     * Returns the data about an ongoing redemption request.\\n     * Note: once the redemptions is confirmed, the request is deleted and this method fails.\\n     * However, if there is no payment and the redemption defaults, the method works and returns status DEFAULTED.\\n     * @param _redemptionRequestId the redemption request id, as used for confirming or defaulting the redemption\\n     */\\n    function redemptionRequestInfo(\\n        uint256 _redemptionRequestId\\n    ) external view returns (RedemptionRequestInfo.Data memory);\\n\\n    /**\\n     * Agent can \\\"redeem against himself\\\" by calling `selfClose`, which burns agent's own f-assets\\n     * and unlocks agent's collateral. The underlying funds backing the f-assets are released\\n     * as agent's free underlying funds and can be later withdrawn after announcement.\\n     * NOTE: may only be called by the agent vault owner.\\n     * @param _agentVault agent vault address\\n     * @param _amountUBA amount of f-assets to self-close\\n     * @return _closedAmountUBA the actual self-closed amount, may be less than requested if there are not enough\\n     *      redemption tickets available or the maximum redemption ticket limit is reached\\n     */\\n    function selfClose(\\n        address _agentVault,\\n        uint256 _amountUBA\\n    ) external returns (uint256 _closedAmountUBA);\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Redemption queue info\\n\\n    /**\\n     * Return (part of) the redemption queue.\\n     * @param _firstRedemptionTicketId the ticket id to start listing from; if 0, starts from the beginning\\n     * @param _pageSize the maximum number of redemption tickets to return\\n     * @return _queue the (part of) the redemption queue; maximum length is _pageSize\\n     * @return _nextRedemptionTicketId works as a cursor - if the _pageSize is reached and there are more tickets,\\n     *  it is the first ticket id not returned; if the end is reached, it is 0\\n     */\\n    function redemptionQueue(\\n        uint256 _firstRedemptionTicketId,\\n        uint256 _pageSize\\n    )\\n        external\\n        view\\n        returns (\\n            RedemptionTicketInfo.Data[] memory _queue,\\n            uint256 _nextRedemptionTicketId\\n        );\\n\\n    /**\\n     * Return (part of) the redemption queue for a specific agent.\\n     * @param _agentVault the agent vault address of the queried agent\\n     * @param _firstRedemptionTicketId the ticket id to start listing from; if 0, starts from the beginning\\n     * @param _pageSize the maximum number of redemption tickets to return\\n     * @return _queue the (part of) the redemption queue; maximum length is _pageSize\\n     * @return _nextRedemptionTicketId works as a cursor - if the _pageSize is reached and there are more tickets,\\n     *  it is the first ticket id not returned; if the end is reached, it is 0\\n     */\\n    function agentRedemptionQueue(\\n        address _agentVault,\\n        uint256 _firstRedemptionTicketId,\\n        uint256 _pageSize\\n    )\\n        external\\n        view\\n        returns (\\n            RedemptionTicketInfo.Data[] memory _queue,\\n            uint256 _nextRedemptionTicketId\\n        );\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Dust and small ticket management\\n\\n    /**\\n     * Due to the minting pool fees or after a lot size change by the governance,\\n     * it may happen that less than one lot remains on a redemption ticket. This is named \\\"dust\\\" and\\n     * can be self closed or liquidated, but not redeemed. However, after several additions,\\n     * the total dust can amount to more than one lot. Using this method, the amount, rounded down\\n     * to a whole number of lots, can be converted to a new redemption ticket.\\n     * NOTE: we do NOT check that the caller is the agent vault owner, since we want to\\n     * allow anyone to convert dust to tickets to increase asset fungibility.\\n     * NOTE: dust above 1 lot is actually added to ticket at every minting, so this function need\\n     * only be called when the agent doesn't have any minting.\\n     * @param _agentVault agent vault address\\n     */\\n    function convertDustToTicket(address _agentVault) external;\\n\\n    /**\\n     * If lot size is increased, there may be many tickets less than one lot in the queue.\\n     * In extreme cases, this could prevent redemptions, if there weren't any tickets above 1 lot\\n     * among the first `maxRedeemedTickets` tickets.\\n     * To fix this, call this method. It converts small tickets to dust and when the dust exceeds one lot\\n     * adds it to the ticket.\\n     * Since the method just cleans the redemption queue it can be called by anybody.\\n     * @param _firstTicketId if nonzero, the ticket id of starting ticket; if zero, the starting ticket will\\n     *   be the redemption queue's first ticket id.\\n     *   When the method finishes, it emits RedemptionTicketsConsolidated event with the nextTicketId\\n     *   parameter. If it is nonzero, the method should be invoked again with this value as _firstTicketId.\\n     */\\n    function consolidateSmallTickets(uint256 _firstTicketId) external;\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Liquidation\\n\\n    /**\\n     * Checks that the agent's collateral is too low and if true, starts agent's liquidation.\\n     * If the agent is already in liquidation, returns the timestamp when liquidation started.\\n     * @param _agentVault agent vault address\\n     * @return _liquidationStartTs timestamp when liquidation started\\n     */\\n    function startLiquidation(\\n        address _agentVault\\n    ) external returns (uint256 _liquidationStartTs);\\n\\n    /**\\n     * Burns up to `_amountUBA` f-assets owned by the caller and pays\\n     * the caller the corresponding amount of native currency with premium\\n     * (premium depends on the liquidation state).\\n     * If the agent isn't in liquidation yet, but satisfies conditions,\\n     * automatically puts the agent in liquidation status.\\n     * @param _agentVault agent vault address\\n     * @param _amountUBA the amount of f-assets to liquidate\\n     * @return _liquidatedAmountUBA liquidated amount of f-asset\\n     * @return _amountPaidVault amount paid to liquidator (in agent's vault collateral)\\n     * @return _amountPaidPool amount paid to liquidator (in NAT from pool)\\n     */\\n    function liquidate(\\n        address _agentVault,\\n        uint256 _amountUBA\\n    )\\n        external\\n        returns (\\n            uint256 _liquidatedAmountUBA,\\n            uint256 _amountPaidVault,\\n            uint256 _amountPaidPool\\n        );\\n\\n    /**\\n     * When the agent's collateral reaches the safe level during liquidation, the liquidation\\n     * process can be stopped by calling this method.\\n     * Full liquidation (i.e. the liquidation triggered by illegal underlying payment)\\n     * cannot be stopped.\\n     * NOTE: anybody can call.\\n     * NOTE: if the method succeeds, the agent's liquidation has ended.\\n     * @param _agentVault agent vault address\\n     */\\n    function endLiquidation(address _agentVault) external;\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Challenges\\n\\n    /**\\n     * Called with a proof of payment made from the agent's underlying address, for which\\n     * no valid payment reference exists (valid payment references are from redemption and\\n     * underlying withdrawal announcement calls).\\n     * On success, immediately triggers full agent liquidation and rewards the caller.\\n     * @param _payment proof of a transaction from the agent's underlying address\\n     * @param _agentVault agent vault address\\n     */\\n    function illegalPaymentChallenge(\\n        IBalanceDecreasingTransaction.Proof calldata _payment,\\n        address _agentVault\\n    ) external;\\n\\n    /**\\n     * Called with proofs of two payments made from the agent's underlying address\\n     * with the same payment reference (each payment reference is valid for only one payment).\\n     * On success, immediately triggers full agent liquidation and rewards the caller.\\n     * @param _payment1 proof of first payment from the agent's underlying address\\n     * @param _payment2 proof of second payment from the agent's underlying address\\n     * @param _agentVault agent vault address\\n     */\\n    function doublePaymentChallenge(\\n        IBalanceDecreasingTransaction.Proof calldata _payment1,\\n        IBalanceDecreasingTransaction.Proof calldata _payment2,\\n        address _agentVault\\n    ) external;\\n\\n    /**\\n     * Called with proofs of several (otherwise legal) payments, which together make the agent's\\n     * underlying free balance negative (i.e. the underlying address balance is less than\\n     * the total amount of backed f-assets).\\n     * On success, immediately triggers full agent liquidation and rewards the caller.\\n     * @param _payments proofs of several distinct payments from the agent's underlying address\\n     * @param _agentVault agent vault address\\n     */\\n    function freeBalanceNegativeChallenge(\\n        IBalanceDecreasingTransaction.Proof[] calldata _payments,\\n        address _agentVault\\n    ) external;\\n}\\n\",\"keccak256\":\"0x1a58938a0add234a9dbae4619612a04c515dc2277056c99c9f3386f391651c46\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IAssetManagerController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport {IAssetManager} from \\\"./IAssetManager.sol\\\";\\n\\ninterface IAssetManagerController {\\n    /**\\n     * Return the list of all asset managers managed by this controller.\\n     */\\n    function getAssetManagers() external view returns (IAssetManager[] memory);\\n\\n    /**\\n     * Check whether the asset manager is managed by this controller.\\n     * @param _assetManager an asset manager address\\n     */\\n    function assetManagerExists(\\n        address _assetManager\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xab970e2b8039700c01315597f46e30c744dbbad823e6c19816bdee9f792d9d99\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IAssetManagerEvents.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport {EmergencyPause} from \\\"./data/EmergencyPause.sol\\\";\\n\\n/**\\n * All asset manager events.\\n */\\ninterface IAssetManagerEvents {\\n    struct AgentVaultCreationData {\\n        address collateralPool;\\n        address collateralPoolToken;\\n        string underlyingAddress;\\n        address vaultCollateralToken;\\n        address poolWNatToken;\\n        uint256 feeBIPS;\\n        uint256 poolFeeShareBIPS;\\n        uint256 mintingVaultCollateralRatioBIPS;\\n        uint256 mintingPoolCollateralRatioBIPS;\\n        uint256 buyFAssetByAgentFactorBIPS;\\n        uint256 poolExitCollateralRatioBIPS;\\n        uint256 redemptionPoolFeeShareBIPS;\\n    }\\n\\n    /**\\n     * A new agent vault was created.\\n     */\\n    event AgentVaultCreated(\\n        address indexed owner,\\n        address indexed agentVault,\\n        AgentVaultCreationData creationData\\n    );\\n\\n    /**\\n     * Agent has announced destroy (close) of agent vault and will be able to\\n     * perform destroy after the timestamp `destroyAllowedAt`.\\n     */\\n    event AgentDestroyAnnounced(\\n        address indexed agentVault,\\n        uint256 destroyAllowedAt\\n    );\\n\\n    /**\\n     * Agent has destroyed (closed) the agent vault.\\n     */\\n    event AgentDestroyed(address indexed agentVault);\\n\\n    /**\\n     * Agent has announced a withdrawal of collateral and will be able to\\n     * withdraw the announced amount after timestamp `withdrawalAllowedAt`.\\n     * If withdrawal was canceled (announced with amount 0), amountWei and withdrawalAllowedAt are zero.\\n     */\\n    event VaultCollateralWithdrawalAnnounced(\\n        address indexed agentVault,\\n        uint256 amountWei,\\n        uint256 withdrawalAllowedAt\\n    );\\n\\n    /**\\n     * Agent has announced a withdrawal of collateral and will be able to\\n     * redeem the announced amount of pool tokens after the timestamp `withdrawalAllowedAt`.\\n     * If withdrawal was canceled (announced with amount 0), amountWei and withdrawalAllowedAt are zero.\\n     */\\n    event PoolTokenRedemptionAnnounced(\\n        address indexed agentVault,\\n        uint256 amountWei,\\n        uint256 withdrawalAllowedAt\\n    );\\n\\n    /**\\n     * Agent was added to the list of available agents and can accept collateral reservation requests.\\n     */\\n    event AgentAvailable(\\n        address indexed agentVault,\\n        uint256 feeBIPS,\\n        uint256 mintingVaultCollateralRatioBIPS,\\n        uint256 mintingPoolCollateralRatioBIPS,\\n        uint256 freeCollateralLots\\n    );\\n\\n    /**\\n     * Agent exited from available agents list.\\n     * The agent can exit the available list after the timestamp `exitAllowedAt`.\\n     */\\n    event AvailableAgentExitAnnounced(\\n        address indexed agentVault,\\n        uint256 exitAllowedAt\\n    );\\n\\n    /**\\n     * Agent exited from available agents list.\\n     */\\n    event AvailableAgentExited(address indexed agentVault);\\n\\n    /**\\n     * Agent has initiated setting change (fee or some agent collateral ratio change).\\n     * The setting change can be executed after the timestamp `validAt`.\\n     */\\n    event AgentSettingChangeAnnounced(\\n        address indexed agentVault,\\n        string name,\\n        uint256 value,\\n        uint256 validAt\\n    );\\n\\n    /**\\n     * Agent has executed setting change (fee or some agent collateral ratio change).\\n     */\\n    event AgentSettingChanged(\\n        address indexed agentVault,\\n        string name,\\n        uint256 value\\n    );\\n\\n    /**\\n     * Agent or agent's collateral pool has changed token contract.\\n     */\\n    event AgentCollateralTypeChanged(\\n        address indexed agentVault,\\n        uint8 collateralClass,\\n        address token\\n    );\\n\\n    /**\\n     * Minter reserved collateral, paid the reservation fee, and is expected to pay the underlying funds.\\n     * Agent's collateral was reserved.\\n     */\\n    event CollateralReserved(\\n        address indexed agentVault,\\n        address indexed minter,\\n        uint256 indexed collateralReservationId,\\n        uint256 valueUBA,\\n        uint256 feeUBA,\\n        uint256 firstUnderlyingBlock,\\n        uint256 lastUnderlyingBlock,\\n        uint256 lastUnderlyingTimestamp,\\n        string paymentAddress,\\n        bytes32 paymentReference,\\n        address executor,\\n        uint256 executorFeeNatWei\\n    );\\n\\n    /**\\n     * Minter paid underlying funds in time and received the fassets.\\n     * The agent's collateral is locked.\\n     */\\n    event MintingExecuted(\\n        address indexed agentVault,\\n        uint256 indexed collateralReservationId,\\n        uint256 mintedAmountUBA,\\n        uint256 agentFeeUBA,\\n        uint256 poolFeeUBA\\n    );\\n\\n    /**\\n     * Minter failed to pay underlying funds in time. Collateral reservation fee was paid to the agent.\\n     * Reserved collateral was released.\\n     */\\n    event MintingPaymentDefault(\\n        address indexed agentVault,\\n        address indexed minter,\\n        uint256 indexed collateralReservationId,\\n        uint256 reservedAmountUBA\\n    );\\n\\n    /**\\n     * Both minter and agent failed to present any proof within attestation time window, so\\n     * the agent called `unstickMinting` to release reserved collateral.\\n     */\\n    event CollateralReservationDeleted(\\n        address indexed agentVault,\\n        address indexed minter,\\n        uint256 indexed collateralReservationId,\\n        uint256 reservedAmountUBA\\n    );\\n\\n    /**\\n     * Emitted when a late or too small payment for an already defaulted or expired minting is confirmed.\\n     * It is equivalent to agent performing underlying topup.\\n     */\\n    event ConfirmedClosedMintingPayment(\\n        address indexed agentVault,\\n        bytes32 transactionHash,\\n        uint256 depositedUBA\\n    );\\n\\n    /**\\n     * Agent performed self minting, either by executing selfMint with underlying deposit or\\n     * by executing mintFromFreeUnderlying (in this case, `mintFromFreeUnderlying` is true and\\n     * `depositedAmountUBA` is zero).\\n     */\\n    event SelfMint(\\n        address indexed agentVault,\\n        bool mintFromFreeUnderlying,\\n        uint256 mintedAmountUBA,\\n        uint256 depositedAmountUBA,\\n        uint256 poolFeeUBA\\n    );\\n\\n    /**\\n     * Redeemer started the redemption process and provided fassets.\\n     * The amount of fassets corresponding to valueUBA was burned.\\n     * Several RedemptionRequested events are emitted, one for every agent redeemed against\\n     * (but multiple tickets for the same agent are combined).\\n     * The agent's collateral is still locked.\\n     */\\n    event RedemptionRequested(\\n        address indexed agentVault,\\n        address indexed redeemer,\\n        uint256 indexed requestId,\\n        string paymentAddress,\\n        uint256 valueUBA,\\n        uint256 feeUBA,\\n        uint256 firstUnderlyingBlock,\\n        uint256 lastUnderlyingBlock,\\n        uint256 lastUnderlyingTimestamp,\\n        bytes32 paymentReference,\\n        address executor,\\n        uint256 executorFeeNatWei\\n    );\\n\\n    /**\\n     * Agent rejected the redemption payment because the redeemer's address is invalid.\\n     */\\n    event RedemptionRejected(\\n        address indexed agentVault,\\n        address indexed redeemer,\\n        uint256 indexed requestId,\\n        uint256 redemptionAmountUBA\\n    );\\n\\n    /**\\n     * In case there were not enough tickets or more than allowed number would have to be redeemed,\\n     * only partial redemption is done and the `remainingLots` lots of the fassets are returned to\\n     * the redeemer.\\n     */\\n    event RedemptionRequestIncomplete(\\n        address indexed redeemer,\\n        uint256 remainingLots\\n    );\\n\\n    /**\\n     * Agent provided proof of redemption payment.\\n     * Agent's collateral is released.\\n     */\\n    event RedemptionPerformed(\\n        address indexed agentVault,\\n        address indexed redeemer,\\n        uint256 indexed requestId,\\n        bytes32 transactionHash,\\n        uint256 redemptionAmountUBA,\\n        int256 spentUnderlyingUBA\\n    );\\n\\n    /**\\n     * The time for redemption payment is over and payment proof was not provided.\\n     * Redeemer was paid in the collateral (with extra).\\n     * The rest of the agent's collateral is released.\\n     * The corresponding amount of underlying currency, held by the agent, is released\\n     * and the agent can withdraw it (after underlying withdrawal announcement).\\n     */\\n    event RedemptionDefault(\\n        address indexed agentVault,\\n        address indexed redeemer,\\n        uint256 indexed requestId,\\n        uint256 redemptionAmountUBA,\\n        uint256 redeemedVaultCollateralWei,\\n        uint256 redeemedPoolCollateralWei\\n    );\\n\\n    /**\\n     * Agent provided the proof that redemption payment was attempted, but failed due to\\n     * the redeemer's address being blocked (or burning more than allowed amount of gas).\\n     * Redeemer is not paid and all of the agent's collateral is released.\\n     * The underlying currency is also released to the agent.\\n     */\\n    event RedemptionPaymentBlocked(\\n        address indexed agentVault,\\n        address indexed redeemer,\\n        uint256 indexed requestId,\\n        bytes32 transactionHash,\\n        uint256 redemptionAmountUBA,\\n        int256 spentUnderlyingUBA\\n    );\\n\\n    /**\\n     * Agent provided the proof that redemption payment was attempted, but failed due to\\n     * his own error. Also triggers payment default, unless the redeemer has done it already.\\n     */\\n    event RedemptionPaymentFailed(\\n        address indexed agentVault,\\n        address indexed redeemer,\\n        uint256 indexed requestId,\\n        bytes32 transactionHash,\\n        int256 spentUnderlyingUBA,\\n        string failureReason\\n    );\\n\\n    /**\\n     * At the end of a successful redemption, part of the redemption fee is re-minted as FAssets\\n     * and paid to the agent's collateral pool as fee.\\n     */\\n    event RedemptionPoolFeeMinted(\\n        address indexed agentVault,\\n        uint256 indexed requestId,\\n        uint256 poolFeeUBA\\n    );\\n\\n    /**\\n     * Due to self-close exit, some of the agent's backed fAssets were redeemed,\\n     * but the redemption was immediately paid in collateral so no redemption process is started.\\n     */\\n    event RedeemedInCollateral(\\n        address indexed agentVault,\\n        address indexed redeemer,\\n        uint256 redemptionAmountUBA,\\n        uint256 paidVaultCollateralWei\\n    );\\n\\n    /**\\n     * Agent self-closed valueUBA of backing fassets.\\n     */\\n    event SelfClose(address indexed agentVault, uint256 valueUBA);\\n\\n    /**\\n     * Redemption ticket with given value was created (when minting was executed).\\n     */\\n    event RedemptionTicketCreated(\\n        address indexed agentVault,\\n        uint256 indexed redemptionTicketId,\\n        uint256 ticketValueUBA\\n    );\\n\\n    /**\\n     * Redemption ticket value was changed (partially redeemed).\\n     * @param ticketValueUBA the ticket value after update\\n     */\\n    event RedemptionTicketUpdated(\\n        address indexed agentVault,\\n        uint256 indexed redemptionTicketId,\\n        uint256 ticketValueUBA\\n    );\\n\\n    /**\\n     * Redemption ticket was deleted.\\n     */\\n    event RedemptionTicketDeleted(\\n        address indexed agentVault,\\n        uint256 indexed redemptionTicketId\\n    );\\n\\n    /**\\n     * Method `consolidateSmallTickets` has finished.\\n     * @param firstTicketId first handled ticket id (different from the method param _firstTicketId if it was 0).\\n     * @param nextTicketId the first remaining (not handled) ticket id, or 0 if the end of queue was reached.\\n     */\\n    event RedemptionTicketsConsolidated(\\n        uint256 firstTicketId,\\n        uint256 nextTicketId\\n    );\\n\\n    /**\\n     * Due to lot size change, some dust was created for this agent during\\n     * redemption. Value `dustUBA` is the new amount of dust. Dust cannot be directly redeemed,\\n     * but it can be self-closed or liquidated and if it accumulates to more than 1 lot,\\n     * it can be converted to a new redemption ticket.\\n     */\\n    event DustChanged(address indexed agentVault, uint256 dustUBA);\\n\\n    /**\\n     * Agent entered liquidation state due to unhealthy position.\\n     * The liquidation ends when the agent is again healthy or the agent's position is fully liquidated.\\n     */\\n    event LiquidationStarted(address indexed agentVault, uint256 timestamp);\\n\\n    /**\\n     * Agent entered liquidation state due to illegal payment.\\n     * Full liquidation will always liquidate the whole agent's position and\\n     * the agent can never use the same vault and underlying address for minting again.\\n     */\\n    event FullLiquidationStarted(address indexed agentVault, uint256 timestamp);\\n\\n    /**\\n     * Some of the agent's position was liquidated, by burning liquidator's fassets.\\n     * Liquidator was paid in collateral with extra.\\n     * The corresponding amount of underlying currency, held by the agent, is released\\n     * and the agent can withdraw it (after underlying withdrawal announcement).\\n     */\\n    event LiquidationPerformed(\\n        address indexed agentVault,\\n        address indexed liquidator,\\n        uint256 valueUBA,\\n        uint256 paidVaultCollateralWei,\\n        uint256 paidPoolCollateralWei\\n    );\\n\\n    /**\\n     * Agent exited liquidation state as agent's position was healthy again and not in full liquidation.\\n     */\\n    event LiquidationEnded(address indexed agentVault);\\n\\n    /**\\n     * Part of the balance in the agent's underlying address is \\\"free balance\\\" that the agent can withdraw.\\n     * It is obtained from minting / redemption fees and self-closed fassets.\\n     * Some of this amount should be left for paying redemption (and withdrawal) gas fees,\\n     * and the rest can be withdrawn by the agent.\\n     * However, withdrawal has to be announced, otherwise it can be challenged as illegal payment.\\n     * Only one announcement can exist per agent - agent has to present payment proof for withdrawal\\n     * before starting a new one.\\n     */\\n    event UnderlyingWithdrawalAnnounced(\\n        address indexed agentVault,\\n        uint256 indexed announcementId,\\n        bytes32 paymentReference\\n    );\\n\\n    /**\\n     * After announcing legal underlying withdrawal and creating transaction,\\n     * the agent must confirm the transaction. This frees the announcement so the agent can create another one.\\n     * If the agent doesn't confirm in time, anybody can confirm the transaction after several hours.\\n     * Failed payments must also be confirmed.\\n     */\\n    event UnderlyingWithdrawalConfirmed(\\n        address indexed agentVault,\\n        uint256 indexed announcementId,\\n        int256 spentUBA,\\n        bytes32 transactionHash\\n    );\\n\\n    /**\\n     * After announcing legal underlying withdrawal agent can cancel ongoing withdrawal.\\n     * The reason for doing that would be in resetting announcement timestamp due to any problems with underlying\\n     * withdrawal - in order to prevent others to confirm withdrawal before agent and get some of his collateral.\\n     */\\n    event UnderlyingWithdrawalCancelled(\\n        address indexed agentVault,\\n        uint256 indexed announcementId\\n    );\\n\\n    /**\\n     * Emitted when the agent tops up the underlying address balance.\\n     */\\n    event UnderlyingBalanceToppedUp(\\n        address indexed agentVault,\\n        bytes32 transactionHash,\\n        uint256 depositedUBA\\n    );\\n\\n    /**\\n     * Emitted whenever the tracked underlying balance changes.\\n     */\\n    event UnderlyingBalanceChanged(\\n        address indexed agentVault,\\n        int256 underlyingBalanceUBA\\n    );\\n\\n    /**\\n     * An unexpected transaction from the agent's underlying address was proved.\\n     * Whole agent's position goes into liquidation.\\n     * The challenger is rewarded from the agent's collateral.\\n     */\\n    event IllegalPaymentConfirmed(\\n        address indexed agentVault,\\n        bytes32 transactionHash\\n    );\\n\\n    /**\\n     * Two transactions with the same payment reference, both from the agent's underlying address, were proved.\\n     * Whole agent's position goes into liquidation.\\n     * The challenger is rewarded from the agent's collateral.\\n     */\\n    event DuplicatePaymentConfirmed(\\n        address indexed agentVault,\\n        bytes32 transactionHash1,\\n        bytes32 transactionHash2\\n    );\\n\\n    /**\\n     * Agent's underlying balance became lower than required for backing f-assets (either through payment or via\\n     * a challenge. Agent goes to a full liquidation.\\n     * The challenger is rewarded from the agent's collateral.\\n     */\\n    event UnderlyingBalanceTooLow(\\n        address indexed agentVault,\\n        int256 balance,\\n        uint256 requiredBalance\\n    );\\n\\n    /**\\n     * A setting has changed.\\n     */\\n    event SettingChanged(string name, uint256 value);\\n\\n    /**\\n     * A setting has changed.\\n     */\\n    event SettingArrayChanged(string name, uint256[] value);\\n\\n    /**\\n     * A contract in the settings has changed.\\n     */\\n    event ContractChanged(string name, address value);\\n\\n    /**\\n     * Current underlying block number or timestamp has been updated.\\n     */\\n    event CurrentUnderlyingBlockUpdated(\\n        uint256 underlyingBlockNumber,\\n        uint256 underlyingBlockTimestamp,\\n        uint256 updatedAt\\n    );\\n\\n    /**\\n     * New collateral token has been added.\\n     */\\n    event CollateralTypeAdded(\\n        uint8 collateralClass,\\n        address token,\\n        uint256 decimals,\\n        bool directPricePair,\\n        string assetFtsoSymbol,\\n        string tokenFtsoSymbol,\\n        uint256 minCollateralRatioBIPS,\\n        uint256 safetyMinCollateralRatioBIPS\\n    );\\n\\n    /**\\n     * System defined collateral ratios for the token have changed (minimal and safety collateral ratio).\\n     */\\n    event CollateralRatiosChanged(\\n        uint8 collateralClass,\\n        address collateralToken,\\n        uint256 minCollateralRatioBIPS,\\n        uint256 safetyMinCollateralRatioBIPS\\n    );\\n\\n    /**\\n     * Emergency pause was triggered.\\n     */\\n    event EmergencyPauseTriggered(\\n        EmergencyPause.Level externalLevel,\\n        uint256 externalPausedUntil,\\n        EmergencyPause.Level governanceLevel,\\n        uint256 governancePausedUntil\\n    );\\n\\n    /**\\n     * Emergency pause was canceled.\\n     */\\n    event EmergencyPauseCanceled();\\n}\\n\",\"keccak256\":\"0xb7885a2d270b8a7e130017f0a502c291a0dac192d69bf4c39ec68ffadeb40379\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IBalanceDecreasingTransaction.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * @custom:name IBalanceDecreasingTransaction\\n * @custom:id 0x02\\n * @custom:supported BTC, DOGE, XRP\\n * @author Flare\\n * @notice A detection of a transaction that either decreases the balance for some address or is\\n * signed by the source address.\\n * Such an attestation could prove a violation of an agreement and therefore provides grounds to liquidate\\n * some funds locked by a smart contract on Flare.\\n *\\n * A transaction is considered \\u201cbalance decreasing\\u201d for the address, if the balance after the\\n * transaction is lower than before or the address is among the signers of the transaction\\n * (even if its balance is greater than before the transaction).\\n * @custom:verification The transaction with `transactionId` is fetched from the API of the\\n * source blockchain node or relevant indexer.\\n * If the transaction cannot be fetched or the transaction is in a block that does not have a\\n * sufficient number of confirmations, the attestation request is rejected.\\n *\\n * Once the transaction is received, the response fields are extracted if the transaction is balance\\n * decreasing for the indicated address.\\n * Some of the request and response fields are chain specific as described below.\\n * The fields can be computed with the help of a balance decreasing summary.\\n *\\n * ### UTXO (Bitcoin and Dogecoin)\\n *\\n * - `sourceAddressIndicator` is the the index of the transaction input in hex padded to a 0x prefixed 32-byte string.\\n * If the indicated input does not exist or the indicated input does not have the address,\\n * the attestation request is rejected.\\n * The `sourceAddress` is the address of the indicated transaction input.\\n * - `spentAmount` is the sum of values of all inputs with sourceAddress minus the sum of\\n * all outputs with `sourceAddress`.\\n * Can be negative.\\n * - `blockTimestamp` is the mediantime of a block.\\n *\\n * ### XRPL\\n *\\n * - `sourceAddressIndicator` is the standard address hash of the address whose balance has been decreased.\\n * If the address indicated by `sourceAddressIndicator` is not among the signers of the transaction and the balance\\n * of the address was not lowered in the transaction, the attestation request is rejected.\\n *\\n * - `spentAmount` is the difference between the balance of the indicated address after and before the transaction.\\n * Can be negative.\\n * - `blockTimestamp` is the close_time of a ledger converted to unix time.\\n *\\n * @custom:lut `blockTimestamp`\\n * @custom:lutlimit `0x127500`, `0x127500`, `0x127500`\\n */\\ninterface IBalanceDecreasingTransaction {\\n    /**\\n     * @notice Toplevel request\\n     * @param attestationType ID of the attestation type.\\n     * @param sourceId ID of the data source.\\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.\\n     * @param requestBody Data defining the request. Type and interpretation is determined by the `attestationType`.\\n     */\\n    struct Request {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        bytes32 messageIntegrityCode;\\n        RequestBody requestBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel response\\n     * @param attestationType Extracted from the request.\\n     * @param sourceId Extracted from the request.\\n     * @param votingRound The ID of the State Connector round in which the request was considered.\\n     * This is a security measure to prevent a collision of attestation hashes.\\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\\n     * @param requestBody Extracted from the request.\\n     * @param responseBody Data defining the response. The verification rules for the construction of the\\n     * response body and the type are defined per specific `attestationType`.\\n     */\\n    struct Response {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        uint64 votingRound;\\n        uint64 lowestUsedTimestamp;\\n        RequestBody requestBody;\\n        ResponseBody responseBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel proof\\n     * @param merkleProof Merkle proof corresponding to the attestation response.\\n     * @param data Attestation response.\\n     */\\n    struct Proof {\\n        bytes32[] merkleProof;\\n        Response data;\\n    }\\n\\n    /**\\n     * @notice Request body for IBalanceDecreasingTransaction attestation type\\n     * @param transactionId ID of the payment transaction.\\n     * @param sourceAddressIndicator The indicator of the address whose balance has been decreased.\\n     */\\n    struct RequestBody {\\n        bytes32 transactionId;\\n        bytes32 sourceAddressIndicator;\\n    }\\n\\n    /**\\n     * @notice Response body for IBalanceDecreasingTransaction attestation type.\\n     * @param blockNumber The number of the block in which the transaction is included.\\n     * @param blockTimestamp The timestamp of the block in which the transaction is included.\\n     * @param sourceAddressHash Standard address hash of the address indicated by the `sourceAddressIndicator`.\\n     * @param spentAmount Amount spent by the source address in minimal units.\\n     * @param standardPaymentReference Standard payment reference of the transaction.\\n     */\\n    struct ResponseBody {\\n        uint64 blockNumber;\\n        uint64 blockTimestamp;\\n        bytes32 sourceAddressHash;\\n        int256 spentAmount;\\n        bytes32 standardPaymentReference;\\n    }\\n}\\n\",\"keccak256\":\"0x2981047bbc558613e917f4a421ac6f1ac6b1b404c57451f141ad8a4bf5121743\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IBalanceDecreasingTransactionVerification.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IBalanceDecreasingTransaction.sol\\\";\\n\\ninterface IBalanceDecreasingTransactionVerification {\\n    function verifyBalanceDecreasingTransaction(\\n        IBalanceDecreasingTransaction.Proof calldata _proof\\n    ) external view returns (bool _proved);\\n}\\n\",\"keccak256\":\"0x94531f48911ac9ef3ea3da54f5b374c7cd437ffb6be43e7ae06973cc67becee1\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IBn256.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n// G1Point implements a point in G1 group.\\nstruct G1Point {\\n    uint256 x;\\n    uint256 y;\\n}\\n\",\"keccak256\":\"0x7374284dbdfa33d5e0eea553bf7ff8b199aeeb663de652abcf9e88fa9af3ce63\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IClaimSetupManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IDelegationAccount.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IClaimSetupManager {\\n    event DelegationAccountCreated(\\n        address owner,\\n        IDelegationAccount delegationAccount\\n    );\\n    event DelegationAccountUpdated(\\n        address owner,\\n        IDelegationAccount delegationAccount,\\n        bool enabled\\n    );\\n    event ClaimExecutorsChanged(address owner, address[] executors);\\n    event AllowedClaimRecipientsChanged(address owner, address[] recipients);\\n    event ClaimExecutorFeeValueChanged(\\n        address executor,\\n        uint256 validFromRewardEpoch,\\n        uint256 feeValueWei\\n    );\\n    event ExecutorRegistered(address executor);\\n    event ExecutorUnregistered(address executor, uint256 validFromRewardEpoch);\\n    event MinFeeSet(uint256 minFeeValueWei);\\n    event MaxFeeSet(uint256 maxFeeValueWei);\\n    event RegisterExecutorFeeSet(uint256 registerExecutorFeeValueWei);\\n    event SetExecutorsExcessAmountRefunded(address owner, uint256 excessAmount);\\n\\n    /**\\n     * @notice Sets the addresses of executors and optionally enables (creates) delegation account.\\n     * @notice If setting registered executors some fee must be paid to them.\\n     * @param _executors        The new executors. All old executors will be deleted and replaced by these.\\n     */\\n    function setAutoClaiming(\\n        address[] memory _executors,\\n        bool _enableDelegationAccount\\n    ) external payable;\\n\\n    /**\\n     * @notice Sets the addresses of executors.\\n     * @notice If setting registered executors some fee must be paid to them.\\n     * @param _executors        The new executors. All old executors will be deleted and replaced by these.\\n     */\\n    function setClaimExecutors(address[] memory _executors) external payable;\\n\\n    /**\\n     * Set the addresses of allowed recipients.\\n     * Apart from these, the owner is always an allowed recipient.\\n     * @param _recipients The new allowed recipients. All old recipients will be deleted and replaced by these.\\n     */\\n    function setAllowedClaimRecipients(address[] memory _recipients) external;\\n\\n    /**\\n     * @notice Enables (creates) delegation account contract,\\n     * i.e. all airdrop and ftso rewards will be send to delegation account when using automatic claiming.\\n     * @return Address of delegation account contract.\\n     */\\n    function enableDelegationAccount() external returns (IDelegationAccount);\\n\\n    /**\\n     * @notice Disables delegation account contract,\\n     * i.e. all airdrop and ftso rewards will be send to owner's account when using automatic claiming.\\n     * @notice Automatic claiming will not claim airdrop and ftso rewards for delegation account anymore.\\n     * @dev Reverts if there is no delegation account\\n     */\\n    function disableDelegationAccount() external;\\n\\n    /**\\n     * @notice Allows executor to register and set initial fee value.\\n     * If executor was already registered before (has fee set), only update fee after `feeValueUpdateOffset`.\\n     * @notice Executor must pay fee in order to register - `registerExecutorFeeValueWei`.\\n     * @param _feeValue    number representing fee value\\n     * @return Returns the reward epoch number when the setting becomes effective.\\n     */\\n    function registerExecutor(\\n        uint256 _feeValue\\n    ) external payable returns (uint256);\\n\\n    /**\\n     * @notice Allows executor to unregister.\\n     * @return Returns the reward epoch number when the setting becomes effective.\\n     */\\n    function unregisterExecutor() external returns (uint256);\\n\\n    /**\\n     * @notice Allows registered executor to set (or update last scheduled) fee value.\\n     * @param _feeValue    number representing fee value\\n     * @return Returns the reward epoch number when the setting becomes effective.\\n     */\\n    function updateExecutorFeeValue(\\n        uint256 _feeValue\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Delegate `_bips` of voting power to `_to` from msg.sender's delegation account\\n     * @param _to The address of the recipient\\n     * @param _bips The percentage of voting power to be delegated expressed in basis points (1/100 of one percent).\\n     *   Not cumulative - every call resets the delegation value (and value of 0 revokes delegation).\\n     */\\n    function delegate(address _to, uint256 _bips) external;\\n\\n    /**\\n     * @notice Undelegate all percentage delegations from the msg.sender's delegation account and then delegate\\n     *   corresponding `_bips` percentage of voting power to each member of `_delegatees`.\\n     * @param _delegatees The addresses of the new recipients.\\n     * @param _bips The percentages of voting power to be delegated expressed in basis points (1/100 of one percent).\\n     *   Total of all `_bips` values must be at most 10000.\\n     */\\n    function batchDelegate(\\n        address[] memory _delegatees,\\n        uint256[] memory _bips\\n    ) external;\\n\\n    /**\\n     * @notice Undelegate all voting power for delegates of msg.sender's delegation account\\n     */\\n    function undelegateAll() external;\\n\\n    /**\\n     * @notice Revoke all delegation from msg.sender's delegation account to `_who` at given block.\\n     *    Only affects the reads via `votePowerOfAtCached()` in the block `_blockNumber`.\\n     *    Block `_blockNumber` must be in the past.\\n     *    This method should be used only to prevent rogue delegate voting in the current voting block.\\n     *    To stop delegating use delegate with value of 0 or undelegateAll.\\n     */\\n    function revokeDelegationAt(address _who, uint256 _blockNumber) external;\\n\\n    /**\\n     * @notice Delegate all governance vote power of msg.sender's delegation account to `_to`.\\n     * @param _to The address of the recipient\\n     */\\n    function delegateGovernance(address _to) external;\\n\\n    /**\\n     * @notice Undelegate governance vote power for delegate of msg.sender's delegation account\\n     */\\n    function undelegateGovernance() external;\\n\\n    /**\\n     * @notice Allows user to transfer WNat to owner's account.\\n     * @param _amount           Amount of tokens to transfer\\n     */\\n    function withdraw(uint256 _amount) external;\\n\\n    /**\\n     * @notice Allows user to transfer balance of ERC20 tokens owned by the personal delegation contract.\\n     The main use case is to transfer tokens/NFTs that were received as part of an airdrop or register \\n     as participant in such airdrop.\\n     * @param _token            Target token contract address\\n     * @param _amount           Amount of tokens to transfer\\n     * @dev Reverts if target token is WNat contract - use method `withdraw` for that\\n     */\\n    function transferExternalToken(IERC20 _token, uint256 _amount) external;\\n\\n    /**\\n     * @notice Gets the delegation account of the `_owner`. Returns address(0) if not created yet.\\n     */\\n    function accountToDelegationAccount(\\n        address _owner\\n    ) external view returns (address);\\n\\n    /**\\n     * @notice Gets the delegation account data for the `_owner`. Returns address(0) if not created yet.\\n     * @param _owner                        owner's address\\n     * @return _delegationAccount           owner's delegation account address - could be address(0)\\n     * @return _enabled                     indicates if delegation account is enabled\\n     */\\n    function getDelegationAccountData(\\n        address _owner\\n    )\\n        external\\n        view\\n        returns (IDelegationAccount _delegationAccount, bool _enabled);\\n\\n    /**\\n     * @notice Get the addresses of executors.\\n     */\\n    function claimExecutors(\\n        address _owner\\n    ) external view returns (address[] memory);\\n\\n    /**\\n     * Get the addresses of allowed recipients.\\n     * Apart from these, the owner is always an allowed recipient.\\n     */\\n    function allowedClaimRecipients(\\n        address _rewardOwner\\n    ) external view returns (address[] memory);\\n\\n    /**\\n     * @notice Returns info if `_executor` is allowed to execute calls for `_owner`\\n     */\\n    function isClaimExecutor(\\n        address _owner,\\n        address _executor\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Get registered executors\\n     */\\n    function getRegisteredExecutors(\\n        uint256 _start,\\n        uint256 _end\\n    )\\n        external\\n        view\\n        returns (address[] memory _registeredExecutors, uint256 _totalLength);\\n\\n    /**\\n     * @notice Returns some info about the `_executor`\\n     * @param _executor             address representing executor\\n     * @return _registered          information if executor is registered\\n     * @return _currentFeeValue     executor's current fee value\\n     */\\n    function getExecutorInfo(\\n        address _executor\\n    ) external view returns (bool _registered, uint256 _currentFeeValue);\\n\\n    /**\\n     * @notice Returns the current fee value of `_executor`\\n     * @param _executor             address representing executor\\n     */\\n    function getExecutorCurrentFeeValue(\\n        address _executor\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the fee value of `_executor` at `_rewardEpoch`\\n     * @param _executor             address representing executor\\n     * @param _rewardEpoch          reward epoch number\\n     */\\n    function getExecutorFeeValue(\\n        address _executor,\\n        uint256 _rewardEpoch\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the scheduled fee value changes of `_executor`\\n     * @param _executor             address representing executor\\n     * @return _feeValue            positional array of fee values\\n     * @return _validFromEpoch      positional array of reward epochs the fee settings are effective from\\n     * @return _fixed               positional array of boolean values indicating if settings are subjected to change\\n     */\\n    function getExecutorScheduledFeeValueChanges(\\n        address _executor\\n    )\\n        external\\n        view\\n        returns (\\n            uint256[] memory _feeValue,\\n            uint256[] memory _validFromEpoch,\\n            bool[] memory _fixed\\n        );\\n}\\n\",\"keccak256\":\"0xbd147953ca90613d49fda18d7b1efc8d8428eb8d0c81444eddf6fda54eacec1d\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IConfirmedBlockHeightExists.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * @custom:name IConfirmedBlockHeightExists\\n * @custom:id 0x02\\n * @custom:supported BTC, DOGE, XRP\\n * @author Flare\\n * @notice An assertion that a block with `blockNumber` is confirmed.\\n * It also provides data to compute the block production rate in the given time range.\\n * @custom:verification It is checked that the block with `blockNumber` is confirmed by at\\n * least `numberOfConfirmations`.\\n * If it is not, the request is rejected. We note a block on the tip of the chain is confirmed by 1 block.\\n * Then `lowestQueryWindowBlock` is determined and its number and timestamp are extracted.\\n *\\n *\\n * Current confirmation heights consensus:\\n *\\n *\\n * | `Chain` | `chainId` | `numberOfConfirmations` | `timestamp ` |\\n * | ------- | --------- | ----------------------- | ------------ |\\n * | `BTC`   | 0         | 6                       | mediantime   |\\n * | `DOGE`  | 2         | 60                      | mediantime   |\\n * | `XRP`   | 3         | 3                       | close_time   |\\n *\\n *\\n * @custom:lut `lowestQueryWindowBlockTimestamp`\\n * @custom:lutlimit `0x127500`, `0x127500`, `0x127500`\\n */\\ninterface IConfirmedBlockHeightExists {\\n    /**\\n     * @notice Toplevel request\\n     * @param attestationType ID of the attestation type.\\n     * @param sourceId ID of the data source.\\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response as defined.\\n     * @param requestBody Data defining the request. Type and interpretation is determined by the `attestationType`.\\n     */\\n    struct Request {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        bytes32 messageIntegrityCode;\\n        RequestBody requestBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel response\\n     * @param attestationType Extracted from the request.\\n     * @param sourceId Extracted from the request.\\n     * @param votingRound The ID of the State Connector round in which the request was considered.\\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\\n     * @param requestBody Extracted from the request.\\n     * @param responseBody Data defining the response. The verification rules for the construction of the\\n     * response body and the type are defined per specific `attestationType`.\\n     */\\n    struct Response {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        uint64 votingRound;\\n        uint64 lowestUsedTimestamp;\\n        RequestBody requestBody;\\n        ResponseBody responseBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel proof\\n     * @param merkleProof Merkle proof corresponding to the attestation response.\\n     * @param data Attestation response.\\n     */\\n    struct Proof {\\n        bytes32[] merkleProof;\\n        Response data;\\n    }\\n\\n    /**\\n     * @notice Request body for ConfirmedBlockHeightExistsType attestation type\\n     * @param blockNumber The number of the block the request wants a confirmation of.\\n     * @param queryWindow The length of the period in which the block production rate is to be computed.\\n     */\\n    struct RequestBody {\\n        uint64 blockNumber;\\n        uint64 queryWindow;\\n    }\\n\\n    /**\\n     * @notice Response body for ConfirmedBlockHeightExistsType attestation type\\n     * @custom:below `blockNumber`, `lowestQueryWindowBlockNumber`, `blockTimestamp`, `lowestQueryWindowBlockTimestamp`\\n     * can be used to compute the average block production time in the specified block range.\\n     * @param blockTimestamp The timestamp of the block with `blockNumber`.\\n     * @param numberOfConfirmations The depth at which a block is considered confirmed depending on the chain.\\n     * All attestation providers must agree on this number.\\n     * @param lowestQueryWindowBlockNumber The block number of the latest block that has a timestamp strictly smaller\\n     * than `blockTimestamp` - `queryWindow`.\\n     * @param lowestQueryWindowBlockTimestamp The timestamp of the block at height `lowestQueryWindowBlockNumber`.\\n     */\\n    struct ResponseBody {\\n        uint64 blockTimestamp;\\n        uint64 numberOfConfirmations;\\n        uint64 lowestQueryWindowBlockNumber;\\n        uint64 lowestQueryWindowBlockTimestamp;\\n    }\\n}\\n\",\"keccak256\":\"0xedc37a6a835438a8bd33f628afc0bfa8963bc5558cf7c3aa693f12cf867ce587\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IConfirmedBlockHeightExistsVerification.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IConfirmedBlockHeightExists.sol\\\";\\n\\ninterface IConfirmedBlockHeightExistsVerification {\\n    function verifyConfirmedBlockHeightExists(\\n        IConfirmedBlockHeightExists.Proof calldata _proof\\n    ) external view returns (bool _proved);\\n}\\n\",\"keccak256\":\"0xec351f8d8fce3649193c05ae1c0fb02ce6b67f9944b4ed523c0919da5ece44d2\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/ICoreVaultClient.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport {IPayment} from \\\".//IFdcVerification.sol\\\";\\n\\n/**\\n * Core vault\\n */\\ninterface ICoreVaultClient {\\n    /**\\n     * Agent has requested transfer of (some of) their backing to the core vault.\\n     */\\n    event TransferToCoreVaultStarted(\\n        address indexed agentVault,\\n        uint256 indexed transferRedemptionRequestId,\\n        uint256 valueUBA\\n    );\\n\\n    /**\\n     * Agent has cancelled transfer to the core vault without paying.\\n     * The amount of `valueUBA` has been re-minted./\\n     */\\n    event TransferToCoreVaultDefaulted(\\n        address indexed agentVault,\\n        uint256 indexed transferRedemptionRequestId,\\n        uint256 remintedUBA\\n    );\\n\\n    /**\\n     * The transfer of underlying to the core vault was successfully completed.\\n     */\\n    event TransferToCoreVaultSuccessful(\\n        address indexed agentVault,\\n        uint256 indexed transferRedemptionRequestId,\\n        uint256 valueUBA\\n    );\\n\\n    /**\\n     * The agent has requested return of some of the underlying from the core vault to the agent's underlying address.\\n     */\\n    event ReturnFromCoreVaultRequested(\\n        address indexed agentVault,\\n        uint256 indexed requestId,\\n        bytes32 paymentReference,\\n        uint256 valueUBA\\n    );\\n\\n    /**\\n     * The agent has cancelled the return request.\\n     */\\n    event ReturnFromCoreVaultCancelled(\\n        address indexed agentVault,\\n        uint256 indexed requestId\\n    );\\n\\n    /**\\n     * The payment from core vault to the agent's underlying address has been confirmed.\\n     */\\n    event ReturnFromCoreVaultConfirmed(\\n        address indexed agentVault,\\n        uint256 indexed requestId,\\n        uint256 receivedUnderlyingUBA,\\n        uint256 remintedUBA\\n    );\\n\\n    /**\\n     * Redemption was requested from a core vault.\\n     * Can only be redeemed to a payment address from to the `allowedDestinations` list in the core vault manager.\\n     */\\n    event CoreVaultRedemptionRequested(\\n        address indexed redeemer,\\n        string paymentAddress,\\n        bytes32 paymentReference,\\n        uint256 valueUBA,\\n        uint256 feeUBA\\n    );\\n\\n    /**\\n     * Agent can transfer their backing to core vault.\\n     * They then get a redemption requests which the owner pays just like any other redemption request.\\n     * After that, the agent's collateral is released.\\n     * NOTE: only agent vault owner can call\\n     * @param _agentVault the agent vault address\\n     * @param _amountUBA the amount to transfer to the core vault\\n     */\\n    function transferToCoreVault(\\n        address _agentVault,\\n        uint256 _amountUBA\\n    ) external;\\n\\n    /**\\n     * Request that core vault transfers funds to the agent's underlying address,\\n     * which makes them available for redemptions. This method reserves agent's collateral.\\n     * This may be sent by an agent when redemptions dominate mintings, so that the agents\\n     * are empty but want to earn from redemptions.\\n     * NOTE: only agent vault owner can call\\n     * NOTE: there can be only one active return request (until it is confirmed or cancelled).\\n     * @param _agentVault the agent vault address\\n     * @param _lots number of lots (same lots as for minting and redemptions)\\n     */\\n    function requestReturnFromCoreVault(\\n        address _agentVault,\\n        uint256 _lots\\n    ) external;\\n\\n    /**\\n     * Before the return request is processed, it can be cancelled, releasing the agent's reserved collateral.\\n     * @param _agentVault the agent vault address\\n     */\\n    function cancelReturnFromCoreVault(address _agentVault) external;\\n\\n    /**\\n     * Confirm the payment from core vault to the agent's underlying address.\\n     * This adds the reserved funds to the agent's backing.\\n     * @param _payment FDC payment proof\\n     * @param _agentVault the agent vault address\\n     */\\n    function confirmReturnFromCoreVault(\\n        IPayment.Proof calldata _payment,\\n        address _agentVault\\n    ) external;\\n\\n    /**\\n     * Directly redeem from core vault by a user holding FAssets.\\n     * This is like ordinary redemption, but the redemption time is much longer (a day or more)\\n     * and there is no possibility of redemption default.\\n     * @param _lots the number of lots, must be larger than `coreVaultMinimumRedeemLots` setting\\n     * @param _redeemerUnderlyingAddress the underlying address to which the assets will be redeemed;\\n     *      must have been added to the `allowedDestinations` list in the core vault manager by\\n     *      the governance before the redemption request.\\n     */\\n    function redeemFromCoreVault(\\n        uint256 _lots,\\n        string memory _redeemerUnderlyingAddress\\n    ) external;\\n\\n    /**\\n     * Return the maximum amount that can be transferred and the minimum amount that\\n     * has to remain on the agent vault's underlying address.\\n     * @param _agentVault the agent vault address\\n     * @return _maximumTransferUBA maximum amount that can be transferred\\n     * @return _minimumLeftAmountUBA the minimum amount that has to remain on the agent vault's underlying address\\n     *  after the transfer\\n     */\\n    function maximumTransferToCoreVault(\\n        address _agentVault\\n    )\\n        external\\n        view\\n        returns (uint256 _maximumTransferUBA, uint256 _minimumLeftAmountUBA);\\n\\n    /**\\n     * Returns the amount available on the core vault - this is the maximum amount that can be returned to agent or\\n     * redeemed directly from the core vault.\\n     * @return _immediatelyAvailableUBA the amount on the core vault operating account - returns and redemptions\\n     * within this amount will be paid out quickly\\n     * @return _totalAvailableUBA the total amount on the core vault, including all escrows\\n     */\\n    function coreVaultAvailableAmount()\\n        external\\n        view\\n        returns (uint256 _immediatelyAvailableUBA, uint256 _totalAvailableUBA);\\n}\\n\",\"keccak256\":\"0xb5d71cd138847493c9c6eeea3b3b0f8b2f0e65cbb1b73c3c94ed1d424ae7f65f\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/ICoreVaultClientSettings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * Core vault settings\\n */\\ninterface ICoreVaultClientSettings {\\n    function setCoreVaultManager(address _coreVaultManager) external;\\n\\n    function setCoreVaultNativeAddress(address payable _nativeAddress) external;\\n\\n    function setCoreVaultTransferTimeExtensionSeconds(\\n        uint256 _transferTimeExtensionSeconds\\n    ) external;\\n\\n    function setCoreVaultTransferDefaultPenaltyBIPS(\\n        uint256 _transferDefaultPenaltyBIPS\\n    ) external;\\n\\n    function setCoreVaultRedemptionFeeBIPS(uint256 _redemptionFeeBIPS) external;\\n\\n    function setCoreVaultMinimumAmountLeftBIPS(\\n        uint256 _minimumAmountLeftBIPS\\n    ) external;\\n\\n    function setCoreVaultMinimumRedeemLots(uint256 _minimumRedeemLots) external;\\n\\n    function getCoreVaultManager() external view returns (address);\\n\\n    function getCoreVaultNativeAddress() external view returns (address);\\n\\n    function getCoreVaultTransferTimeExtensionSeconds()\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getCoreVaultTransferDefaultPenaltyBIPS()\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getCoreVaultRedemptionFeeBIPS() external view returns (uint256);\\n\\n    function getCoreVaultMinimumAmountLeftBIPS()\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getCoreVaultMinimumRedeemLots() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xde7db10ed00db6d97b9b2ba045542035c028db9c8a4afee7436c546dac407515\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IDelegationAccount.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IClaimSetupManager.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IDelegationAccount {\\n    event DelegateFtso(address to, uint256 bips);\\n    event RevokeFtso(address to, uint256 blockNumber);\\n    event UndelegateAllFtso();\\n    event DelegateGovernance(address to);\\n    event UndelegateGovernance();\\n    event WithdrawToOwner(uint256 amount);\\n    event ExternalTokenTransferred(IERC20 token, uint256 amount);\\n    event ExecutorFeePaid(address executor, uint256 amount);\\n    event Initialize(address owner, IClaimSetupManager manager);\\n}\\n\",\"keccak256\":\"0x35d7cfc9f93e75a45debeab6c0b63772c136186643ba847c3629f66e63d604e7\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IEVMTransaction.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * @custom:name IEVMTransaction\\n * @custom:id 0x06\\n * @custom:supported ETH, FLR, SGB\\n * @author Flare\\n * @notice A relay of a transaction from an EVM chain.\\n * This type is only relevant for EVM-compatible chains.\\n * @custom:verification If a transaction with the `transactionId` is in a block on the main branch with\\n * at least `requiredConfirmations`, the specified data is relayed.\\n * If an indicated event does not exist, the request is rejected.\\n * @custom:lut `timestamp`\\n * @custom:lutlimit `0x41eb00`, `0x41eb00`, `0x41eb00`\\n */\\ninterface IEVMTransaction {\\n    /**\\n     * @notice Toplevel request\\n     * @param attestationType ID of the attestation type.\\n     * @param sourceId ID of the data source.\\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.\\n     * @param requestBody Data defining the request. Type (struct) and interpretation is\\n     * determined by the `attestationType`.\\n     */\\n    struct Request {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        bytes32 messageIntegrityCode;\\n        RequestBody requestBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel response\\n     * @param attestationType Extracted from the request.\\n     * @param sourceId Extracted from the request.\\n     * @param votingRound The ID of the State Connector round in which the request was considered.\\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\\n     * @param requestBody Extracted from the request.\\n     * @param responseBody Data defining the response. The verification rules for the construction\\n     * of the response body and the type are defined per specific `attestationType`.\\n     */\\n    struct Response {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        uint64 votingRound;\\n        uint64 lowestUsedTimestamp;\\n        RequestBody requestBody;\\n        ResponseBody responseBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel proof\\n     * @param merkleProof Merkle proof corresponding to the attestation response.\\n     * @param data Attestation response.\\n     */\\n    struct Proof {\\n        bytes32[] merkleProof;\\n        Response data;\\n    }\\n\\n    /**\\n     * @notice Request body for EVM transaction attestation type\\n     * @custom:below Note that events (logs) are indexed in block not in each transaction.\\n     * The contract that uses the attestation should specify the order of event logs as needed and the requestor should\\n     * sort `logIndices` with respect to the set specifications.\\n     * If possible, the contact should require one `logIndex`.\\n     * @param transactionHash Hash of the transaction(transactionHash).\\n     * @param requiredConfirmations The height at which a block is considered confirmed by the requestor.\\n     * @param provideInput If true, \\\"input\\\" field is included in the response.\\n     * @param listEvents If true, events indicated by `logIndices` are included in the response.\\n     * Otherwise, no events are included in the response.\\n     * @param logIndices If `listEvents` is `false`, this should be an empty list, otherwise,\\n     * the request is rejected. If `listEvents` is `true`, this is the list of indices (logIndex)\\n     * of the events to be relayed (sorted by the requestor). The array should contain at most 50 indices.\\n     * If empty, it indicates all events in order capped by 50.\\n     */\\n    struct RequestBody {\\n        bytes32 transactionHash;\\n        uint16 requiredConfirmations;\\n        bool provideInput;\\n        bool listEvents;\\n        uint32[] logIndices;\\n    }\\n\\n    /**\\n     * @notice Response body for EVM transaction attestation type\\n     * @custom:below The fields are in line with transaction provided by EVM node.\\n     * @param blockNumber Number of the block in which the transaction is included.\\n     * @param timestamp Timestamp of the block in which the transaction is included.\\n     * @param sourceAddress The address (from) that signed the transaction.\\n     * @param isDeployment Indicate whether it is a contract creation transaction.\\n     * @param receivingAddress The address (to) of the receiver of the initial transaction.\\n     * Zero address if `isDeployment` is `true`.\\n     * @param value The value transferred by the initial transaction in wei.\\n     * @param input If `provideInput`, this is the data send along with the initial transaction.\\n     * Otherwise it is the default value `0x00`.\\n     * @param status Status of the transaction 1 - success, 0 - failure.\\n     * @param events If `listEvents` is `true`, an array of the requested events.\\n     * Sorted by the logIndex in the same order as `logIndices`. Otherwise, an empty array.\\n     */\\n    struct ResponseBody {\\n        uint64 blockNumber;\\n        uint64 timestamp;\\n        address sourceAddress;\\n        bool isDeployment;\\n        address receivingAddress;\\n        uint256 value;\\n        bytes input;\\n        uint8 status;\\n        Event[] events;\\n    }\\n\\n    /**\\n     * @notice Event log record\\n     * @custom:above An `Event` is a struct with the following fields:\\n     * @custom:below The fields are in line with EVM event logs.\\n     * @param logIndex The consecutive number of the event in block.\\n     * @param emitterAddress The address of the contract that emitted the event.\\n     * @param topics An array of up to four 32-byte strings of indexed log arguments.\\n     * @param data Concatenated 32-byte strings of non-indexed log arguments. At least 32 bytes long.\\n     * @param removed It is `true` if the log was removed due to a chain reorganization\\n     * and `false` if it is a valid log.\\n     */\\n    struct Event {\\n        uint32 logIndex;\\n        address emitterAddress;\\n        bytes32[] topics;\\n        bytes data;\\n        bool removed;\\n    }\\n}\\n\",\"keccak256\":\"0x12c4709d09d96c4c24816e01e57e82ecd7910a486dcda9e07a53f7f37a7219c3\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IEVMTransactionVerification.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IEVMTransaction.sol\\\";\\n\\ninterface IEVMTransactionVerification {\\n    function verifyEVMTransaction(\\n        IEVMTransaction.Proof calldata _proof\\n    ) external view returns (bool _proved);\\n}\\n\",\"keccak256\":\"0xfe0f25556b3001fb2e12dd91d4d8e1d51805798b7d0e65eb34b77321c3d2cea0\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IEntityManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * EntityManager interface.\\n */\\ninterface IEntityManager {\\n    /// Voter addresses.\\n    struct VoterAddresses {\\n        address submitAddress;\\n        address submitSignaturesAddress;\\n        address signingPolicyAddress;\\n    }\\n\\n    /// Event emitted when a node id is registered.\\n    event NodeIdRegistered(address indexed voter, bytes20 indexed nodeId);\\n    /// Event emitted when a node id is unregistered.\\n    event NodeIdUnregistered(address indexed voter, bytes20 indexed nodeId);\\n    /// Event emitted when a public key is registered.\\n    event PublicKeyRegistered(\\n        address indexed voter,\\n        bytes32 indexed part1,\\n        bytes32 indexed part2\\n    );\\n    /// Event emitted when a public key is unregistered.\\n    event PublicKeyUnregistered(\\n        address indexed voter,\\n        bytes32 indexed part1,\\n        bytes32 indexed part2\\n    );\\n    /// Event emitted when a delegation address is proposed.\\n    event DelegationAddressProposed(\\n        address indexed voter,\\n        address indexed delegationAddress\\n    );\\n    /// Event emitted when a delegation address registration is confirmed.\\n    event DelegationAddressRegistrationConfirmed(\\n        address indexed voter,\\n        address indexed delegationAddress\\n    );\\n    /// Event emitted when a submit address is proposed.\\n    event SubmitAddressProposed(\\n        address indexed voter,\\n        address indexed submitAddress\\n    );\\n    /// Event emitted when a submit address registration is confirmed.\\n    event SubmitAddressRegistrationConfirmed(\\n        address indexed voter,\\n        address indexed submitAddress\\n    );\\n    /// Event emitted when a submit signatures address is proposed.\\n    event SubmitSignaturesAddressProposed(\\n        address indexed voter,\\n        address indexed submitSignaturesAddress\\n    );\\n    /// Event emitted when a submit signatures address registration is confirmed.\\n    event SubmitSignaturesAddressRegistrationConfirmed(\\n        address indexed voter,\\n        address indexed submitSignaturesAddress\\n    );\\n    /// Event emitted when a signing policy address is proposed.\\n    event SigningPolicyAddressProposed(\\n        address indexed voter,\\n        address indexed signingPolicyAddress\\n    );\\n    /// Event emitted when a signing policy address registration is confirmed.\\n    event SigningPolicyAddressRegistrationConfirmed(\\n        address indexed voter,\\n        address indexed signingPolicyAddress\\n    );\\n    /// Event emitted when the maximum number of node ids per entity is set.\\n    event MaxNodeIdsPerEntitySet(uint256 maxNodeIdsPerEntity);\\n\\n    /**\\n     * Registers a node id.\\n     * @param _nodeId Node id.\\n     * @param _certificateRaw Certificate in raw format.\\n     * @param _signature Signature.\\n     */\\n    function registerNodeId(\\n        bytes20 _nodeId,\\n        bytes calldata _certificateRaw,\\n        bytes calldata _signature\\n    ) external;\\n\\n    /**\\n     * Unregisters a node id.\\n     * @param _nodeId Node id.\\n     */\\n    function unregisterNodeId(bytes20 _nodeId) external;\\n\\n    /**\\n     * Registers a public key.\\n     * @param _part1 First part of the public key.\\n     * @param _part2 Second part of the public key.\\n     * @param _verificationData Additional data used to verify the public key.\\n     */\\n    function registerPublicKey(\\n        bytes32 _part1,\\n        bytes32 _part2,\\n        bytes calldata _verificationData\\n    ) external;\\n\\n    /**\\n     * Unregisters a public key.\\n     */\\n    function unregisterPublicKey() external;\\n\\n    /**\\n     * Proposes a delegation address (called by the voter).\\n     * @param _delegationAddress Delegation address.\\n     */\\n    function proposeDelegationAddress(address _delegationAddress) external;\\n\\n    /**\\n     * Confirms a delegation address registration (called by the delegation address).\\n     * @param _voter Voter address.\\n     */\\n    function confirmDelegationAddressRegistration(address _voter) external;\\n\\n    /**\\n     * Proposes a submit address (called by the voter).\\n     * @param _submitAddress Submit address.\\n     */\\n    function proposeSubmitAddress(address _submitAddress) external;\\n\\n    /**\\n     * Confirms a submit address registration (called by the submit address).\\n     * @param _voter Voter address.\\n     */\\n    function confirmSubmitAddressRegistration(address _voter) external;\\n\\n    /**\\n     * Proposes a submit signatures address (called by the voter).\\n     * @param _submitSignaturesAddress Submit signatures address.\\n     */\\n    function proposeSubmitSignaturesAddress(\\n        address _submitSignaturesAddress\\n    ) external;\\n\\n    /**\\n     * Confirms a submit signatures address registration (called by the submit signatures address).\\n     * @param _voter Voter address.\\n     */\\n    function confirmSubmitSignaturesAddressRegistration(\\n        address _voter\\n    ) external;\\n\\n    /**\\n     * Proposes a signing policy address (called by the voter).\\n     * @param _signingPolicyAddress Signing policy address.\\n     */\\n    function proposeSigningPolicyAddress(\\n        address _signingPolicyAddress\\n    ) external;\\n\\n    /**\\n     * Confirms a signing policy address registration (called by the signing policy address).\\n     * @param _voter Voter address.\\n     */\\n    function confirmSigningPolicyAddressRegistration(address _voter) external;\\n\\n    /**\\n     * Gets the delegation address of a voter at a specific block number.\\n     * @param _voter Voter address.\\n     * @param _blockNumber Block number.\\n     * @return Public key.\\n     */\\n    function getDelegationAddressOfAt(\\n        address _voter,\\n        uint256 _blockNumber\\n    ) external view returns (address);\\n\\n    /**\\n     * Gets the delegation address of a voter at the current block number.\\n     * @param _voter Voter address.\\n     * @return Public key.\\n     */\\n    function getDelegationAddressOf(\\n        address _voter\\n    ) external view returns (address);\\n\\n    /**\\n     * Gets the node ids of a voter at a specific block number.\\n     * @param _voter Voter address.\\n     * @param _blockNumber Block number.\\n     * @return Node ids.\\n     */\\n    function getNodeIdsOfAt(\\n        address _voter,\\n        uint256 _blockNumber\\n    ) external view returns (bytes20[] memory);\\n\\n    /**\\n     * Gets the node ids of a voter at the current block number.\\n     * @param _voter Voter address.\\n     * @return Node ids.\\n     */\\n    function getNodeIdsOf(\\n        address _voter\\n    ) external view returns (bytes20[] memory);\\n\\n    /**\\n     * Gets the public key of a voter at a specific block number.\\n     * @param _voter Voter address.\\n     * @param _blockNumber Block number.\\n     * @return Public key.\\n     */\\n    function getPublicKeyOfAt(\\n        address _voter,\\n        uint256 _blockNumber\\n    ) external view returns (bytes32, bytes32);\\n\\n    /**\\n     * Gets the public key of a voter at the current block number.\\n     * @param _voter Voter address.\\n     * @return Public key.\\n     */\\n    function getPublicKeyOf(\\n        address _voter\\n    ) external view returns (bytes32, bytes32);\\n\\n    /**\\n     * Gets voter's addresses at a specific block number.\\n     * @param _voter Voter address.\\n     * @param _blockNumber Block number.\\n     * @return _addresses Voter addresses.\\n     */\\n    function getVoterAddressesAt(\\n        address _voter,\\n        uint256 _blockNumber\\n    ) external view returns (VoterAddresses memory _addresses);\\n\\n    /**\\n     * Gets voter's addresses at the current block number.\\n     * @param _voter Voter address.\\n     * @return _addresses Voter addresses.\\n     */\\n    function getVoterAddresses(\\n        address _voter\\n    ) external view returns (VoterAddresses memory _addresses);\\n\\n    /**\\n     * Gets voter's address for a node id at a specific block number.\\n     * @param _nodeId Node id.\\n     * @param _blockNumber Block number.\\n     * @return _voter Voter address.\\n     */\\n    function getVoterForNodeId(\\n        bytes20 _nodeId,\\n        uint256 _blockNumber\\n    ) external view returns (address _voter);\\n\\n    /**\\n     * Gets voter's address for a public key at a specific block number.\\n     * @param _part1 First part of the public key.\\n     * @param _part2 Second part of the public key.\\n     * @param _blockNumber Block number.\\n     * @return _voter Voter address.\\n     */\\n    function getVoterForPublicKey(\\n        bytes32 _part1,\\n        bytes32 _part2,\\n        uint256 _blockNumber\\n    ) external view returns (address _voter);\\n\\n    /**\\n     * Gets voter's address for a delegation address at a specific block number.\\n     * @param _delegationAddress Delegation address.\\n     * @param _blockNumber Block number.\\n     * @return _voter Voter address.\\n     */\\n    function getVoterForDelegationAddress(\\n        address _delegationAddress,\\n        uint256 _blockNumber\\n    ) external view returns (address _voter);\\n\\n    /**\\n     * Gets voter's address for a submit address at a specific block number.\\n     * @param _submitAddress Submit address.\\n     * @param _blockNumber Block number.\\n     * @return _voter Voter address.\\n     */\\n    function getVoterForSubmitAddress(\\n        address _submitAddress,\\n        uint256 _blockNumber\\n    ) external view returns (address _voter);\\n\\n    /**\\n     * Gets voter's address for a submit signatures address at a specific block number.\\n     * @param _submitSignaturesAddress Submit signatures address.\\n     * @param _blockNumber Block number.\\n     * @return _voter Voter address.\\n     */\\n    function getVoterForSubmitSignaturesAddress(\\n        address _submitSignaturesAddress,\\n        uint256 _blockNumber\\n    ) external view returns (address _voter);\\n\\n    /**\\n     * Gets voter's address for a signing policy address at a specific block number.\\n     * @param _signingPolicyAddress Signing policy address.\\n     * @param _blockNumber Block number.\\n     * @return _voter Voter address.\\n     */\\n    function getVoterForSigningPolicyAddress(\\n        address _signingPolicyAddress,\\n        uint256 _blockNumber\\n    ) external view returns (address _voter);\\n}\\n\",\"keccak256\":\"0x33699b654dd750be6c9acde273a4e4052db31dfe429465e51c5b9c4ddf21caea\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFastUpdateIncentiveManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IFixedPointArithmetic.sol\\\" as FPA;\\nimport \\\"./IFastUpdatesConfiguration.sol\\\";\\nimport \\\"./IIncreaseManager.sol\\\";\\n\\n/**\\n * Fast update incentive manager interface.\\n */\\ninterface IFastUpdateIncentiveManager is IIncreaseManager {\\n    /// Incentive offer structure.\\n    struct IncentiveOffer {\\n        FPA.Range rangeIncrease;\\n        FPA.Range rangeLimit;\\n    }\\n\\n    /// Event emitted when an incentive is offered.\\n    event IncentiveOffered(\\n        uint24 indexed rewardEpochId,\\n        FPA.Range rangeIncrease,\\n        FPA.SampleSize sampleSizeIncrease,\\n        FPA.Fee offerAmount\\n    );\\n\\n    /// Event emitted when inflation rewards are offered.\\n    event InflationRewardsOffered(\\n        // reward epoch id\\n        uint24 indexed rewardEpochId,\\n        // feed configurations\\n        IFastUpdatesConfiguration.FeedConfiguration[] feedConfigurations,\\n        // amount (in wei) of reward in native coin\\n        uint256 amount\\n    );\\n\\n    /**\\n     * The entry point for third parties to make incentive offers. It accepts a payment and, using the contents of\\n     * `_offer`, computes how much the expected sample size will be increased to apply the requested (but capped) range\\n     * increase. If the ultimate value of the range exceeds the cap, funds are returned to the sender in proportion to\\n     * the amount by which the increase is adjusted to reach the cap.\\n     * @param _offer The requested amount of per-block variation range increase,\\n     * along with a cap for the ultimate range.\\n     */\\n    function offerIncentive(IncentiveOffer calldata _offer) external payable;\\n\\n    /// Viewer for the current value of the expected sample size.\\n    function getExpectedSampleSize() external view returns (FPA.SampleSize);\\n\\n    /// Viewer for the current value of the unit delta's precision (the fractional part of the scale).\\n    function getPrecision() external view returns (FPA.Precision);\\n\\n    /// Viewer for the current value of the per-block variation range.\\n    function getRange() external view returns (FPA.Range);\\n\\n    /// Viewer for the current value of sample size increase price.\\n    function getCurrentSampleSizeIncreasePrice()\\n        external\\n        view\\n        returns (FPA.Fee);\\n\\n    /// Viewer for the current value of the scale itself.\\n    function getScale() external view returns (FPA.Scale);\\n\\n    /// Viewer for the base value of the scale itself.\\n    function getBaseScale() external view returns (FPA.Scale);\\n\\n    /// The maximum amount by which the expected sample size can be increased by an incentive offer.\\n    /// This is controlled by governance and forces a minimum cost to increasing the sample size greatly,\\n    /// which would otherwise be an attack on the protocol.\\n    function sampleIncreaseLimit() external view returns (FPA.SampleSize);\\n\\n    /// The maximum value that the range can be increased to by an incentive offer.\\n    function rangeIncreaseLimit() external view returns (FPA.Range);\\n\\n    /// The price for increasing the per-block range of variation by 1, prorated for the actual amount of increase.\\n    function rangeIncreasePrice() external view returns (FPA.Fee);\\n}\\n\",\"keccak256\":\"0x6643adba1ab694eb1f75ac58f0893201ce2c1101a33f3152dc5d213e26ebbe08\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFastUpdater.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport {SortitionCredential} from \\\"./ISortition.sol\\\";\\n\\n/**\\n * Fast updater interface.\\n */\\ninterface IFastUpdater {\\n    /// Signature structure\\n    struct Signature {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    /// Fast update structure\\n    struct FastUpdates {\\n        uint256 sortitionBlock;\\n        SortitionCredential sortitionCredential;\\n        bytes deltas;\\n        Signature signature;\\n    }\\n\\n    /// Event emitted when a new set of updates is submitted.\\n    event FastUpdateFeedsSubmitted(\\n        uint32 indexed votingRoundId,\\n        address indexed signingPolicyAddress\\n    );\\n\\n    /// Event emitted when a feed is added or reset.\\n    event FastUpdateFeedReset(\\n        uint256 indexed votingRoundId,\\n        uint256 indexed index,\\n        bytes21 indexed id,\\n        uint256 value,\\n        int8 decimals\\n    );\\n\\n    /// Event emitted when a feed is removed.\\n    event FastUpdateFeedRemoved(uint256 indexed index);\\n\\n    /// Event emitted at the start of a new voting epoch - current feeds' values and decimals.\\n    event FastUpdateFeeds(\\n        uint256 indexed votingEpochId,\\n        uint256[] feeds,\\n        int8[] decimals\\n    );\\n\\n    /**\\n     * The entry point for providers to submit an update transaction.\\n     * @param _updates Data of an update transaction, which in addition to the actual list of updates,\\n     * includes the sortition credential proving the provider's eligibility to make updates in the also-included\\n     * sortition round, as well as a signature allowing a single registered provider to submit from multiple\\n     * EVM accounts.\\n     */\\n    function submitUpdates(FastUpdates calldata _updates) external;\\n\\n    /**\\n     * Public access to the stored data of all feeds.\\n     * A fee (calculated by the FeeCalculator contract) may need to be paid.\\n     * **NOTE:** Overpayment is not refunded.\\n     * @return _feedIds The list of feed ids.\\n     * @return _feeds The list of feeds.\\n     * @return _decimals The list of decimal places for feeds.\\n     * @return _timestamp The timestamp of the last update.\\n     */\\n    function fetchAllCurrentFeeds()\\n        external\\n        payable\\n        returns (\\n            bytes21[] memory _feedIds,\\n            uint256[] memory _feeds,\\n            int8[] memory _decimals,\\n            uint64 _timestamp\\n        );\\n\\n    /**\\n     * Public access to the stored data of each feed, allowing controlled batch access to the lengthy complete data.\\n     * Feeds should be sorted for better performance.\\n     * A fee (calculated by the FeeCalculator contract) may need to be paid.\\n     * **NOTE:** Overpayment is not refunded.\\n     * @param _indices Index numbers of the feeds for which data should be returned, corresponding to `feedIds` in\\n     * the `FastUpdatesConfiguration` contract.\\n     * @return _feeds The list of data for the requested feeds, in the same order as the feed indices were given\\n     * (which may not be their sorted order).\\n     * @return _decimals The list of decimal places for the requested feeds, in the same order as the feed indices were\\n     * given (which may not be their sorted order).\\n     * @return _timestamp The timestamp of the last update.\\n     */\\n    function fetchCurrentFeeds(\\n        uint256[] calldata _indices\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256[] memory _feeds,\\n            int8[] memory _decimals,\\n            uint64 _timestamp\\n        );\\n\\n    /**\\n     * Informational getter concerning the eligibility criterion for being chosen by sortition.\\n     * @return _cutoff The upper endpoint of the acceptable range of \\\"scores\\\" that providers generate for sortition.\\n     * A score below the cutoff indicates eligibility to submit updates in the present sortition round.\\n     */\\n    function currentScoreCutoff() external view returns (uint256 _cutoff);\\n\\n    /**\\n     * Informational getter concerning the eligibility criterion for being chosen by sortition in a given block.\\n     * @param _blockNum The block for which the cutoff is requested.\\n     * @return _cutoff The upper endpoint of the acceptable range of \\\"scores\\\" that providers generate for sortition.\\n     * A score below the cutoff indicates eligibility to submit updates in the present sortition round.\\n     */\\n    function blockScoreCutoff(\\n        uint256 _blockNum\\n    ) external view returns (uint256 _cutoff);\\n\\n    /**\\n     * Informational getter concerning a provider's likelihood of being chosen by sortition.\\n     * @param _signingPolicyAddress The signing policy address of the specified provider. This is different from the\\n     * sender of an update transaction, due to the signature included in the `FastUpdates` type.\\n     * @return _weight The specified provider's weight for sortition purposes. This is derived from the provider's\\n     * delegation weight for the FTSO, but rescaled against a fixed number of \\\"virtual providers\\\", indicating how many\\n     * potential updates a single provider may make in a sortition round.\\n     */\\n    function currentSortitionWeight(\\n        address _signingPolicyAddress\\n    ) external view returns (uint256 _weight);\\n\\n    /**\\n     * The submission window is a number of blocks forming a \\\"grace period\\\" after a round of sortition starts,\\n     * during which providers may submit updates for that round. In other words, each block starts a new round of\\n     * sortition and that round lasts `submissionWindow` blocks.\\n     */\\n    function submissionWindow() external view returns (uint8);\\n\\n    /**\\n     * Id of the current reward epoch.\\n     */\\n    function currentRewardEpochId() external view returns (uint24);\\n\\n    /**\\n     * The number of updates submitted in each block for the last `_historySize` blocks (up to `MAX_BLOCKS_HISTORY`).\\n     * @param _historySize The number of blocks for which the number of updates should be returned.\\n     * @return _noOfUpdates The number of updates submitted in each block for the last `_historySize` blocks.\\n     * The array is ordered from the current block to the oldest block.\\n     */\\n    function numberOfUpdates(\\n        uint256 _historySize\\n    ) external view returns (uint256[] memory _noOfUpdates);\\n\\n    /**\\n     * The number of updates submitted in a block - available only for the last `MAX_BLOCKS_HISTORY` blocks.\\n     * @param _blockNumber The block number for which the number of updates should be returned.\\n     * @return _noOfUpdates The number of updates submitted in the specified block.\\n     */\\n    function numberOfUpdatesInBlock(\\n        uint256 _blockNumber\\n    ) external view returns (uint256 _noOfUpdates);\\n}\\n\",\"keccak256\":\"0x931c3d367ee09f432fa66fa326862d1bf6c5339585a2937b4feb6305d9ab6cf2\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFastUpdatesConfiguration.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * FastUpdatesConfiguration interface.\\n */\\ninterface IFastUpdatesConfiguration {\\n    /**\\n     * The feed configuration struct.\\n     */\\n    struct FeedConfiguration {\\n        // feed id\\n        bytes21 feedId;\\n        // reward band value (interpreted off-chain) in relation to the median\\n        uint32 rewardBandValue;\\n        // inflation share\\n        uint24 inflationShare;\\n    }\\n\\n    /// Event emitted when a feed is added.\\n    event FeedAdded(\\n        bytes21 indexed feedId,\\n        uint32 rewardBandValue,\\n        uint24 inflationShare,\\n        uint256 index\\n    );\\n    /// Event emitted when a feed is updated.\\n    event FeedUpdated(\\n        bytes21 indexed feedId,\\n        uint32 rewardBandValue,\\n        uint24 inflationShare,\\n        uint256 index\\n    );\\n    /// Event emitted when a feed is removed.\\n    event FeedRemoved(bytes21 indexed feedId, uint256 index);\\n\\n    /**\\n     * Returns the index of a feed.\\n     * @param _feedId The feed id.\\n     * @return _index The index of the feed.\\n     */\\n    function getFeedIndex(\\n        bytes21 _feedId\\n    ) external view returns (uint256 _index);\\n\\n    /**\\n     * Returns the feed id at a given index. Removed (unused) feed index will return bytes21(0).\\n     * @param _index The index.\\n     * @return _feedId The feed id.\\n     */\\n    function getFeedId(uint256 _index) external view returns (bytes21 _feedId);\\n\\n    /**\\n     * Returns all feed ids. For removed (unused) feed indices, the feed id will be bytes21(0).\\n     */\\n    function getFeedIds() external view returns (bytes21[] memory);\\n\\n    /**\\n     * Returns the number of feeds, including removed ones.\\n     */\\n    function getNumberOfFeeds() external view returns (uint256);\\n\\n    /**\\n     * Returns the feed configurations, including removed ones.\\n     */\\n    function getFeedConfigurations()\\n        external\\n        view\\n        returns (FeedConfiguration[] memory);\\n\\n    /**\\n     * Returns the unused indices - indices of removed feeds.\\n     */\\n    function getUnusedIndices() external view returns (uint256[] memory);\\n}\\n\",\"keccak256\":\"0x87fca9233dda513b84df570121c7b81d066de629fe32c12c3175796ae29650a7\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFdcHub.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IFdcInflationConfigurations.sol\\\";\\nimport \\\"./IFdcRequestFeeConfigurations.sol\\\";\\n\\n/**\\n * FdcHub interface.\\n */\\ninterface IFdcHub {\\n    // Event emitted when an attestation request is made.\\n    event AttestationRequest(bytes data, uint256 fee);\\n\\n    // Event emitted when a requests offset is set.\\n    event RequestsOffsetSet(uint8 requestsOffsetSeconds);\\n\\n    /// Event emitted when inflation rewards are offered.\\n    event InflationRewardsOffered(\\n        // reward epoch id\\n        uint24 indexed rewardEpochId,\\n        // fdc configurations\\n        IFdcInflationConfigurations.FdcConfiguration[] fdcConfigurations,\\n        // amount (in wei) of reward in native coin\\n        uint256 amount\\n    );\\n\\n    /**\\n     * Method to request an attestation.\\n     * @param _data ABI encoded attestation request\\n     */\\n    function requestAttestation(bytes calldata _data) external payable;\\n\\n    /**\\n     * The offset (in seconds) for the requests to be processed during the current voting round.\\n     */\\n    function requestsOffsetSeconds() external view returns (uint8);\\n\\n    /**\\n     * The FDC inflation configurations contract.\\n     */\\n    function fdcInflationConfigurations()\\n        external\\n        view\\n        returns (IFdcInflationConfigurations);\\n\\n    /**\\n     * The FDC request fee configurations contract.\\n     */\\n    function fdcRequestFeeConfigurations()\\n        external\\n        view\\n        returns (IFdcRequestFeeConfigurations);\\n}\\n\",\"keccak256\":\"0x32539beb951ec7c9c33308d34ea7b0e96cc9adab096c901761549765d710a898\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFdcInflationConfigurations.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * FdcInflationConfigurations interface.\\n */\\ninterface IFdcInflationConfigurations {\\n    /// The FDC configuration struct.\\n\\n    struct FdcConfiguration {\\n        // attestation type\\n        bytes32 attestationType;\\n        // source\\n        bytes32 source;\\n        // inflation share for this configuration\\n        uint24 inflationShare;\\n        // minimal reward eligibility threshold in number of request\\n        uint8 minRequestsThreshold;\\n        // mode (additional settings interpreted on the client side off-chain)\\n        uint224 mode;\\n    }\\n\\n    /**\\n     * Returns the FDC configuration at `_index`.\\n     * @param _index The index of the FDC configuration.\\n     */\\n    function getFdcConfiguration(\\n        uint256 _index\\n    ) external view returns (FdcConfiguration memory);\\n\\n    /**\\n     * Returns the FDC configurations.\\n     */\\n    function getFdcConfigurations()\\n        external\\n        view\\n        returns (FdcConfiguration[] memory);\\n}\\n\",\"keccak256\":\"0x302b9469df23b5f5f3efff68ae95e3c131a9e27033371530397353e32e524561\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFdcRequestFeeConfigurations.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * FdcRequestFeeConfigurations interface.\\n */\\ninterface IFdcRequestFeeConfigurations {\\n    // Event emitted when a type and source price is set.\\n    event TypeAndSourceFeeSet(\\n        bytes32 indexed attestationType,\\n        bytes32 indexed source,\\n        uint256 fee\\n    );\\n\\n    // Event emitted when a type and source price is removed.\\n    event TypeAndSourceFeeRemoved(\\n        bytes32 indexed attestationType,\\n        bytes32 indexed source\\n    );\\n\\n    /**\\n     * Method to get the base fee for an attestation request. It reverts if the request is not supported.\\n     * @param _data ABI encoded attestation request\\n     */\\n    function getRequestFee(\\n        bytes calldata _data\\n    ) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x735f44c67954123a0a293a1b9732cc517b24aac44bc9df5292a93620bf415844\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFdcVerification.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IRelay.sol\\\";\\nimport \\\"./IAddressValidityVerification.sol\\\";\\nimport \\\"./IBalanceDecreasingTransactionVerification.sol\\\";\\nimport \\\"./IConfirmedBlockHeightExistsVerification.sol\\\";\\nimport \\\"./IEVMTransactionVerification.sol\\\";\\nimport \\\"./IPaymentVerification.sol\\\";\\nimport \\\"./IReferencedPaymentNonexistenceVerification.sol\\\";\\nimport \\\"./IWeb2JsonVerification.sol\\\";\\n\\n/**\\n * FdcVerification interface.\\n */\\ninterface IFdcVerification is\\n    IAddressValidityVerification,\\n    IBalanceDecreasingTransactionVerification,\\n    IConfirmedBlockHeightExistsVerification,\\n    IEVMTransactionVerification,\\n    IPaymentVerification,\\n    IReferencedPaymentNonexistenceVerification,\\n    IWeb2JsonVerification\\n{\\n    /**\\n     * The FDC protocol id.\\n     */\\n    function fdcProtocolId() external view returns (uint8 _fdcProtocolId);\\n\\n    /**\\n     * Relay contract address.\\n     */\\n    function relay() external view returns (IRelay);\\n}\\n\",\"keccak256\":\"0x3b97599af78cdcd4fea774904ccaa4e28e09f75f624bd4616b1e3ad17608ce3b\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFeeCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * FeeCalculator interface.\\n */\\ninterface IFeeCalculator {\\n    /**\\n     * Calculates a fee that needs to be paid to fetch feeds' data.\\n     * @param _feedIds List of feed ids.\\n     */\\n    function calculateFeeByIds(\\n        bytes21[] memory _feedIds\\n    ) external view returns (uint256 _fee);\\n\\n    /**\\n     * Calculates a fee that needs to be paid to fetch feeds' data.\\n     * @param _indices Indices of the feeds, corresponding to feed ids in\\n     * the FastUpdatesConfiguration contract.\\n     */\\n    function calculateFeeByIndices(\\n        uint256[] memory _indices\\n    ) external view returns (uint256 _fee);\\n}\\n\",\"keccak256\":\"0x0e45fc6ed4857ba51cfc3d80743f2b7f15a53d4e8e5d9656e4589ad54274d32c\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFixedPointArithmetic.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/*\\n * Opaque type synonyms to enforce arithemtic correctness.\\n * All of these are internally uint256 to avert solc's restricted-bit-size internal handling.\\n * Since the space is available, the fractional parts of all (except Price,\\n * which is not controlled by us) are very wide.\\n */\\n\\ntype Scale is uint256; // 1x127\\ntype Precision is uint256; // 0x127; the fractional part of Scale, top bit always 0\\ntype SampleSize is uint256; // 8x120; current gas usage and block gas limit force <32 update transactions per block\\ntype Range is uint256; // 8x120, with some space for >100% fluctuations\\n// (measured volatility per block is ~1e-3 at most)\\ntype Fractional is uint256; // 0x128\\n\\ntype Fee is uint256; // 128x0; same scale as currency units,restricted to bottom 128 bits\\n// (1e18 integer and fractional parts) to accommodate arithmetic\\n\",\"keccak256\":\"0x18da60b6827be7043637875d82cd9fce832f164a0f2968160e0bd4308e4e34e7\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFlareAssetRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\npragma abicoder v2;\\n\\ninterface IFlareAssetRegistry {\\n    /**\\n     * @notice Returns if the token is a Flare Asset\\n     * @dev All other methods that accept token address will fail if this method returns false\\n     * @param token The token to be checked\\n     */\\n    function isFlareAsset(address token) external view returns (bool);\\n\\n    /**\\n     * Return the asset type of the token. Asset type is a hash uniquely identifying the asset type.\\n     * For example, for wrapped native token, the type is `keccak256(\\\"wrapped native\\\")`,\\n     * and for all f-assets the type will be `keccak256(\\\"f-asset\\\")`.\\n     */\\n    function assetType(address _token) external view returns (bytes32);\\n\\n    /**\\n     * @notice Returns the address of the Flare Asset with the selected symbol\\n     * @param symbol The token's symbol\\n     */\\n    function assetBySymbol(\\n        string calldata symbol\\n    ) external view returns (address);\\n\\n    /**\\n     * @notice Returns if the Flare Asset supports delegation via IVPToken interface\\n     * @param token The token to be checked\\n     */\\n    function supportsFtsoDelegation(address token) external view returns (bool);\\n\\n    /**\\n     * @notice Returns the maximum allowed number of delegates by percent for the selected token\\n     * @param token The token to be checked\\n     */\\n    function maxDelegatesByPercent(\\n        address token\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the incentive pool address for the selected token\\n     * @param token The token to be checked\\n     */\\n    function incentivePoolFor(address token) external view returns (address);\\n\\n    /**\\n     * @notice Returns the addresses of all Flare Assets\\n     */\\n    function allAssets() external view returns (address[] memory);\\n\\n    /**\\n     * @notice Returns the addresses and associated symbols of all Flare Assets\\n     */\\n    function allAssetsWithSymbols()\\n        external\\n        view\\n        returns (address[] memory, string[] memory);\\n\\n    /**\\n     * @notice Returns all asset types.\\n     */\\n    function allAssetTypes() external view returns (bytes32[] memory);\\n\\n    /**\\n     * @notice Returns the addresses of all Flare Assets of given type.\\n     * @param _assetType a type hash, all returned assets will have this assetType\\n     */\\n    function allAssetsOfType(\\n        bytes32 _assetType\\n    ) external view returns (address[] memory);\\n\\n    /**\\n     * @notice Returns the addresses and associated symbols of all Flare Assets of given type.\\n     * @param _assetType a type hash, all returned assets will have this assetType\\n     */\\n    function allAssetsOfTypeWithSymbols(\\n        bytes32 _assetType\\n    ) external view returns (address[] memory, string[] memory);\\n\\n    /**\\n     * @notice Returns a generic asset attribute value.\\n     * @param token The token's address\\n     * @param nameHash attributes name's hash\\n     * @return defined true if the attribute is defined for this token\\n     * @return value attribute value, may have to be cast into some other type\\n     */\\n    function getAttribute(\\n        address token,\\n        bytes32 nameHash\\n    ) external view returns (bool defined, bytes32 value);\\n}\\n\",\"keccak256\":\"0x0ca9cebd37bb051e15e2b10c42980349f1208826c51e0648667285a429becc26\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFlareContractRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\npragma abicoder v2;\\n\\ninterface IFlareContractRegistry {\\n    /**\\n     * @notice Returns contract address for the given name - might be address(0)\\n     * @param _name             name of the contract\\n     */\\n    function getContractAddressByName(\\n        string calldata _name\\n    ) external view returns (address);\\n\\n    /**\\n     * @notice Returns contract address for the given name hash - might be address(0)\\n     * @param _nameHash         hash of the contract name (keccak256(abi.encode(name))\\n     */\\n    function getContractAddressByHash(\\n        bytes32 _nameHash\\n    ) external view returns (address);\\n\\n    /**\\n     * @notice Returns contract addresses for the given names - might be address(0)\\n     * @param _names            names of the contracts\\n     */\\n    function getContractAddressesByName(\\n        string[] calldata _names\\n    ) external view returns (address[] memory);\\n\\n    /**\\n     * @notice Returns contract addresses for the given name hashes - might be address(0)\\n     * @param _nameHashes       hashes of the contract names (keccak256(abi.encode(name))\\n     */\\n    function getContractAddressesByHash(\\n        bytes32[] calldata _nameHashes\\n    ) external view returns (address[] memory);\\n\\n    /**\\n     * @notice Returns all contract names and corresponding addresses\\n     */\\n    function getAllContracts()\\n        external\\n        view\\n        returns (string[] memory _names, address[] memory _addresses);\\n}\\n\",\"keccak256\":\"0xd54506e55561beb24ad2b019b5341900e46cb1d2d6fa837d40c00e096a40420f\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFlareSystemsCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * FlareSystemsCalculator interface.\\n */\\ninterface IFlareSystemsCalculator {\\n    /// Event emitted when the registration weight of a voter is calculated.\\n    event VoterRegistrationInfo(\\n        address indexed voter,\\n        uint24 indexed rewardEpochId,\\n        address delegationAddress,\\n        uint16 delegationFeeBIPS,\\n        uint256 wNatWeight,\\n        uint256 wNatCappedWeight,\\n        bytes20[] nodeIds,\\n        uint256[] nodeWeights\\n    );\\n\\n    /// WNat cap used in signing policy weight.\\n    function wNatCapPPM() external view returns (uint24);\\n    /// Non-punishable time to sign new signing policy.\\n    function signingPolicySignNonPunishableDurationSeconds()\\n        external\\n        view\\n        returns (uint64);\\n    /// Number of non-punishable blocks to sign new signing policy.\\n    function signingPolicySignNonPunishableDurationBlocks()\\n        external\\n        view\\n        returns (uint64);\\n    /// Number of blocks (in addition to non-punishable blocks) after which all rewards are burned.\\n    function signingPolicySignNoRewardsDurationBlocks()\\n        external\\n        view\\n        returns (uint64);\\n}\\n\",\"keccak256\":\"0x4e9a80294fafa1668189c071932cd4d34de5efb538d07e1e557082709da33c58\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFlareSystemsManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./ProtocolsV2Interface.sol\\\";\\n\\n/**\\n * FlareSystemsManager interface.\\n */\\ninterface IFlareSystemsManager is ProtocolsV2Interface {\\n    /// Signature structure\\n    struct Signature {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    /// Number of weight based claims structure\\n    struct NumberOfWeightBasedClaims {\\n        uint256 rewardManagerId;\\n        uint256 noOfWeightBasedClaims;\\n    }\\n\\n    /// Event emitted when random acquisition phase starts.\\n    event RandomAcquisitionStarted(\\n        uint24 indexed rewardEpochId, // Reward epoch id\\n        uint64 timestamp // Timestamp when this happened\\n    );\\n\\n    /// Event emitted when vote power block is selected.\\n    event VotePowerBlockSelected(\\n        uint24 indexed rewardEpochId, // Reward epoch id\\n        uint64 votePowerBlock, // Vote power block for given reward epoch\\n        uint64 timestamp // Timestamp when this happened\\n    );\\n\\n    /// Event emitted when signing policy is signed.\\n    event SigningPolicySigned(\\n        uint24 indexed rewardEpochId, // Reward epoch id\\n        address indexed signingPolicyAddress, // Address which signed this\\n        address indexed voter, // Voter (entity)\\n        uint64 timestamp, // Timestamp when this happened\\n        bool thresholdReached // Indicates if signing threshold was reached\\n    );\\n\\n    /// Event emitted when reward epoch starts.\\n    event RewardEpochStarted(\\n        uint24 indexed rewardEpochId, // Reward epoch id\\n        uint32 startVotingRoundId, // First voting round id of validity\\n        uint64 timestamp // Timestamp when this happened\\n    );\\n\\n    /// Event emitted when it is time to sign uptime vote.\\n    event SignUptimeVoteEnabled(\\n        uint24 indexed rewardEpochId, // Reward epoch id\\n        uint64 timestamp // Timestamp when this happened\\n    );\\n\\n    /// Event emitted when uptime vote is submitted.\\n    event UptimeVoteSubmitted(\\n        uint24 indexed rewardEpochId, // Reward epoch id\\n        address indexed signingPolicyAddress, // Address which signed this\\n        address indexed voter, // Voter (entity)\\n        bytes20[] nodeIds, // Node ids with high enough uptime\\n        uint64 timestamp // Timestamp when this happened\\n    );\\n\\n    /// Event emitted when uptime vote is signed.\\n    event UptimeVoteSigned(\\n        uint24 indexed rewardEpochId, // Reward epoch id\\n        address indexed signingPolicyAddress, // Address which signed this\\n        address indexed voter, // Voter (entity)\\n        bytes32 uptimeVoteHash, // Uptime vote hash\\n        uint64 timestamp, // Timestamp when this happened\\n        bool thresholdReached // Indicates if signing threshold was reached\\n    );\\n\\n    /// Event emitted when rewards are signed.\\n    event RewardsSigned(\\n        uint24 indexed rewardEpochId, // Reward epoch id\\n        address indexed signingPolicyAddress, // Address which signed this\\n        address indexed voter, // Voter (entity)\\n        bytes32 rewardsHash, // Rewards hash\\n        NumberOfWeightBasedClaims[] noOfWeightBasedClaims, // Number of weight based claims list\\n        uint64 timestamp, // Timestamp when this happened\\n        bool thresholdReached // Indicates if signing threshold was reached\\n    );\\n\\n    /**\\n     * Method for collecting signatures for the new signing policy.\\n     * @param _rewardEpochId Reward epoch id of the new signing policy.\\n     * @param _newSigningPolicyHash New signing policy hash.\\n     * @param _signature Signature.\\n     */\\n    function signNewSigningPolicy(\\n        uint24 _rewardEpochId,\\n        bytes32 _newSigningPolicyHash,\\n        Signature calldata _signature\\n    ) external;\\n\\n    /**\\n     * Method for submitting node ids with high enough uptime.\\n     * @param _rewardEpochId Reward epoch id of the uptime vote.\\n     * @param _nodeIds Node ids with high enough uptime.\\n     * @param _signature Signature.\\n     */\\n    function submitUptimeVote(\\n        uint24 _rewardEpochId,\\n        bytes20[] calldata _nodeIds,\\n        Signature calldata _signature\\n    ) external;\\n\\n    /**\\n     * Method for collecting signatures for the uptime vote.\\n     * @param _rewardEpochId Reward epoch id of the uptime vote.\\n     * @param _uptimeVoteHash Uptime vote hash.\\n     * @param _signature Signature.\\n     */\\n    function signUptimeVote(\\n        uint24 _rewardEpochId,\\n        bytes32 _uptimeVoteHash,\\n        Signature calldata _signature\\n    ) external;\\n\\n    /**\\n     * Method for collecting signatures for the rewards.\\n     * @param _rewardEpochId Reward epoch id of the rewards.\\n     * @param _noOfWeightBasedClaims Number of weight based claims list.\\n     * @param _rewardsHash Rewards hash.\\n     * @param _signature Signature.\\n     */\\n    function signRewards(\\n        uint24 _rewardEpochId,\\n        NumberOfWeightBasedClaims[] calldata _noOfWeightBasedClaims,\\n        bytes32 _rewardsHash,\\n        Signature calldata _signature\\n    ) external;\\n\\n    /**\\n     * Returns the seed for given reward epoch id.\\n     */\\n    function getSeed(uint256 _rewardEpochId) external view returns (uint256);\\n\\n    /**\\n     * Returns the threshold for given reward epoch id.\\n     */\\n    function getThreshold(\\n        uint256 _rewardEpochId\\n    ) external view returns (uint16);\\n\\n    /**\\n     * Returns voter rgistration data for given reward epoch id.\\n     * @param _rewardEpochId Reward epoch id.\\n     * @return _votePowerBlock Vote power block.\\n     * @return _enabled Indicates if voter registration is enabled.\\n     */\\n    function getVoterRegistrationData(\\n        uint256 _rewardEpochId\\n    ) external view returns (uint256 _votePowerBlock, bool _enabled);\\n\\n    /**\\n     * Indicates if voter registration is currently enabled.\\n     */\\n    function isVoterRegistrationEnabled() external view returns (bool);\\n\\n    /**\\n     * Returns the current reward epoch id (backwards compatibility).\\n     */\\n    function getCurrentRewardEpoch() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x69da10443bae2422dd0f8ad4a4d4bbc411060bb3aa5026194248fbe61dd7cb4c\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFtso.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\ninterface IFtso {\\n    enum PriceFinalizationType {\\n        // initial state\\n        NOT_FINALIZED,\\n        // median calculation used to find price\\n        WEIGHTED_MEDIAN,\\n        // low turnout - price calculated from median of trusted addresses\\n        TRUSTED_ADDRESSES,\\n        // low turnout + no votes from trusted addresses - price copied from previous epoch\\n        PREVIOUS_PRICE_COPIED,\\n        // price calculated from median of trusted addresses - triggered due to an exception\\n        TRUSTED_ADDRESSES_EXCEPTION,\\n        // previous price copied - triggered due to an exception\\n        PREVIOUS_PRICE_COPIED_EXCEPTION\\n    }\\n\\n    event PriceRevealed(\\n        address indexed voter,\\n        uint256 indexed epochId,\\n        uint256 price,\\n        uint256 timestamp,\\n        uint256 votePowerNat,\\n        uint256 votePowerAsset\\n    );\\n\\n    event PriceFinalized(\\n        uint256 indexed epochId,\\n        uint256 price,\\n        bool rewardedFtso,\\n        uint256 lowIQRRewardPrice,\\n        uint256 highIQRRewardPrice,\\n        uint256 lowElasticBandRewardPrice,\\n        uint256 highElasticBandRewardPrice,\\n        PriceFinalizationType finalizationType,\\n        uint256 timestamp\\n    );\\n\\n    event PriceEpochInitializedOnFtso(\\n        uint256 indexed epochId,\\n        uint256 endTime,\\n        uint256 timestamp\\n    );\\n\\n    event LowTurnout(\\n        uint256 indexed epochId,\\n        uint256 natTurnout,\\n        uint256 lowNatTurnoutThresholdBIPS,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @notice Returns if FTSO is active\\n     */\\n    function active() external view returns (bool);\\n\\n    /**\\n     * @notice Returns the FTSO symbol\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @notice Returns current epoch id\\n     */\\n    function getCurrentEpochId() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns id of the epoch which was opened for price submission at the specified timestamp\\n     * @param _timestamp            Timestamp as seconds from unix epoch\\n     */\\n    function getEpochId(uint256 _timestamp) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns random number of the specified epoch\\n     * @param _epochId              Id of the epoch\\n     */\\n    function getRandom(uint256 _epochId) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns asset price consented in specific epoch\\n     * @param _epochId              Id of the epoch\\n     * @return Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\\n     */\\n    function getEpochPrice(uint256 _epochId) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns current epoch data\\n     * @return _epochId                 Current epoch id\\n     * @return _epochSubmitEndTime      End time of the current epoch price submission as seconds from unix epoch\\n     * @return _epochRevealEndTime      End time of the current epoch price reveal as seconds from unix epoch\\n     * @return _votePowerBlock          Vote power block for the current epoch\\n     * @return _fallbackMode            Current epoch in fallback mode - only votes from trusted addresses will be used\\n     * @dev half-closed intervals - end time not included\\n     */\\n    function getPriceEpochData()\\n        external\\n        view\\n        returns (\\n            uint256 _epochId,\\n            uint256 _epochSubmitEndTime,\\n            uint256 _epochRevealEndTime,\\n            uint256 _votePowerBlock,\\n            bool _fallbackMode\\n        );\\n\\n    /**\\n     * @notice Returns current epoch data\\n     * @return _firstEpochStartTs           First epoch start timestamp\\n     * @return _submitPeriodSeconds         Submit period in seconds\\n     * @return _revealPeriodSeconds         Reveal period in seconds\\n     */\\n    function getPriceEpochConfiguration()\\n        external\\n        view\\n        returns (\\n            uint256 _firstEpochStartTs,\\n            uint256 _submitPeriodSeconds,\\n            uint256 _revealPeriodSeconds\\n        );\\n\\n    /**\\n     * @notice Returns asset price submitted by voter in specific epoch\\n     * @param _epochId              Id of the epoch\\n     * @param _voter                Address of the voter\\n     * @return Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\\n     */\\n    function getEpochPriceForVoter(\\n        uint256 _epochId,\\n        address _voter\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns current asset price\\n     * @return _price               Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\\n     * @return _timestamp           Time when price was updated for the last time\\n     */\\n    function getCurrentPrice()\\n        external\\n        view\\n        returns (uint256 _price, uint256 _timestamp);\\n\\n    /**\\n     * @notice Returns current asset price and number of decimals\\n     * @return _price                   Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\\n     * @return _timestamp               Time when price was updated for the last time\\n     * @return _assetPriceUsdDecimals   Number of decimals used for USD price\\n     */\\n    function getCurrentPriceWithDecimals()\\n        external\\n        view\\n        returns (\\n            uint256 _price,\\n            uint256 _timestamp,\\n            uint256 _assetPriceUsdDecimals\\n        );\\n\\n    /**\\n     * @notice Returns current asset price calculated from trusted providers\\n     * @return _price               Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\\n     * @return _timestamp           Time when price was updated for the last time\\n     */\\n    function getCurrentPriceFromTrustedProviders()\\n        external\\n        view\\n        returns (uint256 _price, uint256 _timestamp);\\n\\n    /**\\n     * @notice Returns current asset price calculated from trusted providers and number of decimals\\n     * @return _price                   Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\\n     * @return _timestamp               Time when price was updated for the last time\\n     * @return _assetPriceUsdDecimals   Number of decimals used for USD price\\n     */\\n    function getCurrentPriceWithDecimalsFromTrustedProviders()\\n        external\\n        view\\n        returns (\\n            uint256 _price,\\n            uint256 _timestamp,\\n            uint256 _assetPriceUsdDecimals\\n        );\\n\\n    /**\\n     * @notice Returns current asset price details\\n     * @return _price                                   Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\\n     * @return _priceTimestamp                          Time when price was updated for the last time\\n     * @return _priceFinalizationType                   Finalization type when price was updated for the last time\\n     * @return _lastPriceEpochFinalizationTimestamp     Time when last price epoch was finalized\\n     * @return _lastPriceEpochFinalizationType          Finalization type of last finalized price epoch\\n     */\\n    function getCurrentPriceDetails()\\n        external\\n        view\\n        returns (\\n            uint256 _price,\\n            uint256 _priceTimestamp,\\n            PriceFinalizationType _priceFinalizationType,\\n            uint256 _lastPriceEpochFinalizationTimestamp,\\n            PriceFinalizationType _lastPriceEpochFinalizationType\\n        );\\n\\n    /**\\n     * @notice Returns current random number\\n     */\\n    function getCurrentRandom() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x900a159dbeb4e580cb4617b59b910bbcb9591f3e051e17f211815f73cfd3b8fe\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFtsoFeedDecimals.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * FtsoFeedDecimals interface.\\n */\\ninterface IFtsoFeedDecimals {\\n    /// Event emitted when a feed decimals value is changed.\\n    event DecimalsChanged(\\n        bytes21 indexed feedId,\\n        int8 decimals,\\n        uint24 rewardEpochId\\n    );\\n\\n    /// The offset in reward epochs for the decimals value to become effective.\\n    function decimalsUpdateOffset() external view returns (uint24);\\n\\n    /// The default decimals value.\\n    function defaultDecimals() external view returns (int8);\\n\\n    /**\\n     * Returns current decimals set for `_feedId`.\\n     * @param _feedId Feed id.\\n     */\\n    function getCurrentDecimals(bytes21 _feedId) external view returns (int8);\\n\\n    /**\\n     * Returns the decimals of `_feedId` for given reward epoch id.\\n     * @param _feedId Feed id.\\n     * @param _rewardEpochId Reward epoch id.\\n     * **NOTE:** decimals might still change for the `current + decimalsUpdateOffset` reward epoch id.\\n     */\\n    function getDecimals(\\n        bytes21 _feedId,\\n        uint256 _rewardEpochId\\n    ) external view returns (int8);\\n\\n    /**\\n     * Returns the scheduled decimals changes of `_feedId`.\\n     * @param _feedId Feed id.\\n     * @return _decimals Positional array of decimals.\\n     * @return _validFromEpochId Positional array of reward epoch ids the decimals settings are effective from.\\n     * @return _fixed Positional array of boolean values indicating if settings are subjected to change.\\n     */\\n    function getScheduledDecimalsChanges(\\n        bytes21 _feedId\\n    )\\n        external\\n        view\\n        returns (\\n            int8[] memory _decimals,\\n            uint256[] memory _validFromEpochId,\\n            bool[] memory _fixed\\n        );\\n\\n    /**\\n     * Returns current decimals setting for `_feedIds`.\\n     * @param _feedIds Concatenated feed ids (each feedId bytes21).\\n     * @return _decimals Concatenated corresponding decimals (each as bytes1(uint8(int8))).\\n     */\\n    function getCurrentDecimalsBulk(\\n        bytes memory _feedIds\\n    ) external view returns (bytes memory _decimals);\\n\\n    /**\\n     * Returns decimals setting for `_feedIds` at `_rewardEpochId`.\\n     * @param _feedIds Concatenated feed ids (each feedId bytes21).\\n     * @param _rewardEpochId Reward epoch id.\\n     * @return _decimals Concatenated corresponding decimals (each as bytes1(uint8(int8))).\\n     * **NOTE:** decimals might still change for the `current + decimalsUpdateOffset` reward epoch id.\\n     */\\n    function getDecimalsBulk(\\n        bytes memory _feedIds,\\n        uint256 _rewardEpochId\\n    ) external view returns (bytes memory _decimals);\\n}\\n\",\"keccak256\":\"0x7f24e6c9c1ea0a00a1a0015ffddf6d55d1646e84bce713ca011d017b5cfe477e\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFtsoFeedIdConverter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * IFtsoFeedIdConverter interface.\\n */\\ninterface IFtsoFeedIdConverter {\\n    /**\\n     * Returns the feed id for given category and name.\\n     * @param _category Feed category.\\n     * @param _name Feed name.\\n     * @return Feed id.\\n     */\\n    function getFeedId(\\n        uint8 _category,\\n        string memory _name\\n    ) external view returns (bytes21);\\n\\n    /**\\n     * Returns the feed category and name for given feed id.\\n     * @param _feedId Feed id.\\n     * @return _category Feed category.\\n     * @return _name Feed name.\\n     */\\n    function getFeedCategoryAndName(\\n        bytes21 _feedId\\n    ) external pure returns (uint8 _category, string memory _name);\\n}\\n\",\"keccak256\":\"0xa926798df6421ce6dca38613ce94c74fd030535e46c46e2738e62c8ac959c72c\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFtsoFeedPublisher.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * FtsoFeedPublisher interface.\\n */\\ninterface IFtsoFeedPublisher {\\n    /// The FTSO feed struct.\\n    struct Feed {\\n        uint32 votingRoundId;\\n        bytes21 id;\\n        int32 value;\\n        uint16 turnoutBIPS;\\n        int8 decimals;\\n    }\\n\\n    /// The FTSO random struct.\\n    struct Random {\\n        uint32 votingRoundId;\\n        uint256 value;\\n        bool isSecure;\\n    }\\n\\n    /// The FTSO feed with proof struct.\\n    struct FeedWithProof {\\n        bytes32[] merkleProof;\\n        Feed body;\\n    }\\n\\n    /// Event emitted when a new feed is published.\\n    event FtsoFeedPublished(\\n        uint32 indexed votingRoundId,\\n        bytes21 indexed id,\\n        int32 value,\\n        uint16 turnoutBIPS,\\n        int8 decimals\\n    );\\n\\n    /**\\n     * Publishes feeds.\\n     * @param _proofs The FTSO feeds with proofs to publish.\\n     */\\n    function publish(FeedWithProof[] calldata _proofs) external;\\n\\n    /**\\n     *The FTSO protocol id.\\n     */\\n    function ftsoProtocolId() external view returns (uint8);\\n\\n    /**\\n     * The size of the feeds history.\\n     */\\n    function feedsHistorySize() external view returns (uint256);\\n\\n    /**\\n     * Returns the current feed.\\n     * @param _feedId Feed id.\\n     */\\n    function getCurrentFeed(\\n        bytes21 _feedId\\n    ) external view returns (Feed memory);\\n\\n    /**\\n     * Returns the feed for given voting round id.\\n     * @param _feedId Feed id.\\n     * @param _votingRoundId Voting round id.\\n     */\\n    function getFeed(\\n        bytes21 _feedId,\\n        uint256 _votingRoundId\\n    ) external view returns (Feed memory);\\n}\\n\",\"keccak256\":\"0x6c056388eb649272f192fa01ad68466b563b3fd27fbb009665d16ab06ebdd1db\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFtsoInflationConfigurations.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * FtsoInflationConfigurations interface.\\n */\\ninterface IFtsoInflationConfigurations {\\n    /// The FTSO configuration struct.\\n    struct FtsoConfiguration {\\n        // concatenated feed ids - i.e. category + base/quote symbol - multiple of 21 (one feedId is bytes21)\\n        bytes feedIds;\\n        // inflation share for this configuration group\\n        uint24 inflationShare;\\n        // minimal reward eligibility turnout threshold in BIPS (basis points)\\n        uint16 minRewardedTurnoutBIPS;\\n        // primary band reward share in PPM (parts per million)\\n        uint24 primaryBandRewardSharePPM;\\n        // secondary band width in PPM (parts per million) in relation to the median - multiple of 3 (uint24)\\n        bytes secondaryBandWidthPPMs;\\n        // rewards split mode (0 means equally, 1 means random,...)\\n        uint16 mode;\\n    }\\n\\n    /**\\n     * Returns the FTSO configuration at `_index`.\\n     * @param _index The index of the FTSO configuration.\\n     */\\n    function getFtsoConfiguration(\\n        uint256 _index\\n    ) external view returns (FtsoConfiguration memory);\\n\\n    /**\\n     * Returns the FTSO configurations.\\n     */\\n    function getFtsoConfigurations()\\n        external\\n        view\\n        returns (FtsoConfiguration[] memory);\\n}\\n\",\"keccak256\":\"0x294659cf3d047f5669e798dce52e6bb6288786c72c74361f48987253887824d1\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFtsoManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./ftso/interfaces/IIFtso.sol\\\";\\nimport \\\"./genesis/interfaces/IFtsoManagerGenesis.sol\\\";\\n\\ninterface IFtsoManager is IFtsoManagerGenesis {\\n    event FtsoAdded(IIFtso ftso, bool add);\\n    event FallbackMode(bool fallbackMode);\\n    event FtsoFallbackMode(IIFtso ftso, bool fallbackMode);\\n    event RewardEpochFinalized(uint256 votepowerBlock, uint256 startBlock);\\n    event PriceEpochFinalized(address chosenFtso, uint256 rewardEpochId);\\n    event InitializingCurrentEpochStateForRevealFailed(\\n        IIFtso ftso,\\n        uint256 epochId\\n    );\\n    event FinalizingPriceEpochFailed(\\n        IIFtso ftso,\\n        uint256 epochId,\\n        IFtso.PriceFinalizationType failingType\\n    );\\n    event DistributingRewardsFailed(address ftso, uint256 epochId);\\n    event AccruingUnearnedRewardsFailed(uint256 epochId);\\n    event UseGoodRandomSet(\\n        bool useGoodRandom,\\n        uint256 maxWaitForGoodRandomSeconds\\n    );\\n\\n    function active() external view returns (bool);\\n\\n    function getCurrentRewardEpoch() external view returns (uint256);\\n\\n    function getRewardEpochVotePowerBlock(\\n        uint256 _rewardEpoch\\n    ) external view returns (uint256);\\n\\n    function getRewardEpochToExpireNext() external view returns (uint256);\\n\\n    function getCurrentPriceEpochData()\\n        external\\n        view\\n        returns (\\n            uint256 _priceEpochId,\\n            uint256 _priceEpochStartTimestamp,\\n            uint256 _priceEpochEndTimestamp,\\n            uint256 _priceEpochRevealEndTimestamp,\\n            uint256 _currentTimestamp\\n        );\\n\\n    function getFtsos() external view returns (IIFtso[] memory _ftsos);\\n\\n    function getPriceEpochConfiguration()\\n        external\\n        view\\n        returns (\\n            uint256 _firstPriceEpochStartTs,\\n            uint256 _priceEpochDurationSeconds,\\n            uint256 _revealEpochDurationSeconds\\n        );\\n\\n    function getRewardEpochConfiguration()\\n        external\\n        view\\n        returns (\\n            uint256 _firstRewardEpochStartTs,\\n            uint256 _rewardEpochDurationSeconds\\n        );\\n\\n    function getFallbackMode()\\n        external\\n        view\\n        returns (\\n            bool _fallbackMode,\\n            IIFtso[] memory _ftsos,\\n            bool[] memory _ftsoInFallbackMode\\n        );\\n}\\n\",\"keccak256\":\"0xeb975b78219709b635834a06e290e3c2e4801149310865ac4a8ca4c9a25faed2\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFtsoRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\npragma abicoder v2;\\n\\nimport \\\"./ftso/interfaces/IIFtso.sol\\\";\\nimport \\\"./genesis/interfaces/IFtsoRegistryGenesis.sol\\\";\\n\\ninterface IFtsoRegistry is IFtsoRegistryGenesis {\\n    struct PriceInfo {\\n        uint256 ftsoIndex;\\n        uint256 price;\\n        uint256 decimals;\\n        uint256 timestamp;\\n    }\\n\\n    function getFtso(\\n        uint256 _ftsoIndex\\n    ) external view returns (IIFtso _activeFtsoAddress);\\n    function getFtsoBySymbol(\\n        string memory _symbol\\n    ) external view returns (IIFtso _activeFtsoAddress);\\n    function getSupportedIndices()\\n        external\\n        view\\n        returns (uint256[] memory _supportedIndices);\\n    function getSupportedSymbols()\\n        external\\n        view\\n        returns (string[] memory _supportedSymbols);\\n    function getSupportedFtsos() external view returns (IIFtso[] memory _ftsos);\\n    function getFtsoIndex(\\n        string memory _symbol\\n    ) external view returns (uint256 _assetIndex);\\n    function getFtsoSymbol(\\n        uint256 _ftsoIndex\\n    ) external view returns (string memory _symbol);\\n    function getCurrentPrice(\\n        uint256 _ftsoIndex\\n    ) external view returns (uint256 _price, uint256 _timestamp);\\n    function getCurrentPrice(\\n        string memory _symbol\\n    ) external view returns (uint256 _price, uint256 _timestamp);\\n    function getCurrentPriceWithDecimals(\\n        uint256 _assetIndex\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 _price,\\n            uint256 _timestamp,\\n            uint256 _assetPriceUsdDecimals\\n        );\\n    function getCurrentPriceWithDecimals(\\n        string memory _symbol\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 _price,\\n            uint256 _timestamp,\\n            uint256 _assetPriceUsdDecimals\\n        );\\n\\n    function getAllCurrentPrices() external view returns (PriceInfo[] memory);\\n    function getCurrentPricesByIndices(\\n        uint256[] memory _indices\\n    ) external view returns (PriceInfo[] memory);\\n    function getCurrentPricesBySymbols(\\n        string[] memory _symbols\\n    ) external view returns (PriceInfo[] memory);\\n\\n    function getSupportedIndicesAndFtsos()\\n        external\\n        view\\n        returns (uint256[] memory _supportedIndices, IIFtso[] memory _ftsos);\\n\\n    function getSupportedSymbolsAndFtsos()\\n        external\\n        view\\n        returns (string[] memory _supportedSymbols, IIFtso[] memory _ftsos);\\n\\n    function getSupportedIndicesAndSymbols()\\n        external\\n        view\\n        returns (\\n            uint256[] memory _supportedIndices,\\n            string[] memory _supportedSymbols\\n        );\\n\\n    function getSupportedIndicesSymbolsAndFtsos()\\n        external\\n        view\\n        returns (\\n            uint256[] memory _supportedIndices,\\n            string[] memory _supportedSymbols,\\n            IIFtso[] memory _ftsos\\n        );\\n}\\n\",\"keccak256\":\"0xd8714e7c20a8541da55d4418c5b8e03958c3d5e6e7aa152238c48a43cf05fa02\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFtsoRewardManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\ninterface IFtsoRewardManager {\\n    event RewardClaimed(\\n        address indexed dataProvider,\\n        address indexed whoClaimed,\\n        address indexed sentTo,\\n        uint256 rewardEpoch,\\n        uint256 amount\\n    );\\n\\n    event UnearnedRewardsAccrued(uint256 epochId, uint256 reward);\\n\\n    event RewardsDistributed(\\n        address indexed ftso,\\n        uint256 epochId,\\n        address[] addresses,\\n        uint256[] rewards\\n    );\\n\\n    event RewardClaimsEnabled(uint256 rewardEpochId);\\n\\n    event FeePercentageChanged(\\n        address indexed dataProvider,\\n        uint256 value,\\n        uint256 validFromEpoch\\n    );\\n\\n    event RewardClaimsExpired(uint256 rewardEpochId);\\n\\n    event FtsoRewardManagerActivated(address ftsoRewardManager);\\n    event FtsoRewardManagerDeactivated(address ftsoRewardManager);\\n\\n    /**\\n     * @notice Allows a percentage delegator to claim rewards.\\n     * @notice This function is intended to be used to claim rewards in case of delegation by percentage.\\n     * @param _recipient            address to transfer funds to\\n     * @param _rewardEpochs         array of reward epoch numbers to claim for\\n     * @return _rewardAmount        amount of total claimed rewards\\n     * @dev Reverts if `msg.sender` is delegating by amount\\n     * @dev Claims for all unclaimed reward epochs to the 'max(_rewardEpochs)'.\\n     * @dev Retained for backward compatibility.\\n     * @dev This function is deprecated - use `claim` instead.\\n     */\\n    function claimReward(\\n        address payable _recipient,\\n        uint256[] calldata _rewardEpochs\\n    ) external returns (uint256 _rewardAmount);\\n\\n    /**\\n     * @notice Allows the sender to claim or wrap rewards for reward owner.\\n     * @notice This function is intended to be used to claim rewards in case of delegation by percentage.\\n     * @notice The caller does not have to be the owner, but must be approved by the owner to claim on his behalf,\\n     *   this approval is done by calling `setClaimExecutors`.\\n     * @notice It is actually safe for this to be called by anybody (nothing can be stolen), but by limiting who can\\n     *   call, we allow the owner to control the timing of the calls.\\n     * @notice Reward owner can claim to any `_recipient`, while the executor can only claim to the reward owner,\\n     *   reward owners's personal delegation account or one of the addresses set by `setAllowedClaimRecipients`.\\n     * @param _rewardOwner          address of the reward owner\\n     * @param _recipient            address to transfer funds to\\n     * @param _rewardEpoch          last reward epoch to claim for\\n     * @param _wrap                 should reward be wrapped immediately\\n     * @return _rewardAmount        amount of total claimed rewards\\n     * @dev Reverts if `msg.sender` is delegating by amount\\n     */\\n    function claim(\\n        address _rewardOwner,\\n        address payable _recipient,\\n        uint256 _rewardEpoch,\\n        bool _wrap\\n    ) external returns (uint256 _rewardAmount);\\n\\n    /**\\n     * @notice Allows the sender to claim rewards from specified data providers.\\n     * @notice This function is intended to be used to claim rewards in case of delegation by amount.\\n     * @param _recipient            address to transfer funds to\\n     * @param _rewardEpochs         array of reward epoch numbers to claim for\\n     * @param _dataProviders        array of addresses representing data providers to claim the reward from\\n     * @return _rewardAmount        amount of total claimed rewards\\n     * @dev Function can only be used for explicit delegations.\\n     * @dev This function is deprecated - use `claimFromDataProviders` instead.\\n     */\\n    function claimRewardFromDataProviders(\\n        address payable _recipient,\\n        uint256[] calldata _rewardEpochs,\\n        address[] calldata _dataProviders\\n    ) external returns (uint256 _rewardAmount);\\n\\n    /**\\n     * @notice Allows the sender to claim or wrap rewards for reward owner from specified data providers.\\n     * @notice This function is intended to be used to claim rewards in case of delegation by amount.\\n     * @notice The caller does not have to be the owner, but must be approved by the owner to claim on his behalf,\\n     *   this approval is done by calling `setClaimExecutors`.\\n     * @notice It is actually safe for this to be called by anybody (nothing can be stolen), but by limiting who can\\n     *   call, we allow the owner to control the timing of the calls.\\n     * @notice Reward owner can claim to any `_recipient`, while the executor can only claim to the reward owner,\\n     *   reward owners's personal delegation account or one of the addresses set by `setAllowedClaimRecipients`.\\n     * @param _rewardOwner          address of the reward owner\\n     * @param _recipient            address to transfer funds to\\n     * @param _rewardEpochs         array of reward epoch numbers to claim for\\n     * @param _dataProviders        array of addresses representing data providers to claim the reward from\\n     * @param _wrap                 should reward be wrapped immediately\\n     * @return _rewardAmount        amount of total claimed rewards\\n     * @dev Function can only be used for explicit delegations.\\n     */\\n    function claimFromDataProviders(\\n        address _rewardOwner,\\n        address payable _recipient,\\n        uint256[] calldata _rewardEpochs,\\n        address[] calldata _dataProviders,\\n        bool _wrap\\n    ) external returns (uint256 _rewardAmount);\\n\\n    /**\\n     * @notice Allows batch claiming for the list of '_rewardOwners' and for all unclaimed epochs <= '_rewardEpoch'.\\n     * @notice If reward owner has enabled delegation account, rewards are also claimed for that delegation account and\\n     *   total claimed amount is sent to that delegation account, otherwise claimed amount is sent to owner's account.\\n     * @notice Claimed amount is automatically wrapped.\\n     * @notice Method can be used by reward owner or executor. If executor is registered with fee > 0,\\n     *   then fee is paid to executor for each claimed address from the list.\\n     * @param _rewardOwners         list of reward owners to claim for\\n     * @param _rewardEpoch          last reward epoch to claim for\\n     */\\n    function autoClaim(\\n        address[] calldata _rewardOwners,\\n        uint256 _rewardEpoch\\n    ) external;\\n\\n    /**\\n     * @notice Allows data provider to set (or update last) fee percentage.\\n     * @param _feePercentageBIPS    number representing fee percentage in BIPS\\n     * @return _validFromEpoch      reward epoch number when the setting becomes effective.\\n     */\\n    function setDataProviderFeePercentage(\\n        uint256 _feePercentageBIPS\\n    ) external returns (uint256 _validFromEpoch);\\n\\n    /**\\n     * @notice Allows reward claiming\\n     */\\n    function active() external view returns (bool);\\n\\n    /**\\n     * @notice Returns the current fee percentage of `_dataProvider`\\n     * @param _dataProvider         address representing data provider\\n     */\\n    function getDataProviderCurrentFeePercentage(\\n        address _dataProvider\\n    ) external view returns (uint256 _feePercentageBIPS);\\n\\n    /**\\n     * @notice Returns the fee percentage of `_dataProvider` at `_rewardEpoch`\\n     * @param _dataProvider         address representing data provider\\n     * @param _rewardEpoch          reward epoch number\\n     */\\n    function getDataProviderFeePercentage(\\n        address _dataProvider,\\n        uint256 _rewardEpoch\\n    ) external view returns (uint256 _feePercentageBIPS);\\n\\n    /**\\n     * @notice Returns the scheduled fee percentage changes of `_dataProvider`\\n     * @param _dataProvider         address representing data provider\\n     * @return _feePercentageBIPS   positional array of fee percentages in BIPS\\n     * @return _validFromEpoch      positional array of block numbers the fee settings are effective from\\n     * @return _fixed               positional array of boolean values indicating if settings are subjected to change\\n     */\\n    function getDataProviderScheduledFeePercentageChanges(\\n        address _dataProvider\\n    )\\n        external\\n        view\\n        returns (\\n            uint256[] memory _feePercentageBIPS,\\n            uint256[] memory _validFromEpoch,\\n            bool[] memory _fixed\\n        );\\n\\n    /**\\n     * @notice Returns information on epoch reward\\n     * @param _rewardEpoch          reward epoch number\\n     * @return _totalReward         number representing the total epoch reward\\n     * @return _claimedReward       number representing the amount of total epoch reward that has been claimed\\n     */\\n    function getEpochReward(\\n        uint256 _rewardEpoch\\n    ) external view returns (uint256 _totalReward, uint256 _claimedReward);\\n\\n    /**\\n     * @notice Returns the state of rewards for `_beneficiary` at `_rewardEpoch`\\n     * @param _beneficiary          address of reward beneficiary\\n     * @param _rewardEpoch          reward epoch number\\n     * @return _dataProviders       positional array of addresses representing data providers\\n     * @return _rewardAmounts       positional array of reward amounts\\n     * @return _claimed             positional array of boolean values indicating if reward is claimed\\n     * @return _claimable           boolean value indicating if rewards are claimable\\n     * @dev Reverts when queried with `_beneficiary` delegating by amount\\n     */\\n    function getStateOfRewards(\\n        address _beneficiary,\\n        uint256 _rewardEpoch\\n    )\\n        external\\n        view\\n        returns (\\n            address[] memory _dataProviders,\\n            uint256[] memory _rewardAmounts,\\n            bool[] memory _claimed,\\n            bool _claimable\\n        );\\n\\n    /**\\n     * @notice Returns the state of rewards for `_beneficiary` at `_rewardEpoch` from `_dataProviders`\\n     * @param _beneficiary          address of reward beneficiary\\n     * @param _rewardEpoch          reward epoch number\\n     * @param _dataProviders        positional array of addresses representing data providers\\n     * @return _rewardAmounts       positional array of reward amounts\\n     * @return _claimed             positional array of boolean values indicating if reward is claimed\\n     * @return _claimable           boolean value indicating if rewards are claimable\\n     */\\n    function getStateOfRewardsFromDataProviders(\\n        address _beneficiary,\\n        uint256 _rewardEpoch,\\n        address[] calldata _dataProviders\\n    )\\n        external\\n        view\\n        returns (\\n            uint256[] memory _rewardAmounts,\\n            bool[] memory _claimed,\\n            bool _claimable\\n        );\\n\\n    /**\\n     * @notice Returns the start and the end of the reward epoch range for which the reward is claimable\\n     * @param _startEpochId         the oldest epoch id that allows reward claiming\\n     * @param _endEpochId           the newest epoch id that allows reward claiming\\n     */\\n    function getEpochsWithClaimableRewards()\\n        external\\n        view\\n        returns (uint256 _startEpochId, uint256 _endEpochId);\\n\\n    /**\\n     * @notice Returns the next claimable reward epoch for '_rewardOwner'.\\n     * @param _rewardOwner          address of the reward owner\\n     */\\n    function nextClaimableRewardEpoch(\\n        address _rewardOwner\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the array of claimable epoch ids for which the reward has not yet been claimed\\n     * @param _beneficiary          address of reward beneficiary\\n     * @return _epochIds            array of epoch ids\\n     * @dev Reverts when queried with `_beneficiary` delegating by amount\\n     */\\n    function getEpochsWithUnclaimedRewards(\\n        address _beneficiary\\n    ) external view returns (uint256[] memory _epochIds);\\n\\n    /**\\n     * @notice Returns the information on claimed reward of `_dataProvider` for `_rewardEpoch` by `_claimer`\\n     * @param _rewardEpoch          reward epoch number\\n     * @param _dataProvider         address representing the data provider\\n     * @param _claimer              address representing the claimer\\n     * @return _claimed             boolean indicating if reward has been claimed\\n     * @return _amount              number representing the claimed amount\\n     */\\n    function getClaimedReward(\\n        uint256 _rewardEpoch,\\n        address _dataProvider,\\n        address _claimer\\n    ) external view returns (bool _claimed, uint256 _amount);\\n\\n    /**\\n     * @notice Return reward epoch that will expire, when new reward epoch will start\\n     * @return Reward epoch id that will expire next\\n     */\\n    function getRewardEpochToExpireNext() external view returns (uint256);\\n\\n    /**\\n     * @notice Return reward epoch vote power block\\n     * @param _rewardEpoch          reward epoch number\\n     */\\n    function getRewardEpochVotePowerBlock(\\n        uint256 _rewardEpoch\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Return current reward epoch number\\n     */\\n    function getCurrentRewardEpoch() external view returns (uint256);\\n\\n    /**\\n     * @notice Return initial reward epoch number\\n     */\\n    function getInitialRewardEpoch() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the information on rewards and initial vote power of `_dataProvider` for `_rewardEpoch`\\n     * @param _rewardEpoch                      reward epoch number\\n     * @param _dataProvider                     address representing the data provider\\n     * @return _rewardAmount                    number representing the amount of rewards\\n     * @return _votePowerIgnoringRevocation     number representing the vote power ignoring revocations\\n     */\\n    function getDataProviderPerformanceInfo(\\n        uint256 _rewardEpoch,\\n        address _dataProvider\\n    )\\n        external\\n        view\\n        returns (uint256 _rewardAmount, uint256 _votePowerIgnoringRevocation);\\n}\\n\",\"keccak256\":\"0x5381acc5f33d5670f007203a5fb152028690e19b65aef407111d67e12ece8c65\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFtsoRewardOffersManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * FtsoRewardOffersManager interface.\\n */\\ninterface IFtsoRewardOffersManager {\\n    /**\\n     * Defines a reward offer.\\n     */\\n    struct Offer {\\n        // amount (in wei) of reward in native coin\\n        uint120 amount;\\n        // feed id - i.e. category + base/quote symbol\\n        bytes21 feedId;\\n        // minimal reward eligibility turnout threshold in BIPS (basis points)\\n        uint16 minRewardedTurnoutBIPS;\\n        // primary band reward share in PPM (parts per million)\\n        uint24 primaryBandRewardSharePPM;\\n        // secondary band width in PPM (parts per million) in relation to the median\\n        uint24 secondaryBandWidthPPM;\\n        // address that can claim undistributed part of the reward (or burn address)\\n        address claimBackAddress;\\n    }\\n\\n    /// Event emitted when the minimal rewards offer value is set.\\n    event MinimalRewardsOfferValueSet(uint256 valueWei);\\n\\n    /// Event emitted when a reward offer is received.\\n    event RewardsOffered(\\n        // reward epoch id\\n        uint24 indexed rewardEpochId,\\n        // feed id - i.e. category + base/quote symbol\\n        bytes21 feedId,\\n        // number of decimals (negative exponent)\\n        int8 decimals,\\n        // amount (in wei) of reward in native coin\\n        uint256 amount,\\n        // minimal reward eligibility turnout threshold in BIPS (basis points)\\n        uint16 minRewardedTurnoutBIPS,\\n        // primary band reward share in PPM (parts per million)\\n        uint24 primaryBandRewardSharePPM,\\n        // secondary band width in PPM (parts per million) in relation to the median\\n        uint24 secondaryBandWidthPPM,\\n        // address that can claim undistributed part of the reward (or burn address)\\n        address claimBackAddress\\n    );\\n\\n    /// Event emitted when inflation rewards are offered.\\n    event InflationRewardsOffered(\\n        // reward epoch id\\n        uint24 indexed rewardEpochId,\\n        // feed ids - i.e. category + base/quote symbols - multiple of 21 (one feedId is bytes21)\\n        bytes feedIds,\\n        // decimals encoded to - multiple of 1 (int8)\\n        bytes decimals,\\n        // amount (in wei) of reward in native coin\\n        uint256 amount,\\n        // minimal reward eligibility turnout threshold in BIPS (basis points)\\n        uint16 minRewardedTurnoutBIPS,\\n        // primary band reward share in PPM (parts per million)\\n        uint24 primaryBandRewardSharePPM,\\n        // secondary band width in PPM (parts per million) in relation to the median - multiple of 3 (uint24)\\n        bytes secondaryBandWidthPPMs,\\n        // rewards split mode (0 means equally, 1 means random,...)\\n        uint16 mode\\n    );\\n\\n    /**\\n     * Allows community to offer rewards.\\n     * @param _nextRewardEpochId The next reward epoch id.\\n     * @param _offers The list of offers.\\n     */\\n    function offerRewards(\\n        uint24 _nextRewardEpochId,\\n        Offer[] calldata _offers\\n    ) external payable;\\n\\n    /**\\n     * Minimal rewards offer value (in wei).\\n     */\\n    function minimalRewardsOfferValueWei() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xd31319f92f360e5729161b4b5a341d69514b87d03b7dc1a6888488d272e02458\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IGenericRewardManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\ninterface IGenericRewardManager {\\n    event RewardClaimed(\\n        address indexed beneficiary,\\n        address indexed sentTo,\\n        uint256 amount\\n    );\\n\\n    event RewardsDistributed(address[] addresses, uint256[] rewards);\\n\\n    event ClaimExecutorsChanged(address rewardOwner, address[] executors);\\n\\n    event AllowedClaimRecipientsChanged(\\n        address rewardOwner,\\n        address[] recipients\\n    );\\n\\n    event RewardManagerActivated(address rewardManager);\\n    event RewardManagerDeactivated(address rewardManager);\\n\\n    /**\\n     * @notice Allows the sender to claim or wrap rewards for reward owner.\\n     * @notice The caller does not have to be the owner, but must be approved by the owner to claim on his behalf.\\n     *   this approval is done by calling `setClaimExecutors`.\\n     * @notice It is actually safe for this to be called by anybody (nothing can be stolen), but by limiting who can\\n     *   call, we allow the owner to control the timing of the calls.\\n     * @notice Reward owner can claim to any `_recipient`, while the executor can only claim to the reward owner or\\n     *   one of the addresses set by `setAllowedClaimRecipients`.\\n     * @param _rewardOwner          address of the reward owner\\n     * @param _recipient            address to transfer funds to\\n     * @param _rewardAmount         amount of rewards to claim\\n     * @param _wrap                 should reward be wrapped immediately\\n     */\\n    function claim(\\n        address _rewardOwner,\\n        address payable _recipient,\\n        uint256 _rewardAmount,\\n        bool _wrap\\n    ) external;\\n\\n    /**\\n     * Set the addresses of executors, who are allowed to call `claim`.\\n     * @param _executors The new executors. All old executors will be deleted and replaced by these.\\n     */\\n    function setClaimExecutors(address[] memory _executors) external;\\n\\n    /**\\n     * Set the addresses of allowed recipients in the methods `claim`.\\n     * Apart from these, the reward owner is always an allowed recipient.\\n     * @param _recipients The new allowed recipients. All old recipients will be deleted and replaced by these.\\n     */\\n    function setAllowedClaimRecipients(address[] memory _recipients) external;\\n\\n    /**\\n     * @notice Allows reward claiming\\n     */\\n    function active() external view returns (bool);\\n\\n    /**\\n     * @notice Returns information of beneficiary rewards\\n     * @param _beneficiary          beneficiary address\\n     * @return _totalReward         number representing the total reward\\n     * @return _claimedReward       number representing the amount of total reward that has been claimed\\n     */\\n    function getStateOfRewards(\\n        address _beneficiary\\n    ) external view returns (uint256 _totalReward, uint256 _claimedReward);\\n\\n    /**\\n     * Get the addresses of executors, who are allowed to call `claim`.\\n     */\\n    function claimExecutors(\\n        address _rewardOwner\\n    ) external view returns (address[] memory);\\n\\n    /**\\n     * Get the addresses of allowed recipients in the methods `claim`.\\n     * Apart from these, the reward owner is always an allowed recipient.\\n     */\\n    function allowedClaimRecipients(\\n        address _rewardOwner\\n    ) external view returns (address[] memory);\\n}\\n\",\"keccak256\":\"0xb031e7ce0fd966a49b2537b2c461be0d7b65a7fab76fa60df580cf37ebce26e3\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IGovernanceSettings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * A special contract that holds Flare governance address.\\n * This contract enables updating governance address and timelock only by hard forking the network,\\n * meaning only by updating validator code.\\n */\\ninterface IGovernanceSettings {\\n    /**\\n     * Get the governance account address.\\n     * The governance address can only be changed by a hardfork.\\n     */\\n    function getGovernanceAddress() external view returns (address);\\n\\n    /**\\n     * Get the time in seconds that must pass between a governance call and execution.\\n     * The timelock value can only be changed by a hardfork.\\n     */\\n    function getTimelock() external view returns (uint256);\\n\\n    /**\\n     * Get the addresses of the accounts that are allowed to execute the timelocked governance calls\\n     * once the timelock period expires.\\n     * Executors can be changed without a hardfork, via a normal governance call.\\n     */\\n    function getExecutors() external view returns (address[] memory);\\n\\n    /**\\n     * Check whether an address is one of the executors.\\n     */\\n    function isExecutor(address _address) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xfe219349e5dcbbb002f109db72eed163e4768f380253aa4e03f1892b07ac6a4a\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IGovernanceVotePower.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * Interface for contracts delegating their governance vote power.\\n */\\ninterface IGovernanceVotePower {\\n    /**\\n     * Delegates all governance vote power of `msg.sender` to address `_to`.\\n     * @param _to The address of the recipient.\\n     */\\n    function delegate(address _to) external;\\n\\n    /**\\n     * Undelegates all governance vote power of `msg.sender`.\\n     */\\n    function undelegate() external;\\n\\n    /**\\n     * Gets the governance vote power of an address at a given block number, including\\n     * all delegations made to it.\\n     * @param _who The address being queried.\\n     * @param _blockNumber The block number at which to fetch the vote power.\\n     * @return Governance vote power of `_who` at `_blockNumber`.\\n     */\\n    function votePowerOfAt(\\n        address _who,\\n        uint256 _blockNumber\\n    ) external view returns (uint256);\\n\\n    /**\\n     * Gets the governance vote power of an address at the latest block, including\\n     * all delegations made to it.\\n     * @param _who The address being queried.\\n     * @return Governance vote power of `account` at the lastest block.\\n     */\\n    function getVotes(address _who) external view returns (uint256);\\n\\n    /**\\n     * Gets the address an account is delegating its governance vote power to, at a given block number.\\n     * @param _who The address being queried.\\n     * @param _blockNumber The block number at which to fetch the address.\\n     * @return Address where `_who` was delegating its governance vote power at block `_blockNumber`.\\n     */\\n    function getDelegateOfAt(\\n        address _who,\\n        uint256 _blockNumber\\n    ) external view returns (address);\\n\\n    /**\\n     * Gets the address an account is delegating its governance vote power to, at the latest block number.\\n     * @param _who The address being queried.\\n     * @return Address where `_who` is currently delegating its governance vote power.\\n     */\\n    function getDelegateOfAtNow(address _who) external view returns (address);\\n}\\n\",\"keccak256\":\"0x8f0c98f4c4cb4ef14f79148229a5493c512a8b6f876f1297364330970cc3bf66\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IIncreaseManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * Increase manager interface.\\n */\\ninterface IIncreaseManager {\\n    function getIncentiveDuration() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xd483962efcae8fcada9b8c8112c497939ac4289c441280e5a3f468056b2c4e0f\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IJsonApi.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * @custom:name IJsonApi\\n * @custom:supported WEB2\\n * @author Flare\\n * @notice An attestation request that fetches data from the given url and then edits the information with a\\n * jq transformation.\\n * @custom:verification  Data is fetched from an url `url`. The received data is then processed with jq as\\n * the `postprocessJq` states. The structure of the final json is written in the `abi_signature`.\\n *\\n * The response contains an abi encoding of the final data.\\n * @custom:lut `0xffffffffffffffff`\\n * @custom:lut-limit `0xffffffffffffffff`\\n */\\ninterface IJsonApi {\\n    /**\\n     * @notice Toplevel request\\n     * @param attestationType ID of the attestation type.\\n     * @param sourceId ID of the data source.\\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.\\n     * @param requestBody Data defining the request. Type (struct) and interpretation is determined\\n     * by the `attestationType`.\\n     */\\n    struct Request {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        bytes32 messageIntegrityCode;\\n        RequestBody requestBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel response\\n     * @param attestationType Extracted from the request.\\n     * @param sourceId Extracted from the request.\\n     * @param votingRound The ID of the State Connector round in which the request was considered.\\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\\n     * @param requestBody Extracted from the request.\\n     * @param responseBody Data defining the response. The verification rules for the construction\\n     * of the response body and the type are defined per specific `attestationType`.\\n     */\\n    struct Response {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        uint64 votingRound;\\n        uint64 lowestUsedTimestamp;\\n        RequestBody requestBody;\\n        ResponseBody responseBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel proof\\n     * @param merkleProof Merkle proof corresponding to the attestation response.\\n     * @param data Attestation response.\\n     */\\n    struct Proof {\\n        bytes32[] merkleProof;\\n        Response data;\\n    }\\n\\n    /**\\n     * @notice Request body for Payment attestation type\\n     * @param url URL of the data source\\n     * @param postprocessJq jq filter to postprocess the data\\n     * @param abi_signature ABI signature of the data\\n     */\\n    struct RequestBody {\\n        string url;\\n        string postprocessJq;\\n        string abi_signature;\\n    }\\n\\n    /**\\n     * @notice Response body for Payment attestation type\\n     * @param abi_encoded_data ABI encoded data\\n     */\\n    struct ResponseBody {\\n        bytes abi_encoded_data;\\n    }\\n}\\n\",\"keccak256\":\"0xd9d1b4883b23509d9a59860cc47e90f2b44627119c6b2717a339e8a83e2fbcee\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IJsonApiVerification.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IJsonApi.sol\\\";\\n\\ninterface IJsonApiVerification {\\n    function verifyJsonApi(\\n        IJsonApi.Proof calldata _proof\\n    ) external view returns (bool _proved);\\n}\\n\",\"keccak256\":\"0x6bf80ddd1f46fca5bd10aedbd0ccf67b6ba937bafef2ddcad00e3fa4101f4a0e\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IPChainStakeMirror.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\npragma abicoder v2;\\n\\nimport \\\"./IPChainVotePower.sol\\\";\\nimport \\\"./IPChainStakeMirrorVerifier.sol\\\";\\n\\n/**\\n * Interface for the `PChainStakeMirror` contract.\\n */\\ninterface IPChainStakeMirror is IPChainVotePower {\\n    /**\\n     * Event emitted when max updates per block is set.\\n     * @param maxUpdatesPerBlock new number of max updated per block\\n     */\\n    event MaxUpdatesPerBlockSet(uint256 maxUpdatesPerBlock);\\n\\n    /**\\n     * Event emitted when the stake is confirmed.\\n     * @param owner The address who opened the stake.\\n     * @param nodeId Node id to which the stake was added.\\n     * @param txHash Unique tx hash - keccak256(abi.encode(PChainStake.txId, PChainStake.inputAddress));\\n     * @param amountWei Stake amount (in wei).\\n     * @param pChainTxId P-chain transaction id.\\n     */\\n    event StakeConfirmed(\\n        address indexed owner,\\n        bytes20 indexed nodeId,\\n        bytes32 indexed txHash,\\n        uint256 amountWei,\\n        bytes32 pChainTxId\\n    );\\n\\n    /**\\n     * Event emitted when the stake has ended.\\n     * @param owner The address whose stake has ended.\\n     * @param nodeId Node id from which the stake was removed.\\n     * @param txHash Unique tx hash - keccak256(abi.encode(PChainStake.txId, PChainStake.inputAddress));\\n     * @param amountWei Stake amount (in wei).\\n     */\\n    event StakeEnded(\\n        address indexed owner,\\n        bytes20 indexed nodeId,\\n        bytes32 indexed txHash,\\n        uint256 amountWei\\n    );\\n\\n    /**\\n     * Event emitted when the stake was revoked.\\n     * @param owner The address whose stake has ended.\\n     * @param nodeId Node id from which the stake was removed.\\n     * @param txHash Unique tx hash - keccak256(abi.encode(PChainStake.txId, PChainStake.inputAddress));\\n     * @param amountWei Stake amount (in wei).\\n     */\\n    event StakeRevoked(\\n        address indexed owner,\\n        bytes20 indexed nodeId,\\n        bytes32 indexed txHash,\\n        uint256 amountWei\\n    );\\n\\n    /**\\n     * Method for P-chain stake mirroring using `PChainStake` data and Merkle proof.\\n     * @param _stakeData Information about P-chain stake.\\n     * @param _merkleProof Merkle proof that should be used to prove the P-chain stake.\\n     */\\n    function mirrorStake(\\n        IPChainStakeMirrorVerifier.PChainStake calldata _stakeData,\\n        bytes32[] calldata _merkleProof\\n    ) external;\\n\\n    /**\\n     * Method for checking if active stake (stake start time <= block.timestamp < stake end time) was already mirrored.\\n     * @param _txId P-chain stake transaction id.\\n     * @param _inputAddress P-chain address that opened stake.\\n     * @return True if stake is active and mirrored.\\n     */\\n    function isActiveStakeMirrored(\\n        bytes32 _txId,\\n        bytes20 _inputAddress\\n    ) external view returns (bool);\\n\\n    /**\\n     * Total amount of tokens at current block.\\n     * @return The current total amount of tokens.\\n     **/\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * Total amount of tokens at a specific `_blockNumber`.\\n     * @param _blockNumber The block number when the totalSupply is queried.\\n     * @return The total amount of tokens at `_blockNumber`.\\n     **/\\n    function totalSupplyAt(uint _blockNumber) external view returns (uint256);\\n\\n    /**\\n     * Queries the token balance of `_owner` at current block.\\n     * @param _owner The address from which the balance will be retrieved.\\n     * @return The current balance.\\n     **/\\n    function balanceOf(address _owner) external view returns (uint256);\\n\\n    /**\\n     * Queries the token balance of `_owner` at a specific `_blockNumber`.\\n     * @param _owner The address from which the balance will be retrieved.\\n     * @param _blockNumber The block number when the balance is queried.\\n     * @return The balance at `_blockNumber`.\\n     **/\\n    function balanceOfAt(\\n        address _owner,\\n        uint _blockNumber\\n    ) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xce00d329315902acec392284f42f69afc37cec632535629927f264fc87d8b907\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IPChainStakeMirrorVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\npragma abicoder v2;\\n\\n/**\\n * Interface with structure for P-chain stake mirror verifications.\\n */\\ninterface IPChainStakeMirrorVerifier {\\n    /**\\n     * Structure describing the P-chain stake.\\n     */\\n    struct PChainStake {\\n        // Hash of the transaction on the underlying chain.\\n        bytes32 txId;\\n        // Type of the staking/delegation transaction: '0' for 'ADD_VALIDATOR_TX' and '1' for 'ADD_DELEGATOR_TX'.\\n        uint8 stakingType;\\n        // Input address that triggered the staking or delegation transaction.\\n        // See https://support.avax.network/en/articles/4596397-what-is-an-address for address definition for P-chain.\\n        bytes20 inputAddress;\\n        // NodeID to which staking or delegation is done.\\n        // For definitions, see https://github.com/ava-labs/avalanchego/blob/master/ids/node_id.go.\\n        bytes20 nodeId;\\n        // Start time of the staking/delegation in seconds (Unix epoch).\\n        uint64 startTime;\\n        // End time of the staking/delegation in seconds (Unix epoch).\\n        uint64 endTime;\\n        // Staked or delegated amount in Gwei (nano FLR).\\n        uint64 weight;\\n    }\\n}\\n\",\"keccak256\":\"0x90a64cd92e144dc65416517cc0bc55e780a5c796838c450783f9777dc03fb797\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IPChainVotePower.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * Interface for the vote power part of the `PChainStakeMirror` contract.\\n */\\ninterface IPChainVotePower {\\n    /**\\n     * Event triggered when a stake is confirmed or at the time it ends.\\n     * Definition: `votePowerFromTo(owner, nodeId)` is `changed` from `priorVotePower` to `newVotePower`.\\n     * @param owner The account that has changed the amount of vote power it is staking.\\n     * @param nodeId The node id whose received vote power has changed.\\n     * @param priorVotePower The vote power originally on that node id.\\n     * @param newVotePower The new vote power that triggered this event.\\n     */\\n    event VotePowerChanged(\\n        address indexed owner,\\n        bytes20 indexed nodeId,\\n        uint256 priorVotePower,\\n        uint256 newVotePower\\n    );\\n\\n    /**\\n     * Emitted when a vote power cache entry is created.\\n     * Allows history cleaners to track vote power cache cleanup opportunities off-chain.\\n     * @param nodeId The node id whose vote power has just been cached.\\n     * @param blockNumber The block number at which the vote power has been cached.\\n     */\\n    event VotePowerCacheCreated(bytes20 nodeId, uint256 blockNumber);\\n\\n    /**\\n     * Get the vote power of `_owner` at block `_blockNumber` using cache.\\n     *   It tries to read the cached value and if not found, reads the actual value and stores it in cache.\\n     *   Can only be used if _blockNumber is in the past, otherwise reverts.\\n     * @param _owner The node id to get voting power.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return Vote power of `_owner` at `_blockNumber`.\\n     */\\n    function votePowerOfAtCached(\\n        bytes20 _owner,\\n        uint256 _blockNumber\\n    ) external returns (uint256);\\n\\n    /**\\n     * Get the total vote power at block `_blockNumber` using cache.\\n     *   It tries to read the cached value and if not found, reads the actual value and stores it in cache.\\n     *   Can only be used if `_blockNumber` is in the past, otherwise reverts.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return The total vote power at the block (sum of all accounts' vote powers).\\n     */\\n    function totalVotePowerAtCached(\\n        uint256 _blockNumber\\n    ) external returns (uint256);\\n\\n    /**\\n     * Get the current total vote power.\\n     * @return The current total vote power (sum of all accounts' vote powers).\\n     */\\n    function totalVotePower() external view returns (uint256);\\n\\n    /**\\n     * Get the total vote power at block `_blockNumber`\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return The total vote power at the block  (sum of all accounts' vote powers).\\n     */\\n    function totalVotePowerAt(\\n        uint _blockNumber\\n    ) external view returns (uint256);\\n\\n    /**\\n     * Get the amounts and node ids being staked to by a vote power owner.\\n     * @param _owner The address being queried.\\n     * @return _nodeIds Array of node ids.\\n     * @return _amounts Array of staked amounts, for each node id.\\n     */\\n    function stakesOf(\\n        address _owner\\n    )\\n        external\\n        view\\n        returns (bytes20[] memory _nodeIds, uint256[] memory _amounts);\\n\\n    /**\\n     * Get the amounts and node ids being staked to by a vote power owner,\\n     * at a given block.\\n     * @param _owner The address being queried.\\n     * @param _blockNumber The block number being queried.\\n     * @return _nodeIds Array of node ids.\\n     * @return _amounts Array of staked amounts, for each node id.\\n     */\\n    function stakesOfAt(\\n        address _owner,\\n        uint256 _blockNumber\\n    )\\n        external\\n        view\\n        returns (bytes20[] memory _nodeIds, uint256[] memory _amounts);\\n\\n    /**\\n     * Get the current vote power of `_nodeId`.\\n     * @param _nodeId The node id to get voting power.\\n     * @return Current vote power of `_nodeId`.\\n     */\\n    function votePowerOf(bytes20 _nodeId) external view returns (uint256);\\n\\n    /**\\n     * Get the vote power of `_nodeId` at block `_blockNumber`\\n     * @param _nodeId The node id to get voting power.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return Vote power of `_nodeId` at `_blockNumber`.\\n     */\\n    function votePowerOfAt(\\n        bytes20 _nodeId,\\n        uint256 _blockNumber\\n    ) external view returns (uint256);\\n\\n    /**\\n     * Get current staked vote power from `_owner` staked to `_nodeId`.\\n     * @param _owner Address of vote power owner.\\n     * @param _nodeId Node id.\\n     * @return The staked vote power.\\n     */\\n    function votePowerFromTo(\\n        address _owner,\\n        bytes20 _nodeId\\n    ) external view returns (uint256);\\n\\n    /**\\n     * Get current staked vote power from `_owner` staked to `_nodeId` at `_blockNumber`.\\n     * @param _owner Address of vote power owner.\\n     * @param _nodeId Node id.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return The staked vote power.\\n     */\\n    function votePowerFromToAt(\\n        address _owner,\\n        bytes20 _nodeId,\\n        uint _blockNumber\\n    ) external view returns (uint256);\\n\\n    /**\\n     * Return vote powers for several node ids in a batch.\\n     * @param _nodeIds The list of node ids to fetch vote power of.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return A list of vote powers.\\n     */\\n    function batchVotePowerOfAt(\\n        bytes20[] memory _nodeIds,\\n        uint256 _blockNumber\\n    ) external view returns (uint256[] memory);\\n}\\n\",\"keccak256\":\"0x7d6b4242859af5d5d8821c665a12685be7e850583d1471be49df4b1e238dbc21\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IPayment.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * @custom:name IPayment\\n * @custom:id 0x01\\n * @custom:supported BTC, DOGE, XRP\\n * @author Flare\\n * @notice A relay of a transaction on an external chain that is considered a payment in a native currency.\\n * Various blockchains support different types of native payments. For each blockchain, it is specified how a payment\\n * transaction should be formed to be provable by this attestation type.\\n * The provable payments emulate traditional banking payments from entity A to entity B in native currency with an\\n * optional payment reference.\\n * @custom:verification The transaction with `transactionId` is fetched from the API of the blockchain node or\\n * relevant indexer.\\n * If the transaction cannot be fetched or the transaction is in a block that does not have a sufficient\\n * [number of confirmations](/specs/attestations/configs.md#finalityconfirmation), the attestation request is rejected.\\n *\\n * Once the transaction is received, the payment summary is computed according to the rules for the source chain.\\n * If the summary is successfully calculated, the response is assembled from the summary.\\n * `blockNumber` and `blockTimestamp` are retrieved from the block if they are not included in the transaction data.\\n * For Bitcoin and Dogecoin, `blockTimestamp` is mediantime of the block.\\n * For XRPL, `blockTimestamp` is close time of the ledger converted to UNIX time.\\n *\\n * If the summary is not successfully calculated, the attestation request is rejected.\\n * @custom:lut `blockTimestamp`\\n * @custom:lutlimit `0x127500`, `0x127500`, `0x127500`\\n */\\ninterface IPayment {\\n    /**\\n     * @notice Toplevel request\\n     * @param attestationType ID of the attestation type.\\n     * @param sourceId ID of the data source.\\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.\\n     * @param requestBody Data defining the request. Type (struct) and interpretation is determined\\n     * by the `attestationType`.\\n     */\\n    struct Request {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        bytes32 messageIntegrityCode;\\n        RequestBody requestBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel response\\n     * @param attestationType Extracted from the request.\\n     * @param sourceId Extracted from the request.\\n     * @param votingRound The ID of the State Connector round in which the request was considered.\\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\\n     * @param requestBody Extracted from the request.\\n     * @param responseBody Data defining the response. The verification rules for the construction\\n     * of the response body and the type are defined per specific `attestationType`.\\n     */\\n    struct Response {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        uint64 votingRound;\\n        uint64 lowestUsedTimestamp;\\n        RequestBody requestBody;\\n        ResponseBody responseBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel proof\\n     * @param merkleProof Merkle proof corresponding to the attestation response.\\n     * @param data Attestation response.\\n     */\\n    struct Proof {\\n        bytes32[] merkleProof;\\n        Response data;\\n    }\\n\\n    /**\\n     * @notice Request body for Payment attestation type\\n     * @param transactionId ID of the payment transaction.\\n     * @param inUtxo For UTXO chains, this is the index of the transaction input with source address.\\n     * Always 0 for the non-utxo chains.\\n     * @param utxo For UTXO chains, this is the index of the transaction output with receiving address.\\n     * Always 0 for the non-utxo chains.\\n     */\\n    struct RequestBody {\\n        bytes32 transactionId;\\n        uint256 inUtxo;\\n        uint256 utxo;\\n    }\\n\\n    /**\\n     * @notice Response body for Payment attestation type\\n     * @param blockNumber Number of the block in which the transaction is included.\\n     * @param blockTimestamp The timestamp of the block in which the transaction is included.\\n     * @param sourceAddressHash Standard address hash of the source address.\\n     * @param sourceAddressesRoot The root of the Merkle tree of the source addresses.\\n     * @param receivingAddressHash Standard address hash of the receiving address.\\n     * The zero 32-byte string if there is no receivingAddress (if `status` is not success).\\n     * @param intendedReceivingAddressHash Standard address hash of the intended receiving address.\\n     * Relevant if the transaction is unsuccessful.\\n     * @param spentAmount Amount in minimal units spent by the source address.\\n     * @param intendedSpentAmount Amount in minimal units to be spent by the source address.\\n     * Relevant if the transaction status is unsuccessful.\\n     * @param receivedAmount Amount in minimal units received by the receiving address.\\n     * @param intendedReceivedAmount Amount in minimal units intended to be received by the receiving address.\\n     * Relevant if the transaction is unsuccessful.\\n     * @param standardPaymentReference Standard payment reference of the transaction.\\n     * @param oneToOne Indicator whether only one source and one receiver are involved in the transaction.\\n     * @param status Succes status of the transaction: 0 - success, 1 - failed by sender's fault,\\n     * 2 - failed by receiver's fault.\\n     */\\n    struct ResponseBody {\\n        uint64 blockNumber;\\n        uint64 blockTimestamp;\\n        bytes32 sourceAddressHash;\\n        bytes32 sourceAddressesRoot;\\n        bytes32 receivingAddressHash;\\n        bytes32 intendedReceivingAddressHash;\\n        int256 spentAmount;\\n        int256 intendedSpentAmount;\\n        int256 receivedAmount;\\n        int256 intendedReceivedAmount;\\n        bytes32 standardPaymentReference;\\n        bool oneToOne;\\n        uint8 status;\\n    }\\n}\\n\",\"keccak256\":\"0x9f24ac36dce88e3c80307b47d7de628941e9877ddc2a935676532fadcb470104\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IPaymentVerification.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IPayment.sol\\\";\\n\\ninterface IPaymentVerification {\\n    function verifyPayment(\\n        IPayment.Proof calldata _proof\\n    ) external view returns (bool _proved);\\n}\\n\",\"keccak256\":\"0xd424ff62a51a573fd3dfed55564572a9a26ee712bd1c26cd293498b77379f1d7\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IPriceSubmitter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./genesis/interfaces/IFtsoGenesis.sol\\\";\\nimport \\\"./genesis/interfaces/IFtsoRegistryGenesis.sol\\\";\\nimport \\\"./genesis/interfaces/IFtsoManagerGenesis.sol\\\";\\n\\ninterface IPriceSubmitter {\\n    /**\\n     * Event emitted when hash was submitted through PriceSubmitter.\\n     * @param submitter the address of the sender\\n     * @param epochId current price epoch id\\n     * @param hash the submitted hash\\n     * @param timestamp current block timestamp\\n     */\\n    event HashSubmitted(\\n        address indexed submitter,\\n        uint256 indexed epochId,\\n        bytes32 hash,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * Event emitted when prices were revealed through PriceSubmitter.\\n     * @param voter the address of the sender\\n     * @param epochId id of the epoch in which the price hash was submitted\\n     * @param ftsos array of ftsos that correspond to the indexes in the call\\n     * @param prices the submitted prices\\n     * @param timestamp current block timestamp\\n     */\\n    event PricesRevealed(\\n        address indexed voter,\\n        uint256 indexed epochId,\\n        IFtsoGenesis[] ftsos,\\n        uint256[] prices,\\n        uint256 random,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @notice Submits hash for current epoch\\n     * @param _epochId              Target epoch id to which hash is submitted\\n     * @param _hash                 Hash of ftso indices, prices, random number and voter address\\n     * @notice Emits HashSubmitted event\\n     */\\n    function submitHash(uint256 _epochId, bytes32 _hash) external;\\n\\n    /**\\n     * @notice Reveals submitted prices during epoch reveal period\\n     * @param _epochId              Id of the epoch in which the price hashes was submitted\\n     * @param _ftsoIndices          List of increasing ftso indices\\n     * @param _prices               List of submitted prices in USD\\n     * @param _random               Submitted random number\\n     * @notice The hash of ftso indices, prices, random number and voter address must be equal to the submitted hash\\n     * @notice Emits PricesRevealed event\\n     */\\n    function revealPrices(\\n        uint256 _epochId,\\n        uint256[] memory _ftsoIndices,\\n        uint256[] memory _prices,\\n        uint256 _random\\n    ) external;\\n\\n    /**\\n     * Returns bitmap of all ftso's for which `_voter` is allowed to submit prices/hashes.\\n     * If voter is allowed to vote for ftso at index (see *_FTSO_INDEX), the corrsponding\\n     * bit in the result will be 1.\\n     */\\n    function voterWhitelistBitmap(\\n        address _voter\\n    ) external view returns (uint256);\\n\\n    function getVoterWhitelister() external view returns (address);\\n    function getFtsoRegistry() external view returns (IFtsoRegistryGenesis);\\n    function getFtsoManager() external view returns (IFtsoManagerGenesis);\\n\\n    /**\\n     * @notice Returns current random number\\n     */\\n    function getCurrentRandom() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns random number of the specified epoch\\n     * @param _epochId              Id of the epoch\\n     */\\n    function getRandom(uint256 _epochId) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x5fafb49e6830006f4182cea22d562a0bafe1ec9ecd4d6689b4a1a5687040a545\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IRandomProvider.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * Random provider interface.\\n */\\ninterface IRandomProvider {\\n    /**\\n     * Returns current random number. Method reverts if random number was not generated securely.\\n     * @return _randomNumber Current random number.\\n     */\\n    function getCurrentRandom() external view returns (uint256 _randomNumber);\\n\\n    /**\\n     * Returns current random number and a flag indicating if it was securely generated.\\n     * It is up to the caller to decide whether to use the returned random number or not.\\n     * @return _randomNumber Current random number.\\n     * @return _isSecureRandom Indicates if current random number is secure.\\n     */\\n    function getCurrentRandomWithQuality()\\n        external\\n        view\\n        returns (uint256 _randomNumber, bool _isSecureRandom);\\n\\n    /**\\n     * Returns current random number, a flag indicating if it was securely generated and its timestamp.\\n     * It is up to the caller to decide whether to use the returned random number or not.\\n     * @return _randomNumber Current random number.\\n     * @return _isSecureRandom Indicates if current random number is secure.\\n     * @return _randomTimestamp Random timestamp.\\n     */\\n    function getCurrentRandomWithQualityAndTimestamp()\\n        external\\n        view\\n        returns (\\n            uint256 _randomNumber,\\n            bool _isSecureRandom,\\n            uint256 _randomTimestamp\\n        );\\n}\\n\",\"keccak256\":\"0x6f7bfeb8f23d02e852c84bfa28208093fa32e2ae2e633d23a2b028c5ec94cdcd\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IRedemptionTimeExtension.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\ninterface IRedemptionTimeExtension {\\n    function setRedemptionPaymentExtensionSeconds(uint256 _value) external;\\n\\n    function redemptionPaymentExtensionSeconds()\\n        external\\n        view\\n        returns (uint256);\\n}\\n\",\"keccak256\":\"0x245964b8d85c2fb8637825dd513c75d07cc32961794ddfa7445451d3923ab463\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IReferencedPaymentNonexistence.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * @custom:name IReferencedPaymentNonexistence\\n * @custom:id 0x04\\n * @custom:supported BTC, DOGE, XRP\\n * @author Flare\\n * @notice Assertion that an agreed-upon payment has not been made by a certain deadline.\\n * A confirmed request shows that a transaction meeting certain criteria (address, amount, reference)\\n * did not appear in the specified block range.\\n *\\n *\\n * This type of attestation can be used to e.g. provide grounds to liquidate funds locked by a smart\\n * contract on Flare when a payment is missed.\\n *\\n * @custom:verification If `firstOverflowBlock` cannot be determined or does not have a sufficient\\n * number of confirmations, the attestation request is rejected.\\n * If `firstOverflowBlockNumber` is higher or equal to `minimalBlockNumber`, the request is rejected.\\n * The search range are blocks between heights including `minimalBlockNumber` and excluding `firstOverflowBlockNumber`.\\n * If the verifier does not have a view of all blocks from `minimalBlockNumber` to `firstOverflowBlockNumber`,\\n * the attestation request is rejected.\\n *\\n * The request is confirmed if no transaction meeting the specified criteria is found in the search range.\\n * The criteria and timestamp are chain specific.\\n * ### UTXO (Bitcoin and Dogecoin)\\n *\\n *\\n * Criteria for the transaction:\\n *\\n *\\n * - It is not coinbase transaction.\\n * - The transaction has the specified standardPaymentReference.\\n * - The sum of values of all outputs with the specified address minus the sum of values of all inputs with\\n * the specified address is greater than `amount` (in practice the sum of all values of the inputs with the\\n * specified address is zero).\\n *\\n *\\n * Timestamp is `mediantime`.\\n * ### XRPL\\n *\\n *\\n *\\n * Criteria for the transaction:\\n * - The transaction is of type payment.\\n * - The transaction has the specified standardPaymentReference,\\n * - One of the following is true:\\n *   - Transaction status is `SUCCESS` and the amount received by the specified destination address is\\n * greater than the specified `value`.\\n *   - Transaction status is `RECEIVER_FAILURE` and the specified destination address would receive an\\n * amount greater than the specified `value` had the transaction been successful.\\n *\\n *\\n * Timestamp is `close_time` converted to UNIX time.\\n *\\n * @custom:lut `minimalBlockTimestamp`\\n * @custom:lutlimit `0x127500`, `0x127500`, `0x127500`\\n */\\ninterface IReferencedPaymentNonexistence {\\n    /**\\n     * @notice Toplevel request\\n     * @param attestationType ID of the attestation type.\\n     * @param sourceId ID of the data source.\\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response as defined.\\n     * @param requestBody Data defining the request. Type and interpretation is determined by the `attestationType`.\\n     */\\n    struct Request {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        bytes32 messageIntegrityCode;\\n        RequestBody requestBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel response\\n     * @param attestationType Extracted from the request.\\n     * @param sourceId Extracted from the request.\\n     * @param votingRound The ID of the State Connector round in which the request was considered.\\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\\n     * @param requestBody Extracted from the request.\\n     * @param responseBody Data defining the response. The verification rules for the construction of the response\\n     * body and the type are defined per specific `attestationType`.\\n     */\\n    struct Response {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        uint64 votingRound;\\n        uint64 lowestUsedTimestamp;\\n        RequestBody requestBody;\\n        ResponseBody responseBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel proof\\n     * @param merkleProof Merkle proof corresponding to the attestation response.\\n     * @param data Attestation response.\\n     */\\n    struct Proof {\\n        bytes32[] merkleProof;\\n        Response data;\\n    }\\n\\n    /**\\n     * @notice Request body for ReferencePaymentNonexistence attestation type\\n     * @param minimalBlockNumber The start block of the search range.\\n     * @param deadlineBlockNumber The blockNumber to be included in the search range.\\n     * @param deadlineTimestamp The timestamp to be included in the search range.\\n     * @param destinationAddressHash The standard address hash of the address to which the payment had to be done.\\n     * @param amount The requested amount in minimal units that had to be payed.\\n     * @param standardPaymentReference The requested standard payment reference.\\n     * @param checkSourceAddresses If true, the source address root is checked (only full match).\\n     * @param sourceAddressesRoot The root of the Merkle tree of the source addresses.\\n     * @custom:below The `standardPaymentReference` should not be zero (as a 32-byte sequence).\\n     */\\n    struct RequestBody {\\n        uint64 minimalBlockNumber;\\n        uint64 deadlineBlockNumber;\\n        uint64 deadlineTimestamp;\\n        bytes32 destinationAddressHash;\\n        uint256 amount;\\n        bytes32 standardPaymentReference;\\n        bool checkSourceAddresses;\\n        bytes32 sourceAddressesRoot;\\n    }\\n\\n    /**\\n     * @notice Response body for ReferencePaymentNonexistence attestation type.\\n     * @param minimalBlockTimestamp The timestamp of the minimalBlock.\\n     * @param firstOverflowBlockNumber The height of the firstOverflowBlock.\\n     * @param firstOverflowBlockTimestamp The timestamp of the firstOverflowBlock.\\n     * @custom:below `firstOverflowBlock` is the first block that has block number higher than\\n     * `deadlineBlockNumber` and timestamp later than `deadlineTimestamp`.\\n     * The specified search range are blocks between heights including `minimalBlockNumber`\\n     * and excluding `firstOverflowBlockNumber`.\\n     */\\n    struct ResponseBody {\\n        uint64 minimalBlockTimestamp;\\n        uint64 firstOverflowBlockNumber;\\n        uint64 firstOverflowBlockTimestamp;\\n    }\\n}\\n\",\"keccak256\":\"0x9ae917e75a27796c4ce2034ad24ddf916d396a003e5bb96aeec50c5b259dcd91\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IReferencedPaymentNonexistenceVerification.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IReferencedPaymentNonexistence.sol\\\";\\n\\ninterface IReferencedPaymentNonexistenceVerification {\\n    function verifyReferencedPaymentNonexistence(\\n        IReferencedPaymentNonexistence.Proof calldata _proof\\n    ) external view returns (bool _proved);\\n}\\n\",\"keccak256\":\"0x75b7345c131b232b8980ce4e50f76153a800a82fdae38a0fa69d44a17f3acd28\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IRelay.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./RandomNumberV2Interface.sol\\\";\\n\\n/**\\n * Relay interface.\\n */\\ninterface IRelay is RandomNumberV2Interface {\\n    struct FeeConfig {\\n        uint8 protocolId; // Protocol id for which the fee is set\\n        uint256 feeInWei; // Fee in wei\\n    }\\n\\n    struct RelayInitialConfig {\\n        uint32 initialRewardEpochId; // The initial reward epoch id.\\n        uint32 startingVotingRoundIdForInitialRewardEpochId; // The starting voting round id for the initial\\n        // reward epoch.\\n        bytes32 initialSigningPolicyHash; // The initial signing policy hash.\\n        uint8 randomNumberProtocolId; // The protocol id of the random number protocol.\\n        uint32 firstVotingRoundStartTs; // The timestamp of the first voting round start.\\n        uint8 votingEpochDurationSeconds; // The duration of a voting epoch in seconds.\\n        uint32 firstRewardEpochStartVotingRoundId; // The start voting round id of the first reward epoch.\\n        uint16 rewardEpochDurationInVotingEpochs; // The duration of a reward epoch in voting epochs.\\n        uint16 thresholdIncreaseBIPS; // The threshold increase in BIPS for signing with\\n        // old signing policy.\\n        uint32 messageFinalizationWindowInRewardEpochs; // The window of reward epochs for finalizing\\n        // the protocol messages.\\n        address payable feeCollectionAddress; // Fee collection address\\n        FeeConfig[] feeConfigs; // Fee configurations\\n    }\\n\\n    struct RelayGovernanceConfig {\\n        bytes32 descriptionHash; // Description hash (should be keccak256(\\\"RelayGovernance\\\")\\n        uint256 chainId; // Chain id on which is the relay is deployed\\n        FeeConfig[] newFeeConfigs; // Fee configurations\\n    }\\n\\n    // Event is emitted when a new signing policy is initialized by the signing policy setter.\\n    event SigningPolicyInitialized(\\n        uint24 indexed rewardEpochId, // Reward epoch id\\n        uint32 startVotingRoundId, // First voting round id of validity.\\n        // Usually it is the first voting round of reward epoch rewardEpochId.\\n        // It can be later,\\n        // if the confirmation of the signing policy on Flare blockchain gets delayed.\\n        uint16 threshold, // Confirmation threshold (absolute value of noramalised weights).\\n        uint256 seed, // Random seed.\\n        address[] voters, // The list of eligible voters in the canonical order.\\n        uint16[] weights, // The corresponding list of normalised signing weights of eligible voters.\\n        // Normalisation is done by compressing the weights from 32-byte values to\\n        // 2 bytes, while approximately keeping the weight relations.\\n        bytes signingPolicyBytes, // The full signing policy byte encoded.\\n        uint64 timestamp // Timestamp when this happened\\n    );\\n\\n    // Event is emitted when a signing policy is relayed.\\n    // It contains minimalistic data in order to save gas. Data about the signing policy are\\n    // extractable from the calldata, assuming prefered usage of direct top-level call to relay().\\n    event SigningPolicyRelayed(\\n        uint256 indexed rewardEpochId // Reward epoch id\\n    );\\n\\n    // Event is emitted when a protocol message is relayed.\\n    event ProtocolMessageRelayed(\\n        uint8 indexed protocolId, // Protocol id\\n        uint32 indexed votingRoundId, // Voting round id\\n        bool isSecureRandom, // Secure random flag\\n        bytes32 merkleRoot // Merkle root of the protocol message\\n    );\\n\\n    /**\\n     * Checks the relay message for sufficient weight of signatures for the _messageHash\\n     * signed for protocol message Merkle root of the form (1, 0, 0, _messageHash).\\n     * If the check is successful, reward epoch id of the signing policy is returned.\\n     * Otherwise the function reverts.\\n     * @param _relayMessage The relay message.\\n     * @param _messageHash The hash of the message.\\n     * @return _rewardEpochId The reward epoch id of the signing policy.\\n     */\\n    function verifyCustomSignature(\\n        bytes calldata _relayMessage,\\n        bytes32 _messageHash\\n    ) external returns (uint256 _rewardEpochId);\\n\\n    /**\\n     * Checks the relay message for sufficient weight of signatures of the hash of the _config data.\\n     * If the check is successful, the relay contract is configured with the new _config data, which\\n     * in particular means that fee configurations are updated.\\n     * Otherwise the function reverts.\\n     * @param _relayMessage The relay message.\\n     * @param _config The new relay configuration.\\n     */\\n    function governanceFeeSetup(\\n        bytes calldata _relayMessage,\\n        RelayGovernanceConfig calldata _config\\n    ) external;\\n\\n    /**\\n     * Finalization function for new signing policies and protocol messages.\\n     * It can be used as finalization contract on Flare chain or as relay contract on other EVM chain.\\n     * Can be called in two modes. It expects calldata that is parsed in a custom manner.\\n     * Hence the transaction calls should assemble relevant calldata in the 'data' field.\\n     * Depending on the data provided, the contract operations in essentially two modes:\\n     * (1) Relaying signing policy. The structure of the calldata is:\\n     *        function signature (4 bytes) + active signing policy\\n     *             + 0 (1 byte) + new signing policy,\\n     *     total of exactly 4423 bytes.\\n     * (2) Relaying signed message. The structure of the calldata is:\\n     *        function signature (4 bytes) + signing policy\\n     *           + signed message (38 bytes) + ECDSA signatures with indices (67 bytes each)\\n     *     This case splits into two subcases:\\n     *     - protocolMessageId = 1: Message id must be of the form (protocolMessageId, 0, 0, merkleRoot).\\n     *       The validity of the signatures of sufficient weight is checked and if\\n     *       successful, the merkleRoot from the message is returned (32 bytes) and the\\n     *       reward epoch id of the signing policy as well (additional 3 bytes)\\n     *     - protocolMessageId > 1: The validity of the signatures of sufficient weight is checked and if\\n     *       it is valid, the merkleRoot is published for protocolId and votingRoundId.\\n     * Reverts if relaying is not successful.\\n     */\\n    function relay() external returns (bytes memory);\\n\\n    /**\\n     * Verifies the leaf (or intermediate node) with the Merkle proof against the Merkle root\\n     * for given protocol id and voting round id.\\n     * A fee may need to be paid. It is protocol specific.\\n     * **NOTE:** Overpayment is not refunded.\\n     * @param _protocolId The protocol id.\\n     * @param _votingRoundId The voting round id.\\n     * @param _leaf The leaf (or intermediate node) to verify.\\n     * @param _proof The Merkle proof.\\n     * @return True if the verification is successful.\\n     */\\n    function verify(\\n        uint256 _protocolId,\\n        uint256 _votingRoundId,\\n        bytes32 _leaf,\\n        bytes32[] calldata _proof\\n    ) external payable returns (bool);\\n\\n    /**\\n     * Returns the signing policy hash for given reward epoch id.\\n     * The function is reverted if signingPolicySetter is set, hence on all\\n     * deployments where the contract is used as a pure relay.\\n     * @param _rewardEpochId The reward epoch id.\\n     * @return _signingPolicyHash The signing policy hash.\\n     */\\n    function toSigningPolicyHash(\\n        uint256 _rewardEpochId\\n    ) external view returns (bytes32 _signingPolicyHash);\\n\\n    /**\\n     * Returns true if there is finalization for a given protocol id and voting round id.\\n     * @param _protocolId The protocol id.\\n     * @param _votingRoundId The voting round id.\\n     */\\n    function isFinalized(\\n        uint256 _protocolId,\\n        uint256 _votingRoundId\\n    ) external view returns (bool);\\n\\n    /**\\n     * Returns the Merkle root for given protocol id and voting round id.\\n     * The function is reverted if signingPolicySetter is set, hence on all\\n     * deployments where the contract is used as a pure relay.\\n     * @param _protocolId The protocol id.\\n     * @param _votingRoundId The voting round id.\\n     * @return _merkleRoot The Merkle root.\\n     */\\n    function merkleRoots(\\n        uint256 _protocolId,\\n        uint256 _votingRoundId\\n    ) external view returns (bytes32 _merkleRoot);\\n\\n    /**\\n     * Returns the start voting round id for given reward epoch id.\\n     * @param _rewardEpochId The reward epoch id.\\n     * @return _startingVotingRoundId The start voting round id.\\n     */\\n    function startingVotingRoundIds(\\n        uint256 _rewardEpochId\\n    ) external view returns (uint256 _startingVotingRoundId);\\n\\n    /**\\n     * Returns the voting round id for given timestamp.\\n     * @param _timestamp The timestamp.\\n     * @return _votingRoundId The voting round id.\\n     */\\n    function getVotingRoundId(\\n        uint256 _timestamp\\n    ) external view returns (uint256 _votingRoundId);\\n\\n    /**\\n     * Returns last initialized reward epoch data.\\n     * @return _lastInitializedRewardEpoch Last initialized reward epoch.\\n     * @return _startingVotingRoundIdForLastInitializedRewardEpoch Starting voting round id for it.\\n     */\\n    function lastInitializedRewardEpochData()\\n        external\\n        view\\n        returns (\\n            uint32 _lastInitializedRewardEpoch,\\n            uint32 _startingVotingRoundIdForLastInitializedRewardEpoch\\n        );\\n\\n    /**\\n     * Returns fee collection address.\\n     */\\n    function feeCollectionAddress() external view returns (address payable);\\n\\n    /**\\n     * Returns fee in wei for one verification of a given protocol id.\\n     * @param _protocolId The protocol id.\\n     */\\n    function protocolFeeInWei(\\n        uint256 _protocolId\\n    ) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x62e1dd8af4729f7b4ae5d8035b5ad0b882d2b69aa31bad1cc21209232b87bfb8\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IRewardManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./RewardsV2Interface.sol\\\";\\n\\n/**\\n * RewardManager interface.\\n */\\ninterface IRewardManager is RewardsV2Interface {\\n    /// Struct used for storing unclaimed reward data.\\n    struct UnclaimedRewardState {\\n        bool initialised; // Information if already initialised\\n        // amount and weight might be 0 if all users already claimed\\n        uint120 amount; // Total unclaimed amount.\\n        uint128 weight; // Total unclaimed weight.\\n    }\\n\\n    /**\\n     * Emitted when rewards are claimed.\\n     * @param beneficiary Address of the beneficiary (voter or node id) that accrued the reward.\\n     * @param rewardOwner Address that was eligible for the rewards.\\n     * @param recipient Address that received the reward.\\n     * @param rewardEpochId Id of the reward epoch where the reward was accrued.\\n     * @param claimType Claim type\\n     * @param amount Amount of rewarded native tokens (wei).\\n     */\\n    event RewardClaimed(\\n        address indexed beneficiary,\\n        address indexed rewardOwner,\\n        address indexed recipient,\\n        uint24 rewardEpochId,\\n        ClaimType claimType,\\n        uint120 amount\\n    );\\n\\n    /**\\n     * Unclaimed rewards have expired and are now inaccessible.\\n     *\\n     * `getUnclaimedRewardState()` can be used to retrieve more information.\\n     * @param rewardEpochId Id of the reward epoch that has just expired.\\n     */\\n    event RewardClaimsExpired(uint256 indexed rewardEpochId);\\n\\n    /**\\n     * Emitted when reward claims have been enabled.\\n     * @param rewardEpochId First claimable reward epoch.\\n     */\\n    event RewardClaimsEnabled(uint256 indexed rewardEpochId);\\n\\n    /**\\n     * Claim rewards for `_rewardOwners` and their PDAs.\\n     * Rewards are deposited to the WNAT (to reward owner or PDA if enabled).\\n     * It can be called by reward owner or its authorized executor.\\n     * Only claiming from weight based claims is supported.\\n     * @param _rewardOwners Array of reward owners.\\n     * @param _rewardEpochId Id of the reward epoch up to which the rewards are claimed.\\n     * @param _proofs Array of reward claims with merkle proofs.\\n     */\\n    function autoClaim(\\n        address[] calldata _rewardOwners,\\n        uint24 _rewardEpochId,\\n        RewardClaimWithProof[] calldata _proofs\\n    ) external;\\n\\n    /**\\n     * Initialises weight based claims.\\n     * @param _proofs Array of reward claims with merkle proofs.\\n     */\\n    function initialiseWeightBasedClaims(\\n        RewardClaimWithProof[] calldata _proofs\\n    ) external;\\n\\n    /**\\n     * Returns the reward manager id.\\n     */\\n    function rewardManagerId() external view returns (uint256);\\n\\n    /**\\n     * Returns the number of weight based claims that have been initialised.\\n     * @param _rewardEpochId Reward epoch id.\\n     */\\n    function noOfInitialisedWeightBasedClaims(\\n        uint256 _rewardEpochId\\n    ) external view returns (uint256);\\n\\n    /**\\n     * Get the current cleanup block number.\\n     * @return The currently set cleanup block number.\\n     */\\n    function cleanupBlockNumber() external view returns (uint256);\\n\\n    /**\\n     * Returns the state of rewards for a given address at a specific reward epoch.\\n     * @param _rewardOwner Address of the reward owner.\\n     * @param _rewardEpochId Reward epoch id.\\n     * @return _rewardStates Array of reward states.\\n     */\\n    function getStateOfRewardsAt(\\n        address _rewardOwner,\\n        uint24 _rewardEpochId\\n    ) external view returns (RewardState[] memory _rewardStates);\\n\\n    /**\\n     * Gets the unclaimed reward state for a beneficiary, reward epoch id and claim type.\\n     * @param _beneficiary Address of the beneficiary to query.\\n     * @param _rewardEpochId Id of the reward epoch to query.\\n     * @param _claimType Claim type to query.\\n     * @return _state Unclaimed reward state.\\n     */\\n    function getUnclaimedRewardState(\\n        address _beneficiary,\\n        uint24 _rewardEpochId,\\n        ClaimType _claimType\\n    ) external view returns (UnclaimedRewardState memory _state);\\n\\n    /**\\n     * Returns totals.\\n     * @return _totalRewardsWei Total rewards (wei).\\n     * @return _totalInflationRewardsWei Total inflation rewards (wei).\\n     * @return _totalClaimedWei Total claimed rewards (wei).\\n     * @return _totalBurnedWei Total burned rewards (wei).\\n     */\\n    function getTotals()\\n        external\\n        view\\n        returns (\\n            uint256 _totalRewardsWei,\\n            uint256 _totalInflationRewardsWei,\\n            uint256 _totalClaimedWei,\\n            uint256 _totalBurnedWei\\n        );\\n\\n    /**\\n     * Returns reward epoch totals.\\n     * @param _rewardEpochId Reward epoch id.\\n     * @return _totalRewardsWei Total rewards (inflation + community) for the epoch (wei).\\n     * @return _totalInflationRewardsWei Total inflation rewards for the epoch (wei).\\n     * @return _initialisedRewardsWei Initialised rewards of all claim types for the epoch (wei).\\n     * @return _claimedRewardsWei Claimed rewards for the epoch (wei).\\n     * @return _burnedRewardsWei Burned rewards for the epoch (wei).\\n     */\\n    function getRewardEpochTotals(\\n        uint24 _rewardEpochId\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 _totalRewardsWei,\\n            uint256 _totalInflationRewardsWei,\\n            uint256 _initialisedRewardsWei,\\n            uint256 _claimedRewardsWei,\\n            uint256 _burnedRewardsWei\\n        );\\n\\n    /**\\n     * Returns current reward epoch id.\\n     */\\n    function getCurrentRewardEpochId() external view returns (uint24);\\n\\n    /**\\n     * Returns initial reward epoch id.\\n     */\\n    function getInitialRewardEpochId() external view returns (uint256);\\n\\n    /**\\n     * Returns the reward epoch id that will expire next once a new reward epoch starts.\\n     */\\n    function getRewardEpochIdToExpireNext() external view returns (uint256);\\n\\n    /**\\n     * The first reward epoch id that was claimable.\\n     */\\n    function firstClaimableRewardEpochId() external view returns (uint24);\\n}\\n\",\"keccak256\":\"0x3a68ce6097e3ba4562e8eba4fd70936d222c37548f13dfca53cd5e30e8c3c003\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/ISortition.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport {G1Point} from \\\"./IBn256.sol\\\";\\n\\nstruct SortitionCredential {\\n    uint256 replicate;\\n    G1Point gamma;\\n    uint256 c;\\n    uint256 s;\\n}\\n\",\"keccak256\":\"0x08a03686bef3616da74372bf214f46fcf6d46618376e5bb86237b070cd11c257\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/ISubmission.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IRandomProvider.sol\\\";\\n\\n/**\\n * Submission interface.\\n */\\ninterface ISubmission is IRandomProvider {\\n    /// Event emitted when a new voting round is initiated.\\n    event NewVotingRoundInitiated();\\n\\n    /**\\n     * Submit1 method. Used in multiple protocols (i.e. as FTSO commit method).\\n     */\\n    function submit1() external returns (bool);\\n\\n    /**\\n     * Submit2 method. Used in multiple protocols (i.e. as FTSO reveal method).\\n     */\\n    function submit2() external returns (bool);\\n\\n    /**\\n     * Submit3 method. Future usage.\\n     */\\n    function submit3() external returns (bool);\\n\\n    /**\\n     * SubmitSignatures method. Used in multiple protocols (i.e. as FTSO submit signature method).\\n     */\\n    function submitSignatures() external returns (bool);\\n\\n    /**\\n     * SubmitAndPass method. Future usage.\\n     * @param _data The data to pass to the submitAndPassContract.\\n     */\\n    function submitAndPass(bytes calldata _data) external returns (bool);\\n}\\n\",\"keccak256\":\"0x6824b5be36c0755325fd605c57c0adfd71cf6236271b64c9736b86832081013c\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IVPContractEvents.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\ninterface IVPContractEvents {\\n    /**\\n     * Event triggered when an account delegates or undelegates another account.\\n     * Definition: `votePowerFromTo(from, to)` is `changed` from `priorVotePower` to `newVotePower`.\\n     * For undelegation, `newVotePower` is 0.\\n     *\\n     * Note: the event is always emitted from VPToken's `writeVotePowerContract`.\\n     */\\n    event Delegate(\\n        address indexed from,\\n        address indexed to,\\n        uint256 priorVotePower,\\n        uint256 newVotePower\\n    );\\n\\n    /**\\n     * Event triggered only when account `delegator` revokes delegation to `delegatee`\\n     * for a single block in the past (typically the current vote block).\\n     *\\n     * Note: the event is always emitted from VPToken's `writeVotePowerContract` and/or `readVotePowerContract`.\\n     */\\n    event Revoke(\\n        address indexed delegator,\\n        address indexed delegatee,\\n        uint256 votePower,\\n        uint256 blockNumber\\n    );\\n}\\n\",\"keccak256\":\"0x91245b693c0283e5c9220a0840f0fb5f1ba934ca12c2df39f1c85bf14644dd13\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IVPToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IGovernanceVotePower} from \\\"./IGovernanceVotePower.sol\\\";\\nimport {IVPContractEvents} from \\\"./IVPContractEvents.sol\\\";\\n\\ninterface IVPToken is IERC20 {\\n    /**\\n     * @notice Delegate by percentage `_bips` of voting power to `_to` from `msg.sender`.\\n     * @param _to The address of the recipient\\n     * @param _bips The percentage of voting power to be delegated expressed in basis points (1/100 of one percent).\\n     *   Not cumulative - every call resets the delegation value (and value of 0 undelegates `to`).\\n     **/\\n    function delegate(address _to, uint256 _bips) external;\\n\\n    /**\\n     * @notice Undelegate all percentage delegations from the sender and then delegate corresponding\\n     *   `_bips` percentage of voting power from the sender to each member of `_delegatees`.\\n     * @param _delegatees The addresses of the new recipients.\\n     * @param _bips The percentages of voting power to be delegated expressed in basis points (1/100 of one percent).\\n     *   Total of all `_bips` values must be at most 10000.\\n     **/\\n    function batchDelegate(\\n        address[] memory _delegatees,\\n        uint256[] memory _bips\\n    ) external;\\n\\n    /**\\n     * @notice Explicitly delegate `_amount` of voting power to `_to` from `msg.sender`.\\n     * @param _to The address of the recipient\\n     * @param _amount An explicit vote power amount to be delegated.\\n     *   Not cumulative - every call resets the delegation value (and value of 0 undelegates `to`).\\n     **/\\n    function delegateExplicit(address _to, uint _amount) external;\\n\\n    /**\\n     * @notice Revoke all delegation from sender to `_who` at given block.\\n     *    Only affects the reads via `votePowerOfAtCached()` in the block `_blockNumber`.\\n     *    Block `_blockNumber` must be in the past.\\n     *    This method should be used only to prevent rogue delegate voting in the current voting block.\\n     *    To stop delegating use delegate/delegateExplicit with value of 0 or undelegateAll/undelegateAllExplicit.\\n     * @param _who Address of the delegatee\\n     * @param _blockNumber The block number at which to revoke delegation.\\n     */\\n    function revokeDelegationAt(address _who, uint _blockNumber) external;\\n\\n    /**\\n     * @notice Undelegate all voting power for delegates of `msg.sender`\\n     *    Can only be used with percentage delegation.\\n     *    Does not reset delegation mode back to NOTSET.\\n     **/\\n    function undelegateAll() external;\\n\\n    /**\\n     * @notice Undelegate all explicit vote power by amount delegates for `msg.sender`.\\n     *    Can only be used with explicit delegation.\\n     *    Does not reset delegation mode back to NOTSET.\\n     * @param _delegateAddresses Explicit delegation does not store delegatees' addresses,\\n     *   so the caller must supply them.\\n     * @return The amount still delegated (in case the list of delegates was incomplete).\\n     */\\n    function undelegateAllExplicit(\\n        address[] memory _delegateAddresses\\n    ) external returns (uint256);\\n\\n    /**\\n     * @dev Should be compatible with ERC20 method\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Should be compatible with ERC20 method\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Should be compatible with ERC20 method\\n     */\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @notice Total amount of tokens at a specific `_blockNumber`.\\n     * @param _blockNumber The block number when the totalSupply is queried\\n     * @return The total amount of tokens at `_blockNumber`\\n     **/\\n    function totalSupplyAt(uint _blockNumber) external view returns (uint256);\\n\\n    /**\\n     * @dev Queries the token balance of `_owner` at a specific `_blockNumber`.\\n     * @param _owner The address from which the balance will be retrieved.\\n     * @param _blockNumber The block number when the balance is queried.\\n     * @return The balance at `_blockNumber`.\\n     **/\\n    function balanceOfAt(\\n        address _owner,\\n        uint _blockNumber\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Get the current total vote power.\\n     * @return The current total vote power (sum of all accounts' vote powers).\\n     */\\n    function totalVotePower() external view returns (uint256);\\n\\n    /**\\n     * @notice Get the total vote power at block `_blockNumber`\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return The total vote power at the block  (sum of all accounts' vote powers).\\n     */\\n    function totalVotePowerAt(\\n        uint _blockNumber\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Get the current vote power of `_owner`.\\n     * @param _owner The address to get voting power.\\n     * @return Current vote power of `_owner`.\\n     */\\n    function votePowerOf(address _owner) external view returns (uint256);\\n\\n    /**\\n     * @notice Get the vote power of `_owner` at block `_blockNumber`\\n     * @param _owner The address to get voting power.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return Vote power of `_owner` at `_blockNumber`.\\n     */\\n    function votePowerOfAt(\\n        address _owner,\\n        uint256 _blockNumber\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Get the vote power of `_owner` at block `_blockNumber`, ignoring revocation information (and cache).\\n     * @param _owner The address to get voting power.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return Vote power of `_owner` at `_blockNumber`. Result doesn't change if vote power is revoked.\\n     */\\n    function votePowerOfAtIgnoringRevocation(\\n        address _owner,\\n        uint256 _blockNumber\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Get the delegation mode for '_who'. This mode determines whether vote power is\\n     *  allocated by percentage or by explicit value. Once the delegation mode is set,\\n     *  it never changes, even if all delegations are removed.\\n     * @param _who The address to get delegation mode.\\n     * @return delegation mode: 0 = NOTSET, 1 = PERCENTAGE, 2 = AMOUNT (i.e. explicit)\\n     */\\n    function delegationModeOf(address _who) external view returns (uint256);\\n\\n    /**\\n     * @notice Get current delegated vote power `_from` delegator delegated `_to` delegatee.\\n     * @param _from Address of delegator\\n     * @param _to Address of delegatee\\n     * @return The delegated vote power.\\n     */\\n    function votePowerFromTo(\\n        address _from,\\n        address _to\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Get delegated the vote power `_from` delegator delegated `_to` delegatee at `_blockNumber`.\\n     * @param _from Address of delegator\\n     * @param _to Address of delegatee\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return The delegated vote power.\\n     */\\n    function votePowerFromToAt(\\n        address _from,\\n        address _to,\\n        uint _blockNumber\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Compute the current undelegated vote power of `_owner`\\n     * @param _owner The address to get undelegated voting power.\\n     * @return The unallocated vote power of `_owner`\\n     */\\n    function undelegatedVotePowerOf(\\n        address _owner\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Get the undelegated vote power of `_owner` at given block.\\n     * @param _owner The address to get undelegated voting power.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return The undelegated vote power of `_owner` (= owner's own balance minus all delegations from owner)\\n     */\\n    function undelegatedVotePowerOfAt(\\n        address _owner,\\n        uint256 _blockNumber\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Get the vote power delegation `delegationAddresses`\\n     *  and `_bips` of `_who`. Returned in two separate positional arrays.\\n     * @param _who The address to get delegations.\\n     * @return _delegateAddresses Positional array of delegation addresses.\\n     * @return _bips Positional array of delegation percents specified in basis points (1/100 or 1 percent)\\n     * @return _count The number of delegates.\\n     * @return _delegationMode The mode of the delegation (NOTSET=0, PERCENTAGE=1, AMOUNT=2).\\n     */\\n    function delegatesOf(\\n        address _who\\n    )\\n        external\\n        view\\n        returns (\\n            address[] memory _delegateAddresses,\\n            uint256[] memory _bips,\\n            uint256 _count,\\n            uint256 _delegationMode\\n        );\\n\\n    /**\\n     * @notice Get the vote power delegation `delegationAddresses`\\n     *  and `pcts` of `_who`. Returned in two separate positional arrays.\\n     * @param _who The address to get delegations.\\n     * @param _blockNumber The block for which we want to know the delegations.\\n     * @return _delegateAddresses Positional array of delegation addresses.\\n     * @return _bips Positional array of delegation percents specified in basis points (1/100 or 1 percent)\\n     * @return _count The number of delegates.\\n     * @return _delegationMode The mode of the delegation (NOTSET=0, PERCENTAGE=1, AMOUNT=2).\\n     */\\n    function delegatesOfAt(\\n        address _who,\\n        uint256 _blockNumber\\n    )\\n        external\\n        view\\n        returns (\\n            address[] memory _delegateAddresses,\\n            uint256[] memory _bips,\\n            uint256 _count,\\n            uint256 _delegationMode\\n        );\\n\\n    /**\\n     * Returns VPContract used for readonly operations (view methods).\\n     * The only non-view method that might be called on it is `revokeDelegationAt`.\\n     *\\n     * @notice `readVotePowerContract` is almost always equal to `writeVotePowerContract`\\n     * except during upgrade from one VPContract to a new version (which should happen\\n     * rarely or never and will be anounced before).\\n     *\\n     * @notice You shouldn't call any methods on VPContract directly, all are exposed\\n     * via VPToken (and state changing methods are forbidden from direct calls).\\n     * This is the reason why this method returns `IVPContractEvents` - it should only be used\\n     * for listening to events (`Revoke` only).\\n     */\\n    function readVotePowerContract() external view returns (IVPContractEvents);\\n\\n    /**\\n     * Returns VPContract used for state changing operations (non-view methods).\\n     * The only non-view method that might be called on it is `revokeDelegationAt`.\\n     *\\n     * @notice `writeVotePowerContract` is almost always equal to `readVotePowerContract`\\n     * except during upgrade from one VPContract to a new version (which should happen\\n     * rarely or never and will be anounced before). In the case of upgrade,\\n     * `writeVotePowerContract` will be replaced first to establish delegations, and\\n     * after some perio (e.g. after a reward epoch ends) `readVotePowerContract` will be set equal to it.\\n     *\\n     * @notice You shouldn't call any methods on VPContract directly, all are exposed\\n     * via VPToken (and state changing methods are forbidden from direct calls).\\n     * This is the reason why this method returns `IVPContractEvents` - it should only be used\\n     * for listening to events (`Delegate` and `Revoke` only).\\n     */\\n    function writeVotePowerContract() external view returns (IVPContractEvents);\\n\\n    /**\\n     * When set, allows token owners to participate in governance voting\\n     * and delegate governance vote power.\\n     */\\n    function governanceVotePower() external view returns (IGovernanceVotePower);\\n}\\n\",\"keccak256\":\"0xa9efab6774133cce7bd53f22a76b86cda2867efb58e160c5ba6fa23625fbe21e\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IVoterRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * VoterRegistry interface.\\n */\\ninterface IVoterRegistry {\\n    /// Signature data.\\n    struct Signature {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    /// Event emitted when a beneficiary (c-chain address or node id) is chilled.\\n    event BeneficiaryChilled(\\n        bytes20 indexed beneficiary,\\n        uint256 untilRewardEpochId\\n    );\\n\\n    /// Event emitted when a voter is removed.\\n    event VoterRemoved(address indexed voter, uint256 indexed rewardEpochId);\\n\\n    /// Event emitted when a voter is registered.\\n    event VoterRegistered(\\n        address indexed voter,\\n        uint24 indexed rewardEpochId,\\n        address indexed signingPolicyAddress,\\n        address submitAddress,\\n        address submitSignaturesAddress,\\n        bytes32 publicKeyPart1,\\n        bytes32 publicKeyPart2,\\n        uint256 registrationWeight\\n    );\\n\\n    /**\\n     * Registers a voter if the weight is high enough.\\n     * @param _voter The voter address.\\n     * @param _signature The signature.\\n     */\\n    function registerVoter(\\n        address _voter,\\n        Signature calldata _signature\\n    ) external;\\n\\n    /**\\n     * Maximum number of voters in one reward epoch.\\n     */\\n    function maxVoters() external view returns (uint256);\\n\\n    /**\\n     * In case of providing bad votes (e.g. ftso collusion), the beneficiary can be chilled for a few reward epochs.\\n     * If beneficiary is chilled, the vote power assigned to it is zero.\\n     * @param _beneficiary The beneficiary (c-chain address or node id).\\n     * @return _rewardEpochId The reward epoch id until which the voter is chilled.\\n     */\\n    function chilledUntilRewardEpochId(\\n        bytes20 _beneficiary\\n    ) external view returns (uint256 _rewardEpochId);\\n\\n    /**\\n     * Returns the block number of the start of the new signing policy initialisation for a given reward epoch.\\n     * It is a snaphost block of the voters' addresses (it is zero if the reward epoch is not supported).\\n     * @param _rewardEpochId The reward epoch id.\\n     */\\n    function newSigningPolicyInitializationStartBlockNumber(\\n        uint256 _rewardEpochId\\n    ) external view returns (uint256);\\n\\n    /**\\n     * Indicates if the voter must have the public key set when registering.\\n     */\\n    function publicKeyRequired() external view returns (bool);\\n\\n    /**\\n     * Returns the list of registered voters for a given reward epoch.\\n     * List can be empty if the reward epoch is not supported (before initial reward epoch or future reward epoch).\\n     * List for the next reward epoch can still change until the signing policy snapshot is created.\\n     * @param _rewardEpochId The reward epoch id.\\n     */\\n    function getRegisteredVoters(\\n        uint256 _rewardEpochId\\n    ) external view returns (address[] memory);\\n\\n    /**\\n     * Returns the number of registered voters for a given reward epoch.\\n     * Size can be zero if the reward epoch is not supported (before initial reward epoch or future reward epoch).\\n     * Size for the next reward epoch can still change until the signing policy snapshot is created.\\n     * @param _rewardEpochId The reward epoch id.\\n     */\\n    function getNumberOfRegisteredVoters(\\n        uint256 _rewardEpochId\\n    ) external view returns (uint256);\\n\\n    /**\\n     * Returns true if a voter was (is currently) registered in a given reward epoch.\\n     * @param _voter The voter address.\\n     * @param _rewardEpochId The reward epoch id.\\n     */\\n    function isVoterRegistered(\\n        address _voter,\\n        uint256 _rewardEpochId\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x39382c509fce6745c15b2de8d9e3cd6c2dff858a5d32086b8dc1da4c48fa0a2c\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IVoterWhitelister.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\ninterface IVoterWhitelister {\\n    /**\\n     * Raised when an account is removed from the voter whitelist.\\n     */\\n    event VoterWhitelisted(address voter, uint256 ftsoIndex);\\n\\n    /**\\n     * Raised when an account is removed from the voter whitelist.\\n     */\\n    event VoterRemovedFromWhitelist(address voter, uint256 ftsoIndex);\\n\\n    /**\\n     * Raised when an account is chilled from the voter whitelist.\\n     */\\n    event VoterChilled(address voter, uint256 untilRewardEpoch);\\n\\n    /**\\n     * Request to whitelist `_voter` account to ftso at `_ftsoIndex`. Will revert if vote power too low.\\n     * May be called by any address.\\n     */\\n    function requestWhitelistingVoter(\\n        address _voter,\\n        uint256 _ftsoIndex\\n    ) external;\\n\\n    /**\\n     * Request to whitelist `_voter` account to all active ftsos.\\n     * May be called by any address.\\n     * It returns an array of supported ftso indices and success flag per index.\\n     */\\n    function requestFullVoterWhitelisting(\\n        address _voter\\n    )\\n        external\\n        returns (uint256[] memory _supportedIndices, bool[] memory _success);\\n\\n    /**\\n     * Maximum number of voters in the whitelist for a new FTSO.\\n     */\\n    function defaultMaxVotersForFtso() external view returns (uint256);\\n\\n    /**\\n     * Maximum number of voters in the whitelist for FTSO at index `_ftsoIndex`.\\n     */\\n    function maxVotersForFtso(\\n        uint256 _ftsoIndex\\n    ) external view returns (uint256);\\n\\n    /**\\n     * Get whitelisted price providers for ftso with `_symbol`\\n     */\\n    function getFtsoWhitelistedPriceProvidersBySymbol(\\n        string memory _symbol\\n    ) external view returns (address[] memory);\\n\\n    /**\\n     * Get whitelisted price providers for ftso at `_ftsoIndex`\\n     */\\n    function getFtsoWhitelistedPriceProviders(\\n        uint256 _ftsoIndex\\n    ) external view returns (address[] memory);\\n\\n    /**\\n     * In case of providing bad prices (e.g. collusion), the voter can be chilled for a few reward epochs.\\n     * A voter can whitelist again from a returned reward epoch onwards.\\n     */\\n    function chilledUntilRewardEpoch(\\n        address _voter\\n    ) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xa3952c2b8a56ffc17c5312e2a24f823e46524a8968cc007b5c9249ecaeac50e8\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IWNat.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\ninterface IWNat {\\n    /**\\n     * @notice Deposit native token and mint WNAT ERC20.\\n     */\\n    function deposit() external payable;\\n\\n    /**\\n     * @notice Withdraw native token and burn WNAT ERC20.\\n     * @param _amount The amount to withdraw.\\n     */\\n    function withdraw(uint256 _amount) external;\\n\\n    /**\\n     * @notice Deposit native token from msg.sender and mint WNAT ERC20.\\n     * @param _recipient An address to receive minted WNAT.\\n     */\\n    function depositTo(address _recipient) external payable;\\n\\n    /**\\n     * @notice Withdraw WNAT from an owner and send NAT to msg.sender given an allowance.\\n     * @param _owner An address spending the native tokens.\\n     * @param _amount The amount to spend.\\n     *\\n     * Requirements:\\n     *\\n     * - `_owner` must have a balance of at least `_amount`.\\n     * - the caller must have allowance for `_owners`'s tokens of at least\\n     * `_amount`.\\n     */\\n    function withdrawFrom(address _owner, uint256 _amount) external;\\n}\\n\",\"keccak256\":\"0x7b3385688e966f694c96f84b6fee362cd7894ec607dce3349038d13e871ad01c\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IWNatDelegationFee.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * WNatDelegationFee interface.\\n */\\ninterface IWNatDelegationFee {\\n    /// Event emitted when a voter fee percentage value is changed.\\n    event FeePercentageChanged(\\n        address indexed voter,\\n        uint16 value,\\n        uint24 validFromEpochId\\n    );\\n\\n    /**\\n     * Allows voter to set (or update last) fee percentage.\\n     * @param _feePercentageBIPS Number representing fee percentage in BIPS.\\n     * @return Returns the reward epoch number when the value becomes effective.\\n     */\\n    function setVoterFeePercentage(\\n        uint16 _feePercentageBIPS\\n    ) external returns (uint256);\\n\\n    /// The offset in reward epochs for the fee percentage value to become effective.\\n    function feePercentageUpdateOffset() external view returns (uint24);\\n\\n    /// The default fee percentage value.\\n    function defaultFeePercentageBIPS() external view returns (uint16);\\n\\n    /**\\n     * Returns the current fee percentage of `_voter`.\\n     * @param _voter Voter address.\\n     */\\n    function getVoterCurrentFeePercentage(\\n        address _voter\\n    ) external view returns (uint16);\\n\\n    /**\\n     * Returns the fee percentage of `_voter` for given reward epoch id.\\n     * @param _voter Voter address.\\n     * @param _rewardEpochId Reward epoch id.\\n     * **NOTE:** fee percentage might still change for the `current + feePercentageUpdateOffset` reward epoch id\\n     */\\n    function getVoterFeePercentage(\\n        address _voter,\\n        uint256 _rewardEpochId\\n    ) external view returns (uint16);\\n\\n    /**\\n     * Returns the scheduled fee percentage changes of `_voter`.\\n     * @param _voter Voter address.\\n     * @return _feePercentageBIPS Positional array of fee percentages in BIPS.\\n     * @return _validFromEpochId Positional array of reward epoch ids the fee setings are effective from.\\n     * @return _fixed Positional array of boolean values indicating if settings are subjected to change.\\n     */\\n    function getVoterScheduledFeePercentageChanges(\\n        address _voter\\n    )\\n        external\\n        view\\n        returns (\\n            uint256[] memory _feePercentageBIPS,\\n            uint256[] memory _validFromEpochId,\\n            bool[] memory _fixed\\n        );\\n}\\n\",\"keccak256\":\"0x75a879a5d80563fe2f7df5fbfdee054ba2adf51c408f2622d9867ef2965f25af\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IWeb2Json.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * @custom:name IWeb2Json\\n * @custom:supported WEB2\\n * @author Flare\\n * @notice An attestation request that fetches JSON data from the given URL,\\n * applies a jq filter to transform the returned result, and returns the structured data as ABI encoded data.\\n * @custom:verification  Data is fetched from an URL `url`. The received data is then processed with jq as\\n * the `postProcessJq` states. The structure of the final JSON is written in the `abiSignature`.\\n *\\n * The response contains an abi encoding of the final data.\\n * @custom:lut `0xffffffffffffffff`\\n * @custom:lut-limit `0xffffffffffffffff`\\n */\\ninterface IWeb2Json {\\n    /**\\n     * @notice Toplevel request\\n     * @param attestationType ID of the attestation type.\\n     * @param sourceId ID of the data source.\\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.\\n     * @param requestBody Data defining the request. Type (struct) and interpretation is determined\\n     * by the `attestationType`.\\n     */\\n    struct Request {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        bytes32 messageIntegrityCode;\\n        RequestBody requestBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel response\\n     * @param attestationType Extracted from the request.\\n     * @param sourceId Extracted from the request.\\n     * @param votingRound The ID of the State Connector round in which the request was considered.\\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\\n     * @param requestBody Extracted from the request.\\n     * @param responseBody Data defining the response. The verification rules for the construction\\n     * of the response body and the type are defined per specific `attestationType`.\\n     */\\n    struct Response {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        uint64 votingRound;\\n        uint64 lowestUsedTimestamp;\\n        RequestBody requestBody;\\n        ResponseBody responseBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel proof\\n     * @param merkleProof Merkle proof corresponding to the attestation response.\\n     * @param data Attestation response.\\n     */\\n    struct Proof {\\n        bytes32[] merkleProof;\\n        Response data;\\n    }\\n\\n    /**\\n     * @notice Request body for Web2Json attestation type\\n     * @param url URL of the data source\\n     * @param httpMethod HTTP method to be used to fetch from URL source.\\n     * Supported methods: GET, POST, PUT, PATCH, DELETE.\\n     * @param headers Headers to be included to fetch from URL source. Use `{}` if no headers are needed.\\n     * @param queryParams Query parameters to be included to fetch from URL source.\\n     * Use `{}` if no query parameters are needed.\\n     * @param body Request body to be included to fetch from URL source. Use '{}' if no request body is required.\\n     * @param postProcessJq jq filter used to post-process the JSON response from the URL.\\n     * @param abiSignature ABI signature of the struct used to encode the data after jq post-processing.\\n     */\\n    struct RequestBody {\\n        string url;\\n        string httpMethod;\\n        string headers;\\n        string queryParams;\\n        string body;\\n        string postProcessJq;\\n        string abiSignature;\\n    }\\n\\n    /**\\n     * @notice Response body for Web2Json attestation type\\n     * @param abiEncodedData Raw binary data encoded to match the function parameters in ABI.\\n     */\\n    struct ResponseBody {\\n        bytes abiEncodedData;\\n    }\\n}\\n\",\"keccak256\":\"0xf6fe44b15d57a422378dd0cf7520df1df30cb2b81869b5d60857392e1362f66b\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IWeb2JsonVerification.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IWeb2Json.sol\\\";\\n\\ninterface IWeb2JsonVerification {\\n    function verifyWeb2Json(\\n        IWeb2Json.Proof calldata _proof\\n    ) external view returns (bool _proved);\\n}\\n\",\"keccak256\":\"0x8ddd82d5eba88987f1d170b0a47bff6ce5fc9d37f9c1a8f28c615f2ca20698d4\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/ProtocolsV2Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * Protocols V2 long term support interface.\\n */\\ninterface ProtocolsV2Interface {\\n    /**\\n     * Timestamp when the first reward epoch started, in seconds since UNIX epoch.\\n     */\\n    function firstRewardEpochStartTs() external view returns (uint64);\\n\\n    /**\\n     * Duration of reward epoch, in seconds.\\n     */\\n    function rewardEpochDurationSeconds() external view returns (uint64);\\n\\n    /**\\n     * Timestamp when the first voting epoch started, in seconds since UNIX epoch.\\n     */\\n    function firstVotingRoundStartTs() external view returns (uint64);\\n\\n    /**\\n     * Duration of voting epoch, in seconds.\\n     */\\n    function votingEpochDurationSeconds() external view returns (uint64);\\n\\n    /**\\n     * Returns the vote power block for given reward epoch id.\\n     */\\n    function getVotePowerBlock(\\n        uint256 _rewardEpochId\\n    ) external view returns (uint64 _votePowerBlock);\\n\\n    /**\\n     * Returns the start voting round id for given reward epoch id.\\n     */\\n    function getStartVotingRoundId(\\n        uint256 _rewardEpochId\\n    ) external view returns (uint32);\\n\\n    /**\\n     * Returns the current reward epoch id.\\n     */\\n    function getCurrentRewardEpochId() external view returns (uint24);\\n\\n    /**\\n     * Returns the current voting epoch id.\\n     */\\n    function getCurrentVotingEpochId() external view returns (uint32);\\n}\\n\",\"keccak256\":\"0xfd54af39bbcf68376017ea46c79e7960f2d13fe270d6d09db338fd015f277071\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/RandomNumberV2Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * Random number V2 long term support interface.\\n */\\ninterface RandomNumberV2Interface {\\n    /**\\n     * Returns the current random number, its timestamp and the flag indicating if it is secure.\\n     * @return _randomNumber The current random number.\\n     * @return _isSecureRandom The flag indicating if the random number is secure.\\n     * @return _randomTimestamp The timestamp of the random number.\\n     */\\n    function getRandomNumber()\\n        external\\n        view\\n        returns (\\n            uint256 _randomNumber,\\n            bool _isSecureRandom,\\n            uint256 _randomTimestamp\\n        );\\n\\n    /**\\n     * Returns the historical random number for a given _votingRoundId,\\n     * its timestamp and the flag indicating if it is secure.\\n     * If no finalization in the _votingRoundId, the function reverts.\\n     * @param _votingRoundId The voting round id.\\n     * @return _randomNumber The current random number.\\n     * @return _isSecureRandom The flag indicating if the random number is secure.\\n     * @return _randomTimestamp The timestamp of the random number.\\n     */\\n    function getRandomNumberHistorical(\\n        uint256 _votingRoundId\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 _randomNumber,\\n            bool _isSecureRandom,\\n            uint256 _randomTimestamp\\n        );\\n}\\n\",\"keccak256\":\"0x82c2764990f3733a4ef9a399de824f2dc66fc27239080d33019da52181ffb697\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/RewardsV2Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * Rewards V2 long term support interface.\\n */\\ninterface RewardsV2Interface {\\n    /// Claim type enum.\\n    enum ClaimType {\\n        DIRECT,\\n        FEE,\\n        WNAT,\\n        MIRROR,\\n        CCHAIN\\n    }\\n\\n    /// Struct used for claiming rewards with Merkle proof.\\n    struct RewardClaimWithProof {\\n        bytes32[] merkleProof;\\n        RewardClaim body;\\n    }\\n\\n    /// Struct used in Merkle tree for storing reward claims.\\n    struct RewardClaim {\\n        uint24 rewardEpochId;\\n        bytes20 beneficiary; // c-chain address or node id (bytes20) in case of type MIRROR\\n        uint120 amount; // in wei\\n        ClaimType claimType;\\n    }\\n\\n    /// Struct used for returning state of rewards.\\n    struct RewardState {\\n        uint24 rewardEpochId;\\n        bytes20 beneficiary; // c-chain address or node id (bytes20) in case of type MIRROR\\n        uint120 amount; // in wei\\n        ClaimType claimType;\\n        bool initialised;\\n    }\\n\\n    /**\\n     * Claim rewards for `_rewardOwner` and transfer them to `_recipient`.\\n     * It can be called by reward owner or its authorized executor.\\n     * @param _rewardOwner Address of the reward owner.\\n     * @param _recipient Address of the reward recipient.\\n     * @param _rewardEpochId Id of the reward epoch up to which the rewards are claimed.\\n     * @param _wrap Indicates if the reward should be wrapped (deposited) to the WNAT contract.\\n     * @param _proofs Array of reward claims with merkle proofs.\\n     * @return _rewardAmountWei Amount of rewarded native tokens (wei).\\n     */\\n    function claim(\\n        address _rewardOwner,\\n        address payable _recipient,\\n        uint24 _rewardEpochId,\\n        bool _wrap,\\n        RewardClaimWithProof[] calldata _proofs\\n    ) external returns (uint256 _rewardAmountWei);\\n\\n    /**\\n     * Indicates if the contract is active - claims are enabled.\\n     */\\n    function active() external view returns (bool);\\n\\n    /**\\n     * Returns the start and the end of the reward epoch range for which the reward is claimable.\\n     * @return _startEpochId The oldest epoch id that allows reward claiming.\\n     * @return _endEpochId The newest epoch id that allows reward claiming.\\n     */\\n    function getRewardEpochIdsWithClaimableRewards()\\n        external\\n        view\\n        returns (uint24 _startEpochId, uint24 _endEpochId);\\n\\n    /**\\n     * Returns the next claimable reward epoch for a reward owner.\\n     * @param _rewardOwner Address of the reward owner to query.\\n     */\\n    function getNextClaimableRewardEpochId(\\n        address _rewardOwner\\n    ) external view returns (uint256);\\n\\n    /**\\n     * Returns the state of rewards for a given address for all unclaimed reward epochs with claimable rewards.\\n     * @param _rewardOwner Address of the reward owner.\\n     * @return _rewardStates Array of reward states.\\n     */\\n    function getStateOfRewards(\\n        address _rewardOwner\\n    ) external view returns (RewardState[][] memory _rewardStates);\\n}\\n\",\"keccak256\":\"0x049c91d723427e2fa372f7202d658b01fdc9f502e64709f3fdb2c5770efcfac9\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/TestFtsoV2Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * FtsoV2 long term support interface.\\n */\\ninterface TestFtsoV2Interface {\\n    /// Feed data structure\\n    struct FeedData {\\n        uint32 votingRoundId;\\n        bytes21 id;\\n        int32 value;\\n        uint16 turnoutBIPS;\\n        int8 decimals;\\n    }\\n\\n    /// Feed data with proof structure\\n    struct FeedDataWithProof {\\n        bytes32[] proof;\\n        FeedData body;\\n    }\\n\\n    /// Feed id change structure\\n    struct FeedIdChange {\\n        bytes21 oldFeedId;\\n        bytes21 newFeedId;\\n    }\\n\\n    /// Event emitted when a feed id is changed (e.g. feed renamed).\\n    event FeedIdChanged(bytes21 indexed oldFeedId, bytes21 indexed newFeedId);\\n\\n    /**\\n     * Returns the FTSO protocol id.\\n     */\\n    function getFtsoProtocolId() external view returns (uint256);\\n\\n    /**\\n     * Returns the list of supported feed ids (currently active feed ids).\\n     * To get the list of all available feed ids, combine with `getFeedIdChanges()`.\\n     * @return _feedIds The list of supported feed ids.\\n     */\\n    function getSupportedFeedIds()\\n        external\\n        view\\n        returns (bytes21[] memory _feedIds);\\n\\n    /**\\n     * Returns the list of feed id changes.\\n     * @return _feedIdChanges The list of changed feed id pairs (old and new feed id).\\n     */\\n    function getFeedIdChanges()\\n        external\\n        view\\n        returns (FeedIdChange[] memory _feedIdChanges);\\n\\n    /**\\n     * Calculates the fee for fetching a feed.\\n     * @param _feedId The id of the feed.\\n     * @return _fee The fee for fetching the feed.\\n     */\\n    function calculateFeeById(\\n        bytes21 _feedId\\n    ) external view returns (uint256 _fee);\\n\\n    /**\\n     * Calculates the fee for fetching feeds.\\n     * @param _feedIds The list of feed ids.\\n     * @return _fee The fee for fetching the feeds.\\n     */\\n    function calculateFeeByIds(\\n        bytes21[] memory _feedIds\\n    ) external view returns (uint256 _fee);\\n\\n    /**\\n     * Returns stored data of a feed.\\n     * A fee (calculated by the FeeCalculator contract) may need to be paid.\\n     * @param _feedId The id of the feed.\\n     * @return _value The value for the requested feed.\\n     * @return _decimals The decimal places for the requested feed.\\n     * @return _timestamp The timestamp of the last update.\\n     */\\n    function getFeedById(\\n        bytes21 _feedId\\n    ) external view returns (uint256 _value, int8 _decimals, uint64 _timestamp);\\n\\n    /**\\n     * Returns stored data of each feed.\\n     * A fee (calculated by the FeeCalculator contract) may need to be paid.\\n     * @param _feedIds The list of feed ids.\\n     * @return _values The list of values for the requested feeds.\\n     * @return _decimals The list of decimal places for the requested feeds.\\n     * @return _timestamp The timestamp of the last update.\\n     */\\n    function getFeedsById(\\n        bytes21[] memory _feedIds\\n    )\\n        external\\n        view\\n        returns (\\n            uint256[] memory _values,\\n            int8[] memory _decimals,\\n            uint64 _timestamp\\n        );\\n\\n    /**\\n     * Returns value in wei and timestamp of a feed.\\n     * A fee (calculated by the FeeCalculator contract) may need to be paid.\\n     * @param _feedId The id of the feed.\\n     * @return _value The value for the requested feed in wei (i.e. with 18 decimal places).\\n     * @return _timestamp The timestamp of the last update.\\n     */\\n    function getFeedByIdInWei(\\n        bytes21 _feedId\\n    ) external view returns (uint256 _value, uint64 _timestamp);\\n\\n    /** Returns value of each feed and a timestamp.\\n     * For some feeds, a fee (calculated by the FeeCalculator contract) may need to be paid.\\n     * @param _feedIds Ids of the feeds.\\n     * @return _values The list of values for the requested feeds in wei (i.e. with 18 decimal places).\\n     * @return _timestamp The timestamp of the last update.\\n     */\\n    function getFeedsByIdInWei(\\n        bytes21[] memory _feedIds\\n    ) external view returns (uint256[] memory _values, uint64 _timestamp);\\n\\n    /**\\n     * Checks if the feed data is valid (i.e. is part of the confirmed Merkle tree).\\n     * @param _feedData Structure containing data about the feed (FeedData structure) and Merkle proof.\\n     * @return true if the feed data is valid.\\n     */\\n    function verifyFeedData(\\n        FeedDataWithProof calldata _feedData\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x49c4869f4c11d42e3459d37b34fed433a50bd5bfe85a34b2bf79fe831e942df3\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/data/AgentInfo.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nlibrary AgentInfo {\\n    enum Status {\\n        // agent is operating normally\\n        NORMAL,\\n        // liquidation due to collateral ratio - ends when agent is healthy\\n        LIQUIDATION,\\n        // illegal payment liquidation - always liquidates all and then agent must close vault\\n        FULL_LIQUIDATION,\\n        // agent announced destroy, cannot mint again; all existing mintings have been redeemed before\\n        DESTROYING,\\n        // agent has been destroyed, cannot do anything except return info\\n        // owner can still withdraw tokens from the vault\\n        DESTROYED\\n    }\\n\\n    struct Info {\\n        // Current agent's status.\\n        AgentInfo.Status status;\\n        // Agent vault owner's management address, used for occasional administration.\\n        // Immutable.\\n        address ownerManagementAddress;\\n        // Agent vault owner's work address, used for automatic operations.\\n        // Can be changed by a call from the owner's management address.\\n        address ownerWorkAddress;\\n        // Agent's collateral pool address\\n        address collateralPool;\\n        // Agent collateral pool's pool token address\\n        address collateralPoolToken;\\n        // Underlying address as string - to be used for minting payments.\\n        // For most other purposes, you use underlyingAddressHash, which is `keccak256(underlyingAddressString)`.\\n        string underlyingAddressString;\\n        // If true, anybody can mint against this agent.\\n        // If false, the agent can only self-mint.\\n        // Once minted, all redemption tickets go to the same (public) queue, regardless of this flag.\\n        bool publiclyAvailable;\\n        // Current fee the agent charges for minting (paid in underlying currency).\\n        uint256 feeBIPS;\\n        // Share of the minting fee that goes to the pool as percentage of the minting fee.\\n        // This share of fee is minted as f-assets and belongs to the pool.\\n        uint256 poolFeeShareBIPS;\\n        // The token identifier of the agent's current vault collateral.\\n        // Token identifier can be used to call AssetManager.getCollateralType().\\n        IERC20 vaultCollateralToken;\\n        // Amount, set by agent, at which locked and free collateral are calculated for new mintings.\\n        // For agent's vault collateral.\\n        uint256 mintingVaultCollateralRatioBIPS;\\n        // Amount, set by agent, at which locked and free collateral are calculated for new mintings.\\n        // For pool collateral.\\n        uint256 mintingPoolCollateralRatioBIPS;\\n        // The maximum number of lots that the agent can mint.\\n        // This can change any moment due to minting, redemption or price changes.\\n        uint256 freeCollateralLots;\\n        // Total amount of vault collateral in agent's vault.\\n        uint256 totalVaultCollateralWei;\\n        // Free collateral, available for new mintings.\\n        // Note: this value doesn't tell you anything about agent being near liquidation, since it is\\n        // calculated at agentMinCollateralRatio, not minCollateralRatio.\\n        // Use collateralRatioBIPS to see whether the agent is near liquidation.\\n        uint256 freeVaultCollateralWei;\\n        // The actual agent's collateral ratio, as it is used in liquidation.\\n        // For calculation, the system checks both FTSO prices and trusted provider's prices and uses\\n        // the ones that give higher ratio.\\n        uint256 vaultCollateralRatioBIPS;\\n        // The token identifier of the agent's current vault collateral.\\n        // Token identifier can be used to call AssetManager.getCollateralType().\\n        IERC20 poolWNatToken;\\n        // Total amount of NAT collateral in agent's pool.\\n        uint256 totalPoolCollateralNATWei;\\n        // Free NAT pool collateral (see vault collateral for details).\\n        uint256 freePoolCollateralNATWei;\\n        // The actual pool collateral ratio (see vault collateral for details).\\n        uint256 poolCollateralRatioBIPS;\\n        // The amount of pool tokens that belong to agent's vault. This limits the amount of possible\\n        // minting: to be able to mint, the NAT value of all backed fassets together with new ones, times\\n        // mintingPoolHoldingsRequiredBIPS, must be smaller than the agent's pool tokens amount converted to NAT.\\n        // Note: the amount of agent's pool tokens only affects minting, not liquidation.\\n        uint256 totalAgentPoolTokensWei;\\n        // The amount of vault collateral that will be withdrawn by the agent.\\n        uint256 announcedVaultCollateralWithdrawalWei;\\n        // The amount of pool tokens that will be withdrawn by the agent.\\n        uint256 announcedPoolTokensWithdrawalWei;\\n        // Free agent's pool tokens.\\n        uint256 freeAgentPoolTokensWei;\\n        // Total amount of minted f-assets.\\n        uint256 mintedUBA;\\n        // Total amount reserved for ongoing mintings.\\n        uint256 reservedUBA;\\n        // Total amount of ongoing redemptions.\\n        uint256 redeemingUBA;\\n        // Total amount of ongoing redemptions that lock the pool collateral.\\n        // (In pool self-close exits, pool collateral is not locked. So the amount of locked\\n        // collateral in the pool can be less than the amount of locked vault collateral.)\\n        uint256 poolRedeemingUBA;\\n        // Total amount of dust (unredeemable minted f-assets).\\n        // Note: dustUBA is part of mintedUBA, so the amount of redeemable f-assets is calculated as\\n        // `mintedUBA - dustUBA`\\n        uint256 dustUBA;\\n        // Liquidation info\\n        // If the agent is in LIQUIDATION or FULL_LIQUIDATION, the time agent entered liquidation.\\n        // If status is neither of that, returns 0.\\n        // Can be used for calculating current liquidation premium, which depends on time since liquidation started.\\n        uint256 liquidationStartTimestamp;\\n        // When agent is in liquidation, this is the amount o FAssets that need to be liquidated to bring the agent's\\n        // position to safety. When performing liquidation, only up to this amount of FAssets will be liquidated.\\n        // If not in liquidation, this value is 0.\\n        // Since the liquidation state may need to be upgraded by, call `startLiquidation` before\\n        // `getAgentInfo` to get the value that will actually be used in liquidation.\\n        uint256 maxLiquidationAmountUBA;\\n        // When agent is in liquidation, this is the factor (in BIPS) of the converted value of the liquidated\\n        // FAssets paid by the vault collateral. If not in liquidation, this value is 0.\\n        uint256 liquidationPaymentFactorVaultBIPS;\\n        // When agent is in liquidation, this is the factor (in BIPS) of the converted value of the liquidated\\n        // FAssets paid by the pool collateral. If not in liquidation, this value is 0.\\n        uint256 liquidationPaymentFactorPoolBIPS;\\n        // Total underlying balance (backing and free).\\n        int256 underlyingBalanceUBA;\\n        // The minimum underlying balance that has to be held by the agent. Below this, agent is liquidated.\\n        uint256 requiredUnderlyingBalanceUBA;\\n        // Underlying balance not backing anything (can be used for gas/fees or withdrawn after announcement).\\n        int256 freeUnderlyingBalanceUBA;\\n        // Current underlying withdrawal announcement (or 0 if no announcement was made).\\n        uint256 announcedUnderlyingWithdrawalId;\\n        // The factor set by the agent to multiply the price at which agent buys f-assets from pool\\n        // token holders on self-close exit (when requested or the redeemed amount is less than 1 lot).\\n        uint256 buyFAssetByAgentFactorBIPS;\\n        // The minimum collateral ratio above which a staker can exit the pool\\n        // (this is CR that must be left after exit).\\n        // Must be higher than system minimum collateral ratio for pool collateral.\\n        uint256 poolExitCollateralRatioBIPS;\\n        // The redemption fee share paid to the pool (as FAssets).\\n        // In redemption dominated situations (when agent requests return from core vault to earn\\n        // from redemption fees), pool can get some share to make it sustainable for pool users.\\n        // NOTE: the pool fee share is locked at the redemption request time, but is charged at the redemption\\n        // confirmation time. If agent uses all the redemption fee for transaction fees, this could make the\\n        // agent's free underlying balance negative.\\n        uint256 redemptionPoolFeeShareBIPS;\\n    }\\n}\\n\",\"keccak256\":\"0x587b54a6f396fb05d3a56528f21887b15e4463cab2e4d2cd8728febb085bee4d\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/data/AgentSettings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nlibrary AgentSettings {\\n    struct Data {\\n        // The token used as vault collateral. Must be one of the tokens obtained by `getCollateralTypes()`,\\n        // with class VAULT.\\n        IERC20 vaultCollateralToken;\\n        // The suffix to pool token name and symbol that identifies new vault's collateral pool token.\\n        // Must be unique within an asset manager.\\n        string poolTokenSuffix;\\n        // Minting fee. Normally charged to minters for publicly available agents, but must be set\\n        // also for self-minting agents to pay part of it to collateral pool.\\n        // Fee is paid in underlying currency along with backing assets.\\n        uint256 feeBIPS;\\n        // Share of the minting fee that goes to the pool as percentage of the minting fee.\\n        // This share of fee is minted as f-assets and belongs to the pool.\\n        uint256 poolFeeShareBIPS;\\n        // Collateral ratio at which we calculate locked collateral and collateral available for minting.\\n        // Agent may set own value for minting collateral ratio on creation.\\n        // The value must always be greater than system minimum collateral ratio for vault collateral.\\n        // Warning: having this value near global min collateral ratio can quickly lead to liquidation for public\\n        // agents, so it is advisable to set it significantly higher.\\n        uint256 mintingVaultCollateralRatioBIPS;\\n        // Collateral ratio at which we calculate locked collateral and collateral available for minting.\\n        // Agent may set own value for minting collateral ratio on creation.\\n        // The value must always be greater than system minimum collateral ratio for pool collateral.\\n        // Warning: having this value near global min collateral ratio can quickly lead to liquidation for public\\n        // agents, so it is advisable to set it significantly higher.\\n        uint256 mintingPoolCollateralRatioBIPS;\\n        // The factor set by the agent to multiply the price at which agent buys f-assets from pool\\n        // token holders on self-close exit (when requested or the redeemed amount is less than 1 lot).\\n        uint256 buyFAssetByAgentFactorBIPS;\\n        // The minimum collateral ratio above which a staker can exit the pool\\n        // (this is CR that must be left after exit).\\n        // Must be higher than system minimum collateral ratio for pool collateral.\\n        uint256 poolExitCollateralRatioBIPS;\\n        // The redemption fee share paid to the pool (as FAssets).\\n        // In redemption dominated situations (when agent requests return from core vault to earn\\n        // from redemption fees), pool can get some share to make it sustainable for pool users.\\n        // NOTE: the pool fee share is locked at the redemption request time, but is charged at the redemption\\n        // confirmation time. If agent uses all the redemption fee for transaction fees, this could make the\\n        // agent's free underlying balance negative.\\n        uint256 redemptionPoolFeeShareBIPS;\\n    }\\n}\\n\",\"keccak256\":\"0xeb7c63d50464ed4da8a94c1124f82a06ab7d548a653e3873cf912f96837d8044\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/data/AssetManagerSettings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nlibrary AssetManagerSettings {\\n    struct Data {\\n        // Required contracts.\\n        // Only used to verify that calls come from assetManagerController.\\n        // Type: AssetManagerController\\n        // changed via address updater\\n        address assetManagerController;\\n        // The f-asset contract managed by this asset manager.\\n        // Type: IIFAsset\\n        // immutable\\n        address fAsset;\\n        // Factory for creating new agent vaults.\\n        // Type: IIAgentVaultFactory\\n        // timelocked\\n        address agentVaultFactory;\\n        // Factory for creating new agent collateral pools.\\n        // Type: IICollateralPoolFactory\\n        // timelocked\\n        address collateralPoolFactory;\\n        // Factory for creating new agent collateral pool tokens.\\n        // Type: IICollateralPoolTokenFactory\\n        // timelocked\\n        address collateralPoolTokenFactory;\\n        // The suffix to pool token name and symbol that identifies new vault's collateral pool token.\\n        // When vault is created, the owner passes own suffix which will be appended to this.\\n        string poolTokenSuffix;\\n        // If set, the whitelist contains a list of accounts that can call public methods\\n        // (minting, redeeming, challenging, etc.)\\n        // This can be `address(0)`, in which case no whitelist checks are done.\\n        // Type: IWhitelist\\n        // timelocked\\n        address __whitelist; // only storage placeholder\\n        // If set, the owner address registry contains a list of allowed agent owner's\\n        // management addresses and mappings from management to work address.\\n        // Type: IAgentOwnerRegistry\\n        // timelocked\\n        address agentOwnerRegistry;\\n        // Attestation client verifies and decodes attestation proofs.\\n        // Type: IFdcVerification\\n        // changed via address updater\\n        address fdcVerification;\\n        // The address where burned NAT is sent.\\n        // immutable\\n        address payable burnAddress;\\n        // The contract that reads prices from FTSO system in an FTSO version independent way.\\n        // Type: IPriceReader\\n        // timelocked\\n        address priceReader;\\n        // Same as assetToken.decimals()\\n        // immutable\\n        uint8 assetDecimals;\\n        // Number of decimals of precision of minted amounts.\\n        // assetMintingGranularityUBA = 10 ** (assetDecimals - assetMintingDecimals)\\n        // immutable\\n        uint8 assetMintingDecimals;\\n        // Must match attestation data chainId.\\n        // immutable\\n        bytes32 chainId;\\n        // Average time between two successive blocks on the underlying chain, in milliseconds.\\n        // rate-limited\\n        uint32 averageBlockTimeMS;\\n        // The minimum amount of pool tokens the agent must hold to be able to mint.\\n        // To be able to mint, the NAT value of all backed fassets together with new ones times this percentage\\n        // must be smaller than the agent's pool tokens' amount converted to NAT.\\n        // rate-limited\\n        uint32 mintingPoolHoldingsRequiredBIPS;\\n        // Collateral reservation fee that must be paid by the minter.\\n        // Payment is in NAT, but is proportional to the value of assets to be minted.\\n        // rate-limited\\n        uint16 collateralReservationFeeBIPS;\\n        // Asset unit value (e.g. 1 BTC or 1 ETH) in UBA = 10 ** assetToken.decimals()\\n        // immutable\\n        uint64 assetUnitUBA;\\n        // The granularity in which lots are measured = the value of AMG (asset minting granularity) in UBA.\\n        // Can only be changed via redeploy of AssetManager.\\n        // AMG is used internally instead of UBA so that minted quantities fit into 64bits to reduce storage.\\n        // So assetMintingGranularityUBA should be set so that the max supply in AMG of this currency\\n        // in foreseeable time (say 100yr) cannot overflow 64 bits.\\n        // immutable\\n        uint64 assetMintingGranularityUBA;\\n        // Lot size in asset minting granularity. May change, which affects subsequent mintings and redemptions.\\n        // timelocked\\n        uint64 lotSizeAMG;\\n        // The percentage of minted f-assets that the agent must hold in his underlying address.\\n        uint16 __minUnderlyingBackingBIPS; // only storage placeholder\\n        // for some chains (e.g. Ethereum) we require that agent proves that underlying address is an EOA address\\n        // this must be done by presenting a payment proof from that address\\n        // immutable\\n        bool __requireEOAAddressProof; // only storage placeholder\\n        // Maximum minted amount of the f-asset.\\n        // rate-limited\\n        uint64 mintingCapAMG;\\n        // Number of underlying blocks that the minter or agent is allowed to pay underlying value.\\n        // If payment not reported in that time, minting/redemption can be challenged and default action triggered.\\n        // CAREFUL: Count starts from the current proved block height, so the minters and agents should\\n        // make sure that current block height is fresh, otherwise they might not have enough time for payment.\\n        // timelocked\\n        uint64 underlyingBlocksForPayment;\\n        // Minimum time to allow agent to pay for redemption or minter to pay for minting.\\n        // This is useful for fast chains, when there can be more than one block per second.\\n        // Redemption/minting payment failure can be called only after underlyingSecondsForPayment have elapsed\\n        // on underlying chain.\\n        // CAREFUL: Count starts from the current proved block timestamp, so the minters and agents should\\n        // make sure that current block timestamp is fresh, otherwise they might not have enough time for payment.\\n        // This is partially mitigated by adding local duration since the last block height update to\\n        // the current underlying block timestamp.\\n        // timelocked\\n        uint64 underlyingSecondsForPayment;\\n        // Redemption fee in underlying currency base amount (UBA).\\n        // rate-limited\\n        uint16 redemptionFeeBIPS;\\n        // On redemption underlying payment failure, redeemer is compensated with\\n        // redemption value recalculated in flare/sgb times redemption failure factor.\\n        // Expressed in BIPS, e.g. 12000 for factor of 1.2.\\n        // This is the part of factor paid from agent's vault collateral.\\n        // rate-limited\\n        uint32 redemptionDefaultFactorVaultCollateralBIPS;\\n        // This is the part of redemption factor paid from agent's pool collateral.\\n        // rate-limited\\n        uint32 __redemptionDefaultFactorPoolBIPS; // only storage placeholder\\n        // If the agent or redeemer becomes unresponsive, we still need payment or non-payment confirmations\\n        // to be presented eventually to properly track agent's underlying balance.\\n        // Therefore we allow anybody to confirm payments/non-payments this many seconds after request was made.\\n        // rate-limited\\n        uint64 confirmationByOthersAfterSeconds;\\n        // The user who makes abandoned redemption confirmations gets rewarded by the following amount.\\n        // rate-limited\\n        uint128 confirmationByOthersRewardUSD5;\\n        // To prevent unbounded work, the number of tickets redeemed in a single request is limited.\\n        // rate-limited\\n        // >= 1\\n        uint16 maxRedeemedTickets;\\n        // Challenge reward can be composed of two part - fixed and proportional (any of them can be zero).\\n        // This is the proportional part (in BIPS).\\n        // rate-limited\\n        uint16 paymentChallengeRewardBIPS;\\n        // Challenge reward can be composed of two part - fixed and proportional (any of them can be zero).\\n        // This is the fixed part (in vault collateral token wei).\\n        // rate-limited\\n        uint128 paymentChallengeRewardUSD5;\\n        // Agent has to announce any collateral withdrawal ar vault destroy and then wait for at least\\n        // withdrawalWaitMinSeconds. This prevents challenged agent to remove all collateral before\\n        // challenge can be proved.\\n        // rate-limited\\n        uint64 withdrawalWaitMinSeconds;\\n        // Maximum age that trusted price feed is valid.\\n        // Otherwise (if there were no trusted votes for that long) just use generic ftso price feed.\\n        // rate-limited\\n        uint64 maxTrustedPriceAgeSeconds;\\n        // Agent can remain in CCB for this much time, after that liquidation starts automatically.\\n        // rate-limited\\n        uint64 __ccbTimeSeconds; // only storage placeholder\\n        // Amount of seconds (typically 1 day) that the payment/non-payment proofs must be available.\\n        // This setting is used in `unstickMinting` and `finishRedemptionWithoutPayment` to prove that the time when\\n        // payment/non-payment could be proved has already passed.\\n        // rate-limited\\n        uint64 attestationWindowSeconds;\\n        // Minimum time after an update of a setting before the same setting can be updated again.\\n        // timelocked\\n        uint64 minUpdateRepeatTimeSeconds;\\n        // Ratio at which the agents can buy back their collateral when f-asset is terminated.\\n        // Typically a bit more than 1 to incentivize agents to buy f-assets and self-close instead.\\n        // immutable\\n        uint64 __buybackCollateralFactorBIPS; // only storage placeholder\\n        // Minimum time that has to pass between underlying withdrawal announcement and the confirmation.\\n        // Any value is ok, but higher values give more security against multiple announcement attack by a miner.\\n        // Shouldn't be much bigger than Flare data connector response time, so that payments can be confirmed without\\n        // extra wait. Should be smaller than confirmationByOthersAfterSeconds (e.g. less than 1 hour).\\n        // rate-limited\\n        uint64 __announcedUnderlyingConfirmationMinSeconds; // only storage placeholder\\n        // Minimum time from the moment token is deprecated to when it becomes invalid and agents still using\\n        // it as vault collateral get liquidated.\\n        // timelocked\\n        uint64 __tokenInvalidationTimeMinSeconds; // only storage placeholder\\n        // On some rare occasions (stuck minting), the agent has to unlock collateral.\\n        // For this, part of collateral corresponding to FTSO asset value is burned and the rest is released.\\n        // However, we cannot burn typical vault collateral (stablecoins), so the agent must buy them for NAT\\n        // at FTSO price multiplied with this factor (should be a bit above 1) and then we burn the NATs.\\n        // timelocked\\n        uint32 vaultCollateralBuyForFlareFactorBIPS;\\n        // Amount of seconds that have to pass between available list exit announcement and execution.\\n        // rate-limited\\n        uint64 agentExitAvailableTimelockSeconds;\\n        // Amount of seconds that have to pass between agent fee and pool fee share change announcement and execution.\\n        // rate-limited\\n        uint64 agentFeeChangeTimelockSeconds;\\n        // Amount of seconds that have to pass between agent-set minting collateral ratio (vault or pool)\\n        // change announcement and execution.\\n        // rate-limited\\n        uint64 agentMintingCRChangeTimelockSeconds;\\n        // Amount of seconds that have to pass between agent-set settings for pool exit collateral ratio\\n        // change announcement and execution.\\n        // rate-limited\\n        uint64 poolExitCRChangeTimelockSeconds;\\n        // Amount of seconds that an agent is allowed to execute an update once it is allowed.\\n        // rate-limited\\n        uint64 agentTimelockedOperationWindowSeconds;\\n        // duration of the timelock for collateral pool tokens after minting\\n        uint32 collateralPoolTokenTimelockSeconds;\\n        // If there was no liquidator for the current liquidation offer,\\n        // go to the next step of liquidation after a certain period of time.\\n        // rate-limited\\n        uint64 liquidationStepSeconds;\\n        // Factor with which to multiply the asset price in native currency to obtain the payment\\n        // to the liquidator.\\n        // Expressed in BIPS, e.g. [12000, 16000, 20000] means that the liquidator will be paid 1.2, 1.6 and 2.0\\n        // times the market price of the liquidated assets after each `liquidationStepSeconds`.\\n        // Values in the array must increase and be greater than 100%.\\n        // rate-limited\\n        uint256[] liquidationCollateralFactorBIPS;\\n        // How much of the liquidation is paid in vault collateral.\\n        // The remainder will be paid in pool NAT collateral.\\n        uint256[] liquidationFactorVaultCollateralBIPS;\\n        // Minimum time that the system must wait before performing diamond cut.\\n        // The actual timelock is the maximum of this setting and GovernanceSettings.timelock.\\n        uint64 diamondCutMinTimelockSeconds;\\n        // The maximum total pause that can be triggered by non-governance (but governance allowed) caller.\\n        // The duration count can be reset by the governance.\\n        uint64 maxEmergencyPauseDurationSeconds;\\n        // The amount of time since last emergency pause after which the total pause duration counter\\n        // will reset automatically.\\n        uint64 emergencyPauseDurationResetAfterSeconds;\\n        // The amount of time after which the collateral reservation can be cancelled if the\\n        // handshake is not completed.\\n        // rate-limited\\n        uint64 __cancelCollateralReservationAfterSeconds; // only storage placeholder\\n        // The amount of collateral reservation fee returned to the minter in case of rejection or cancellation.\\n        // Expressed in BIPS, e.g. 9500 for factor of 0.95, max 10000 for factor of 1.0.\\n        // rate-limited\\n        uint16 __rejectOrCancelCollateralReservationReturnFactorBIPS; // only storage placeholder\\n        // Time window inside which the agent can reject the redemption request.\\n        // rate-limited\\n        uint64 __rejectRedemptionRequestWindowSeconds; // only storage placeholder\\n        // Time window inside which the agent can take over the redemption request from another agent\\n        // that has rejected it.\\n        // rate-limited\\n        uint64 __takeOverRedemptionRequestWindowSeconds; // only storage placeholder\\n        // On redemption rejection, without take over, redeemer is compensated with\\n        // redemption value recalculated in flare/sgb times redemption failure factor.\\n        // Expressed in BIPS, e.g. 12000 for factor of 1.2.\\n        // This is the part of factor paid from agent's vault collateral.\\n        // rate-limited\\n        uint32 __rejectedRedemptionDefaultFactorVaultCollateralBIPS; // only storage placeholder\\n        // This is the part of rejected redemption factor paid from agent's pool collateral.\\n        // rate-limited\\n        uint32 __rejectedRedemptionDefaultFactorPoolBIPS; // only storage placeholder\\n    }\\n}\\n\",\"keccak256\":\"0xecc617af341da9273948255ca56322bbe5ca3460378fadb4d11e29e2367e0e38\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/data/AvailableAgentInfo.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport {AgentInfo} from \\\"./AgentInfo.sol\\\";\\n\\nlibrary AvailableAgentInfo {\\n    struct Data {\\n        // Agent vault address.\\n        address agentVault;\\n        // The management address of the agent vault's owner.\\n        address ownerManagementAddress;\\n        // Agent's minting fee in BIPS.\\n        uint256 feeBIPS;\\n        // Minimum agent vault collateral ratio needed for minting.\\n        uint256 mintingVaultCollateralRatioBIPS;\\n        // Minimum pool collateral ratio needed for minting.\\n        uint256 mintingPoolCollateralRatioBIPS;\\n        // The number of lots that can be minted by this agent.\\n        // Note: the value is only informative since it can can change at any time\\n        // due to price changes, reservation, minting, redemption, or even lot size change.\\n        uint256 freeCollateralLots;\\n        // The agent status, as for getAgentInfo().\\n        AgentInfo.Status status;\\n    }\\n}\\n\",\"keccak256\":\"0x9b24a69b894d433e5ee4f1614aaf959c09af71e551aaab38f0dedd40d5653a7c\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/data/CollateralReservationInfo.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nlibrary CollateralReservationInfo {\\n    enum Status {\\n        ACTIVE, // the minting process hasn't finished yet\\n        SUCCESSFUL, // the payment has been confirmed and the FAssets minted\\n        DEFAULTED, // the payment has defaulted and the agent received the collateral reservation fee\\n        EXPIRED // the confirmation time has expired and the agent called unstickMinting\\n    }\\n\\n    struct Data {\\n        // The id used for executing or defaulting the minting.\\n        uint64 collateralReservationId;\\n        // The agent vault whose collateral is reserved.\\n        address agentVault;\\n        // The minter address - the address that will receive the minted FAssets.\\n        address minter;\\n        // The agent's underlying address to which the underlying assets should be paid by the minter.\\n        string paymentAddress;\\n        // Payment reference that must be part of the agent's redemption payment.\\n        bytes32 paymentReference;\\n        // The amount of FAssets that the minter will receive. Always a whole number of lots.\\n        uint256 valueUBA;\\n        // The underlying fee. The total amount the minter has to deposit is `valueUBA + mintingFeeUBA`.\\n        // Part of the fee is minted as pool fee share and the rest becomes agent's free underlying.\\n        uint128 mintingFeeUBA;\\n        // The fee that was paid at the collateral reservation time.\\n        // Part of the fee is goes to the pool and the rest to the agent vault as WNAT.\\n        uint128 reservationFeeNatWei;\\n        // Proportion of the mintingFeeUBA and reservationFeeNatWei that belongs to the collateral pool.\\n        uint16 poolFeeShareBIPS;\\n        // The underlying block (approximate - as known by the asset manager) when the reservation occurred.\\n        uint64 firstUnderlyingBlock;\\n        // The last underlying block and timestamp for redemption payment. Redemption is defaulted if\\n        // there is no payment by the time BOTH lastUnderlyingBlock and lastUnderlyingTimestamp have passed.\\n        uint64 lastUnderlyingBlock;\\n        uint64 lastUnderlyingTimestamp;\\n        // The executor, optionally assigned by the minter to execute the minting.\\n        // (Only minter, agent or executor may execute the minting.)\\n        address executor;\\n        // The fee in NAT that the executor receives if they successfully execute the minting.\\n        uint256 executorFeeNatWei;\\n        // If the minting process has finished, indication of success/default. Otherwise ACTIVE.\\n        CollateralReservationInfo.Status status;\\n    }\\n}\\n\",\"keccak256\":\"0x6ba4ab5f661987e9a5b921b09a8595364ad176bf9518867103684ea63379939b\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/data/CollateralType.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nlibrary CollateralType {\\n    enum Class {\\n        NONE, // unused\\n        POOL, // pool collateral type\\n        VAULT // usable as vault collateral\\n    }\\n\\n    // Collateral token is uniquely identified by the pair (collateralClass, token).\\n    struct Data {\\n        // The kind of collateral for this token.\\n        CollateralType.Class collateralClass;\\n        // The ERC20 token contract for this collateral type.\\n        IERC20 token;\\n        // Same as token.decimals(), when that exists.\\n        uint256 decimals;\\n        // Token invalidation time. Should always be 0 since token invalidation is deprecated.\\n        uint256 validUntil;\\n        // When `true`, the FTSO with symbol `assetFtsoSymbol` returns asset price relative to this token\\n        // (such FTSO's will probably exist for major stablecoins).\\n        // When `false`, the FTSOs with symbols `assetFtsoSymbol` and `tokenFtsoSymbol` give asset and token\\n        // price relative to the same reference currency and the asset/token price is calculated as their ratio.\\n        bool directPricePair;\\n        // FTSO symbol for the asset, relative to this token or a reference currency\\n        // (it depends on the value of `directPricePair`).\\n        string assetFtsoSymbol;\\n        // FTSO symbol for this token in reference currency.\\n        // Used for asset/token price calculation when `directPricePair` is `false`.\\n        // Otherwise it is irrelevant to asset/token price calculation, but if it is nonempty,\\n        // it is still used in calculation of challenger and confirmation rewards\\n        // (otherwise we assume it approximates the value of USD and pay directly the USD amount in vault collateral).\\n        string tokenFtsoSymbol;\\n        // Minimum collateral ratio for healthy agents.\\n        uint256 minCollateralRatioBIPS;\\n        // Minimum collateral ratio required to get agent out of liquidation.\\n        // Will always be greater than minCollateralRatioBIPS.\\n        uint256 safetyMinCollateralRatioBIPS;\\n    }\\n}\\n\",\"keccak256\":\"0xca8d0f9d24884b5fbb00e467946deba7c98bef60c439ce955ee7a7fd0f25f9dc\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/data/EmergencyPause.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nlibrary EmergencyPause {\\n    enum Level {\\n        // Pause is not active.\\n        NONE,\\n        // Prevent starting mint, redeem, liquidation and core vault transfer/return.\\n        START_OPERATIONS,\\n        // Everything from START_OPERATIONS, plus prevent finishing or defulating already started mints and redeems.\\n        FULL,\\n        // Everything from FULL, plus prevent FAsset transfers.\\n        FULL_AND_TRANSFER\\n    }\\n}\\n\",\"keccak256\":\"0x0c1b8c014b91fe15be47f795df1e361d450351a003d0e8600ad3059e27db2ae5\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/data/RedemptionRequestInfo.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nlibrary RedemptionRequestInfo {\\n    enum Status {\\n        ACTIVE, // waiting for confirmation/default\\n        DEFAULTED_UNCONFIRMED, // default called, failed or late payment can still be confirmed\\n        // final statuses - there can be no valid payment for this redemption anymore\\n        SUCCESSFUL, // successful payment confirmed\\n        DEFAULTED_FAILED, // payment failed   (default was paid)\\n        BLOCKED, // payment blocked\\n        REJECTED // redemption request rejected due to invalid redeemer's address\\n    }\\n\\n    struct Data {\\n        // The id used for confirming or defaulting the request.\\n        uint64 redemptionRequestId;\\n        // Redemption status. Note that on payment confirmation the request is deleted, so there is no success status.\\n        RedemptionRequestInfo.Status status;\\n        // The redeemed agent vault.\\n        address agentVault;\\n        // Native redeemer address - the address that receives collateral in case of default.\\n        address redeemer;\\n        // The underlying address to which the redeemed assets should be paid by the agent.\\n        string paymentAddress;\\n        // Payment reference that must be part of the agent's redemption payment.\\n        bytes32 paymentReference;\\n        // The amount of the FAsset the redeemer has burned. Note that this is not the amount of underlying\\n        // the redeemer will receive - the redemption payment amount is this minus the underlyingFeeUBA.\\n        uint128 valueUBA;\\n        // The redemption fee that remain on agent's underlying address.\\n        // Part of it will be reminted as pool fee share and the rest becomes the agent's free underlying.\\n        uint128 feeUBA;\\n        // Proportional part of the underlyingFeeUBA that is re-minted on successful redemption\\n        // and goes to the collateral pool.\\n        uint16 poolFeeShareBIPS;\\n        // The underlying block (approximate - as known by the asset manager) when the request occurred.\\n        uint64 firstUnderlyingBlock;\\n        // The last underlying block and timestamp for redemption payment. Redemption is defaulted if\\n        // there is no payment by the time BOTH lastUnderlyingBlock and lastUnderlyingTimestamp have passed.\\n        uint64 lastUnderlyingBlock;\\n        uint64 lastUnderlyingTimestamp;\\n        // The native (Flare/Songbird) chain timestamp when the request occurred.\\n        uint64 timestamp;\\n        // True if redemption was created by a selfCloseExit on the collateral pool.\\n        bool poolSelfClose;\\n        // True if redemption was initiated by an agent for transfer to core vault.\\n        bool transferToCoreVault;\\n        // The executor, optionally assigned by the redeemer to execute the default if needed.\\n        // (Only redeemer, agent or executor may execute the default.)\\n        address executor;\\n        // The fee in NAT that the executor receives if they successfully call default.\\n        uint256 executorFeeNatWei;\\n    }\\n}\\n\",\"keccak256\":\"0x04e9e7fb72fa9be7966a7016d7a9583a9b8e52222be12f7f3ebd6b5475f71e33\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/data/RedemptionTicketInfo.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nlibrary RedemptionTicketInfo {\\n    struct Data {\\n        // The id of the ticket, same as returned in RedemptionTicketCreated/Updated/Deleted events.\\n        uint256 redemptionTicketId;\\n        // Backing agent vault address.\\n        address agentVault;\\n        // The amount of FAsset on the ticket.\\n        uint256 ticketValueUBA;\\n    }\\n}\\n\",\"keccak256\":\"0x5766d8ee4ff113f408deea0ee5b59ad9a730e580037e8700d5f6c11a19e93ecd\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/diamond/interfaces/IDiamondLoupe.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\n// A loupe is a small magnifying glass used to look at diamonds.\\n// These functions look at diamonds\\ninterface IDiamondLoupe {\\n    /// These functions are expected to be called frequently\\n    /// by tools.\\n\\n    struct Facet {\\n        address facetAddress;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\n    /// @return facets_ Facet\\n    function facets() external view returns (Facet[] memory facets_);\\n\\n    /// @notice Gets all the function selectors supported by a specific facet.\\n    /// @param _facet The facet address.\\n    /// @return facetFunctionSelectors_\\n    function facetFunctionSelectors(\\n        address _facet\\n    ) external view returns (bytes4[] memory facetFunctionSelectors_);\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses()\\n        external\\n        view\\n        returns (address[] memory facetAddresses_);\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(\\n        bytes4 _functionSelector\\n    ) external view returns (address facetAddress_);\\n}\\n\",\"keccak256\":\"0xdc5991b0218ab6b2cd78983c19f74a789a79ec9a9ba756ae05c8dcd512c13e38\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/ftso/interfaces/IIFtso.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"../../genesis/interfaces/IFtsoGenesis.sol\\\";\\nimport \\\"../../IFtso.sol\\\";\\nimport \\\"../../token/interfaces/IIVPToken.sol\\\";\\n\\ninterface IIFtso is IFtso, IFtsoGenesis {\\n    /// function finalizePriceReveal\\n    /// called by reward manager only on correct timing.\\n    /// if price reveal period for epoch x ended. finalize.\\n    /// iterate list of price submissions\\n    /// find weighted median\\n    /// find adjucant 50% of price submissions.\\n    /// Allocate reward for any price submission which is same as a \\\"winning\\\" submission\\n    function finalizePriceEpoch(\\n        uint256 _epochId,\\n        bool _returnRewardData\\n    )\\n        external\\n        returns (\\n            address[] memory _eligibleAddresses,\\n            uint256[] memory _natWeights,\\n            uint256 _totalNatWeight\\n        );\\n\\n    function fallbackFinalizePriceEpoch(uint256 _epochId) external;\\n\\n    function forceFinalizePriceEpoch(uint256 _epochId) external;\\n\\n    // activateFtso will be called by ftso manager once ftso is added\\n    // before this is done, FTSO can't run\\n    function activateFtso(\\n        uint256 _firstEpochStartTs,\\n        uint256 _submitPeriodSeconds,\\n        uint256 _revealPeriodSeconds\\n    ) external;\\n\\n    function deactivateFtso() external;\\n\\n    // update initial price and timestamp - only if not active\\n    function updateInitialPrice(\\n        uint256 _initialPriceUSD,\\n        uint256 _initialPriceTimestamp\\n    ) external;\\n\\n    function configureEpochs(\\n        uint256 _maxVotePowerNatThresholdFraction,\\n        uint256 _maxVotePowerAssetThresholdFraction,\\n        uint256 _lowAssetUSDThreshold,\\n        uint256 _highAssetUSDThreshold,\\n        uint256 _highAssetTurnoutThresholdBIPS,\\n        uint256 _lowNatTurnoutThresholdBIPS,\\n        uint256 _elasticBandRewardBIPS,\\n        uint256 _elasticBandWidthPPM,\\n        address[] memory _trustedAddresses\\n    ) external;\\n\\n    function setAsset(IIVPToken _asset) external;\\n\\n    function setAssetFtsos(IIFtso[] memory _assetFtsos) external;\\n\\n    // current vote power block will update per reward epoch.\\n    // the FTSO doesn't have notion of reward epochs.\\n    // reward manager only can set this data.\\n    function setVotePowerBlock(uint256 _blockNumber) external;\\n\\n    function initializeCurrentEpochStateForReveal(\\n        uint256 _circulatingSupplyNat,\\n        bool _fallbackMode\\n    ) external;\\n\\n    /**\\n     * @notice Returns ftso manager address\\n     */\\n    function ftsoManager() external view returns (address);\\n\\n    /**\\n     * @notice Returns the FTSO asset\\n     * @dev Asset is null in case of multi-asset FTSO\\n     */\\n    function getAsset() external view returns (IIVPToken);\\n\\n    /**\\n     * @notice Returns the Asset FTSOs\\n     * @dev AssetFtsos is not null only in case of multi-asset FTSO\\n     */\\n    function getAssetFtsos() external view returns (IIFtso[] memory);\\n\\n    /**\\n     * @notice Returns current configuration of epoch state\\n     * @return _maxVotePowerNatThresholdFraction        High threshold for native token vote power per voter\\n     * @return _maxVotePowerAssetThresholdFraction      High threshold for asset vote power per voter\\n     * @return _lowAssetUSDThreshold            Threshold for low asset vote power\\n     * @return _highAssetUSDThreshold           Threshold for high asset vote power\\n     * @return _highAssetTurnoutThresholdBIPS   Threshold for high asset turnout\\n     * @return _lowNatTurnoutThresholdBIPS      Threshold for low nat turnout\\n     * @return _elasticBandRewardBIPS           Hybrid reward band, where _elasticBandRewardBIPS goes to the \\n        elastic band (prices within _elasticBandWidthPPM of the median) \\n        and 10000 - elasticBandRewardBIPS to the IQR \\n     * @return _elasticBandWidthPPM             Prices within _elasticBandWidthPPM of median are rewarded\\n     * @return _trustedAddresses                Trusted addresses - use their prices if low nat turnout is not achieved\\n     */\\n    function epochsConfiguration()\\n        external\\n        view\\n        returns (\\n            uint256 _maxVotePowerNatThresholdFraction,\\n            uint256 _maxVotePowerAssetThresholdFraction,\\n            uint256 _lowAssetUSDThreshold,\\n            uint256 _highAssetUSDThreshold,\\n            uint256 _highAssetTurnoutThresholdBIPS,\\n            uint256 _lowNatTurnoutThresholdBIPS,\\n            uint256 _elasticBandRewardBIPS,\\n            uint256 _elasticBandWidthPPM,\\n            address[] memory _trustedAddresses\\n        );\\n\\n    /**\\n     * @notice Returns parameters necessary for approximately replicating vote weighting.\\n     * @return _assets                  the list of Assets that are accounted in vote\\n     * @return _assetMultipliers        weight of each asset in (multiasset) ftso, mutiplied by TERA\\n     * @return _totalVotePowerNat       total native token vote power at block\\n     * @return _totalVotePowerAsset     total combined asset vote power at block\\n     * @return _assetWeightRatio        ratio of combined asset vp vs. native token vp (in BIPS)\\n     * @return _votePowerBlock          vote powewr block for given epoch\\n     */\\n    function getVoteWeightingParameters()\\n        external\\n        view\\n        returns (\\n            IIVPToken[] memory _assets,\\n            uint256[] memory _assetMultipliers,\\n            uint256 _totalVotePowerNat,\\n            uint256 _totalVotePowerAsset,\\n            uint256 _assetWeightRatio,\\n            uint256 _votePowerBlock\\n        );\\n\\n    function wNat() external view returns (IIVPToken);\\n}\\n\",\"keccak256\":\"0x95a16987ca3a253dc4167d724298c45006177c904b68b9e0b23fa4e9e8915c90\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/genesis/interfaces/IFtsoGenesis.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\ninterface IFtsoGenesis {\\n    /**\\n     * @notice Reveals submitted price during epoch reveal period - only price submitter\\n     * @param _voter                Voter address\\n     * @param _epochId              Id of the epoch in which the price hash was submitted\\n     * @param _price                Submitted price in USD\\n     * @notice The hash of _price and _random must be equal to the submitted hash\\n     * @notice Emits PriceRevealed event\\n     */\\n    function revealPriceSubmitter(\\n        address _voter,\\n        uint256 _epochId,\\n        uint256 _price,\\n        uint256 _wNatVP\\n    ) external;\\n\\n    /**\\n     * @notice Get (and cache) wNat vote power for specified voter and given epoch id\\n     * @param _voter                Voter address\\n     * @param _epochId              Id of the epoch in which the price hash was submitted\\n     * @return wNat vote power\\n     */\\n    function wNatVotePowerCached(\\n        address _voter,\\n        uint256 _epochId\\n    ) external returns (uint256);\\n}\\n\",\"keccak256\":\"0x811b13e7ea469439bfd4fd572b603dee2ae3adea9a4fac82283a81db4863f663\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/genesis/interfaces/IFtsoManagerGenesis.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\ninterface IFtsoManagerGenesis {\\n    function getCurrentPriceEpochId()\\n        external\\n        view\\n        returns (uint256 _priceEpochId);\\n}\\n\",\"keccak256\":\"0x6adc3295b96dad83eebfc9bc7a799764f07bd75c2f7e95b19190badfca0294bf\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/genesis/interfaces/IFtsoRegistryGenesis.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IFtsoGenesis.sol\\\";\\n\\ninterface IFtsoRegistryGenesis {\\n    function getFtsos(\\n        uint256[] memory _indices\\n    ) external view returns (IFtsoGenesis[] memory _ftsos);\\n}\\n\",\"keccak256\":\"0x804c35979a44a9c9aa94521e603d3eeabe414e7860b25267960eea35fcc8b199\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/token/interfaces/IICleanable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\ninterface IICleanable {\\n    /**\\n     * Set the contract that is allowed to call history cleaning methods.\\n     */\\n    function setCleanerContract(address _cleanerContract) external;\\n\\n    /**\\n     * Set the cleanup block number.\\n     * Historic data for the blocks before `cleanupBlockNumber` can be erased,\\n     * history before that block should never be used since it can be inconsistent.\\n     * In particular, cleanup block number must be before current vote power block.\\n     * @param _blockNumber The new cleanup block number.\\n     */\\n    function setCleanupBlockNumber(uint256 _blockNumber) external;\\n\\n    /**\\n     * Get the current cleanup block number.\\n     */\\n    function cleanupBlockNumber() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xb2051b09812a899ba53558609b3f8fada259ef510c59f32dca898bcd39de22bc\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/token/interfaces/IIGovernanceVotePower.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"../../IVPToken.sol\\\";\\nimport \\\"../../IPChainStakeMirror.sol\\\";\\nimport \\\"../../IGovernanceVotePower.sol\\\";\\n\\n/**\\n * Internal interface for contracts delegating their governance vote power.\\n */\\ninterface IIGovernanceVotePower is IGovernanceVotePower {\\n    /**\\n     * Emitted when a delegate's vote power changes, as a result of a new delegation\\n     * or a token transfer, for example.\\n     *\\n     * The event is always emitted from a `GovernanceVotePower` contract.\\n     * @param delegate The account receiving the changing delegated vote power.\\n     * @param previousBalance Delegated vote power before the change.\\n     * @param newBalance Delegated vote power after the change.\\n     */\\n    event DelegateVotesChanged(\\n        address indexed delegate,\\n        uint256 previousBalance,\\n        uint256 newBalance\\n    );\\n\\n    /**\\n     * Emitted when an account starts delegating vote power or switches its delegation\\n     * to another address.\\n     *\\n     * The event is always emitted from a `GovernanceVotePower` contract.\\n     * @param delegator Account delegating its vote power.\\n     * @param fromDelegate Account receiving the delegation before the change.\\n     * Can be address(0) if there was no previous delegation.\\n     * @param toDelegate Account receiving the delegation after the change.\\n     * Can be address(0) if `delegator` just undelegated all its vote power.\\n     */\\n    event DelegateChanged(\\n        address indexed delegator,\\n        address indexed fromDelegate,\\n        address indexed toDelegate\\n    );\\n\\n    /**\\n     * Update governance vote power of all involved delegates after tokens are transferred.\\n     *\\n     * This function **MUST** be called after each governance token transfer for the\\n     * delegates to reflect the correct balance.\\n     * @param _from Source address of the transfer.\\n     * @param _to Destination address of the transfer.\\n     * @param _fromBalance _Ignored._\\n     * @param _toBalance _Ignored._\\n     * @param _amount Amount being transferred.\\n     */\\n    function updateAtTokenTransfer(\\n        address _from,\\n        address _to,\\n        uint256 _fromBalance,\\n        uint256 _toBalance,\\n        uint256 _amount\\n    ) external;\\n\\n    /**\\n     * Set the cleanup block number.\\n     * Historic data for the blocks before `cleanupBlockNumber` can be erased.\\n     * History before that block should never be used since it can be inconsistent.\\n     * In particular, cleanup block number must be lower than the current vote power block.\\n     * @param _blockNumber The new cleanup block number.\\n     */\\n    function setCleanupBlockNumber(uint256 _blockNumber) external;\\n\\n    /**\\n     * Set the contract that is allowed to call history cleaning methods.\\n     * @param _cleanerContract Address of the cleanup contract.\\n     * Usually this will be an instance of `CleanupBlockNumberManager`.\\n     */\\n    function setCleanerContract(address _cleanerContract) external;\\n\\n    /**\\n     * Get the token that this governance vote power contract belongs to.\\n     * @return The IVPToken interface owning this contract.\\n     */\\n    function ownerToken() external view returns (IVPToken);\\n\\n    /**\\n     * Get the stake mirror contract that this governance vote power contract belongs to.\\n     * @return The IPChainStakeMirror interface owning this contract.\\n     */\\n    function pChainStakeMirror() external view returns (IPChainStakeMirror);\\n\\n    /**\\n     * Get the current cleanup block number set with `setCleanupBlockNumber()`.\\n     * @return The currently set cleanup block number.\\n     */\\n    function getCleanupBlockNumber() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x634edf63f2b35a2b54cfb872594785a7353f7eba9f82a0d90577f0e725c4a031\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/token/interfaces/IIVPContract.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"../../IVPToken.sol\\\";\\nimport \\\"../../IVPContractEvents.sol\\\";\\nimport \\\"./IICleanable.sol\\\";\\n\\ninterface IIVPContract is IICleanable, IVPContractEvents {\\n    /**\\n     * Update vote powers when tokens are transfered.\\n     * Also update delegated vote powers for percentage delegation\\n     * and check for enough funds for explicit delegations.\\n     **/\\n    function updateAtTokenTransfer(\\n        address _from,\\n        address _to,\\n        uint256 _fromBalance,\\n        uint256 _toBalance,\\n        uint256 _amount\\n    ) external;\\n\\n    /**\\n     * @notice Delegate `_bips` percentage of voting power to `_to` from `_from`\\n     * @param _from The address of the delegator\\n     * @param _to The address of the recipient\\n     * @param _balance The delegator's current balance\\n     * @param _bips The percentage of voting power to be delegated expressed in basis points (1/100 of one percent).\\n     *   Not cumulative - every call resets the delegation value (and value of 0 revokes delegation).\\n     **/\\n    function delegate(\\n        address _from,\\n        address _to,\\n        uint256 _balance,\\n        uint256 _bips\\n    ) external;\\n\\n    /**\\n     * @notice Explicitly delegate `_amount` of voting power to `_to` from `msg.sender`.\\n     * @param _from The address of the delegator\\n     * @param _to The address of the recipient\\n     * @param _balance The delegator's current balance\\n     * @param _amount An explicit vote power amount to be delegated.\\n     *   Not cumulative - every call resets the delegation value (and value of 0 undelegates `to`).\\n     **/\\n    function delegateExplicit(\\n        address _from,\\n        address _to,\\n        uint256 _balance,\\n        uint _amount\\n    ) external;\\n\\n    /**\\n     * @notice Revoke all delegation from sender to `_who` at given block.\\n     *    Only affects the reads via `votePowerOfAtCached()` in the block `_blockNumber`.\\n     *    Block `_blockNumber` must be in the past.\\n     *    This method should be used only to prevent rogue delegate voting in the current voting block.\\n     *    To stop delegating use delegate/delegateExplicit with value of 0 or undelegateAll/undelegateAllExplicit.\\n     * @param _from The address of the delegator\\n     * @param _who Address of the delegatee\\n     * @param _balance The delegator's current balance\\n     * @param _blockNumber The block number at which to revoke delegation.\\n     **/\\n    function revokeDelegationAt(\\n        address _from,\\n        address _who,\\n        uint256 _balance,\\n        uint _blockNumber\\n    ) external;\\n\\n    /**\\n     * @notice Undelegate all voting power for delegates of `msg.sender`\\n     *    Can only be used with percentage delegation.\\n     *    Does not reset delegation mode back to NOTSET.\\n     * @param _from The address of the delegator\\n     **/\\n    function undelegateAll(address _from, uint256 _balance) external;\\n\\n    /**\\n     * @notice Undelegate all explicit vote power by amount delegates for `msg.sender`.\\n     *    Can only be used with explicit delegation.\\n     *    Does not reset delegation mode back to NOTSET.\\n     * @param _from The address of the delegator\\n     * @param _delegateAddresses Explicit delegation does not store delegatees' addresses,\\n     *   so the caller must supply them.\\n     * @return The amount still delegated (in case the list of delegates was incomplete).\\n     */\\n    function undelegateAllExplicit(\\n        address _from,\\n        address[] memory _delegateAddresses\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Get the vote power of `_who` at block `_blockNumber`\\n     *   Reads/updates cache and upholds revocations.\\n     * @param _who The address to get voting power.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return Vote power of `_who` at `_blockNumber`.\\n     */\\n    function votePowerOfAtCached(\\n        address _who,\\n        uint256 _blockNumber\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Get the current vote power of `_who`.\\n     * @param _who The address to get voting power.\\n     * @return Current vote power of `_who`.\\n     */\\n    function votePowerOf(address _who) external view returns (uint256);\\n\\n    /**\\n     * @notice Get the vote power of `_who` at block `_blockNumber`\\n     * @param _who The address to get voting power.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return Vote power of `_who` at `_blockNumber`.\\n     */\\n    function votePowerOfAt(\\n        address _who,\\n        uint256 _blockNumber\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Get the vote power of `_who` at block `_blockNumber`, ignoring revocation information (and cache).\\n     * @param _who The address to get voting power.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return Vote power of `_who` at `_blockNumber`. Result doesn't change if vote power is revoked.\\n     */\\n    function votePowerOfAtIgnoringRevocation(\\n        address _who,\\n        uint256 _blockNumber\\n    ) external view returns (uint256);\\n\\n    /**\\n     * Return vote powers for several addresses in a batch.\\n     * @param _owners The list of addresses to fetch vote power of.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return A list of vote powers.\\n     */\\n    function batchVotePowerOfAt(\\n        address[] memory _owners,\\n        uint256 _blockNumber\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @notice Get current delegated vote power `_from` delegator delegated `_to` delegatee.\\n     * @param _from Address of delegator\\n     * @param _to Address of delegatee\\n     * @param _balance The delegator's current balance\\n     * @return The delegated vote power.\\n     */\\n    function votePowerFromTo(\\n        address _from,\\n        address _to,\\n        uint256 _balance\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Get delegated the vote power `_from` delegator delegated `_to` delegatee at `_blockNumber`.\\n     * @param _from Address of delegator\\n     * @param _to Address of delegatee\\n     * @param _balance The delegator's current balance\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return The delegated vote power.\\n     */\\n    function votePowerFromToAt(\\n        address _from,\\n        address _to,\\n        uint256 _balance,\\n        uint _blockNumber\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Compute the current undelegated vote power of `_owner`\\n     * @param _owner The address to get undelegated voting power.\\n     * @param _balance Owner's current balance\\n     * @return The unallocated vote power of `_owner`\\n     */\\n    function undelegatedVotePowerOf(\\n        address _owner,\\n        uint256 _balance\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Get the undelegated vote power of `_owner` at given block.\\n     * @param _owner The address to get undelegated voting power.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return The undelegated vote power of `_owner` (= owner's own balance minus all delegations from owner)\\n     */\\n    function undelegatedVotePowerOfAt(\\n        address _owner,\\n        uint256 _balance,\\n        uint256 _blockNumber\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Get the delegation mode for '_who'. This mode determines whether vote power is\\n     *  allocated by percentage or by explicit value.\\n     * @param _who The address to get delegation mode.\\n     * @return Delegation mode (NOTSET=0, PERCENTAGE=1, AMOUNT=2))\\n     */\\n    function delegationModeOf(address _who) external view returns (uint256);\\n\\n    /**\\n     * @notice Get the vote power delegation `_delegateAddresses`\\n     *  and `pcts` of an `_owner`. Returned in two separate positional arrays.\\n     * @param _owner The address to get delegations.\\n     * @return _delegateAddresses Positional array of delegation addresses.\\n     * @return _bips Positional array of delegation percents specified in basis points (1/100 or 1 percent)\\n     * @return _count The number of delegates.\\n     * @return _delegationMode The mode of the delegation (NOTSET=0, PERCENTAGE=1, AMOUNT=2).\\n     */\\n    function delegatesOf(\\n        address _owner\\n    )\\n        external\\n        view\\n        returns (\\n            address[] memory _delegateAddresses,\\n            uint256[] memory _bips,\\n            uint256 _count,\\n            uint256 _delegationMode\\n        );\\n\\n    /**\\n     * @notice Get the vote power delegation `delegationAddresses`\\n     *  and `pcts` of an `_owner`. Returned in two separate positional arrays.\\n     * @param _owner The address to get delegations.\\n     * @param _blockNumber The block for which we want to know the delegations.\\n     * @return _delegateAddresses Positional array of delegation addresses.\\n     * @return _bips Positional array of delegation percents specified in basis points (1/100 or 1 percent)\\n     * @return _count The number of delegates.\\n     * @return _delegationMode The mode of the delegation (NOTSET=0, PERCENTAGE=1, AMOUNT=2).\\n     */\\n    function delegatesOfAt(\\n        address _owner,\\n        uint256 _blockNumber\\n    )\\n        external\\n        view\\n        returns (\\n            address[] memory _delegateAddresses,\\n            uint256[] memory _bips,\\n            uint256 _count,\\n            uint256 _delegationMode\\n        );\\n\\n    /**\\n     * The VPToken (or some other contract) that owns this VPContract.\\n     * All state changing methods may be called only from this address.\\n     * This is because original msg.sender is sent in `_from` parameter\\n     * and we must be sure that it cannot be faked by directly calling VPContract.\\n     * Owner token is also used in case of replacement to recover vote powers from balances.\\n     */\\n    function ownerToken() external view returns (IVPToken);\\n\\n    /**\\n     * Return true if this IIVPContract is configured to be used as a replacement for other contract.\\n     * It means that vote powers are not necessarily correct at the initialization, therefore\\n     * every method that reads vote power must check whether it is initialized for that address and block.\\n     */\\n    function isReplacement() external view returns (bool);\\n}\\n\",\"keccak256\":\"0x0ab3bf233248cc7f26e42e7a58cdc2f806059ce920e71f870de1d585c32250ea\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/token/interfaces/IIVPToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"../../IVPToken.sol\\\";\\nimport \\\"../../IGovernanceVotePower.sol\\\";\\nimport \\\"./IIVPContract.sol\\\";\\nimport \\\"./IIGovernanceVotePower.sol\\\";\\nimport \\\"./IICleanable.sol\\\";\\n\\ninterface IIVPToken is IVPToken, IICleanable {\\n    /**\\n     * Set the contract that is allowed to set cleanupBlockNumber.\\n     * Usually this will be an instance of CleanupBlockNumberManager.\\n     */\\n    function setCleanupBlockNumberManager(\\n        address _cleanupBlockNumberManager\\n    ) external;\\n\\n    /**\\n     * Sets new governance vote power contract that allows token owners to participate in governance voting\\n     * and delegate governance vote power.\\n     */\\n    function setGovernanceVotePower(\\n        IIGovernanceVotePower _governanceVotePower\\n    ) external;\\n\\n    /**\\n     * @notice Get the total vote power at block `_blockNumber` using cache.\\n     *   It tries to read the cached value and if not found, reads the actual value and stores it in cache.\\n     *   Can only be used if `_blockNumber` is in the past, otherwise reverts.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return The total vote power at the block (sum of all accounts' vote powers).\\n     */\\n    function totalVotePowerAtCached(\\n        uint256 _blockNumber\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Get the vote power of `_owner` at block `_blockNumber` using cache.\\n     *   It tries to read the cached value and if not found, reads the actual value and stores it in cache.\\n     *   Can only be used if _blockNumber is in the past, otherwise reverts.\\n     * @param _owner The address to get voting power.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return Vote power of `_owner` at `_blockNumber`.\\n     */\\n    function votePowerOfAtCached(\\n        address _owner,\\n        uint256 _blockNumber\\n    ) external returns (uint256);\\n\\n    /**\\n     * Return vote powers for several addresses in a batch.\\n     * @param _owners The list of addresses to fetch vote power of.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return A list of vote powers.\\n     */\\n    function batchVotePowerOfAt(\\n        address[] memory _owners,\\n        uint256 _blockNumber\\n    ) external view returns (uint256[] memory);\\n}\\n\",\"keccak256\":\"0x28c253d67eff699918a126af4195a69e86203db964570b22088392302f9e2e64\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"keccak256\":\"0xc6a8ff0ea489379b61faa647490411b80102578440ab9d84e9a957cc12164e70\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x4296879f55019b23e135000eb36896057e7101fb7fb859c5ef690cf14643757b\",\"license\":\"MIT\"},\"contracts/DegenDuel.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport { TestFtsoV2Interface } from \\\"@flarenetwork/flare-periphery-contracts/coston2/TestFtsoV2Interface.sol\\\";\\nimport { ContractRegistry } from \\\"@flarenetwork/flare-periphery-contracts/coston2/ContractRegistry.sol\\\";\\nimport { RandomNumberV2Interface } from \\\"@flarenetwork/flare-periphery-contracts/coston2/RandomNumberV2Interface.sol\\\";\\nimport { IFdcVerification } from \\\"@flarenetwork/flare-periphery-contracts/coston2/IFdcVerification.sol\\\";\\nimport { IWeb2Json } from \\\"@flarenetwork/flare-periphery-contracts/coston2/IWeb2Json.sol\\\";\\n\\n/**\\n * @title DegenDuel\\n * @notice PvP prediction duel game using all 3 Flare protocols: FTSO + FDC + RNG\\n * @dev Built for ETH Oxford 2026 hackathon on Coston2 testnet\\n */\\ncontract DegenDuel {\\n    // ============ Types ============\\n\\n    enum DuelType { PRICE, DATA }\\n    enum DuelStatus { OPEN, ACTIVE, SETTLED, CANCELLED, EXPIRED }\\n\\n    struct Duel {\\n        uint256 id;\\n        DuelType duelType;\\n        DuelStatus status;\\n        address playerA;\\n        address playerB;\\n        uint256 stakeAmount;\\n        uint256 deadline;\\n        bool playerAPrediction; // true = \\\"above threshold\\\"\\n        address winner;\\n        // PRICE duel fields\\n        bytes21 feedId;\\n        uint256 priceThreshold;\\n        int8 priceDecimals;\\n        // DATA duel fields (settled via FDC Web2Json)\\n        uint256 dataThreshold;\\n        // Settlement data\\n        uint256 settledValue;\\n        uint256 payout;\\n        bool bonusApplied;\\n    }\\n\\n    // ============ State ============\\n\\n    uint256 public nextDuelId;\\n    mapping(uint256 => Duel) public duels;\\n    uint256[] public openDuelIds;\\n    uint256[] public activeDuelIds;\\n    mapping(address => uint256[]) public playerDuels;\\n    mapping(address => uint256) public playerWins;\\n    mapping(address => uint256) public playerEarnings;\\n\\n    uint256 public constant PROTOCOL_FEE_BPS = 100; // 1%\\n    uint256 public constant BONUS_CHANCE = 10; // 10% chance of 2x via RNG\\n    uint256 public constant MIN_STAKE = 0.01 ether;\\n    uint256 public constant MAX_DURATION = 7 days;\\n\\n    address public immutable owner;\\n    uint256 public protocolFeePool;\\n    uint256 public totalDuelsCreated;\\n    uint256 public totalDuelsSettled;\\n    uint256 public totalVolume;\\n\\n    // ============ Events ============\\n\\n    event DuelCreated(\\n        uint256 indexed duelId,\\n        address indexed creator,\\n        DuelType duelType,\\n        uint256 stakeAmount,\\n        uint256 deadline,\\n        bytes21 feedId,\\n        uint256 threshold,\\n        bool prediction\\n    );\\n\\n    event DuelJoined(uint256 indexed duelId, address indexed joiner);\\n\\n    event DuelSettled(\\n        uint256 indexed duelId,\\n        address indexed winner,\\n        uint256 payout,\\n        uint256 settledValue,\\n        bool bonusApplied\\n    );\\n\\n    event DuelCancelled(uint256 indexed duelId);\\n    event DuelExpired(uint256 indexed duelId);\\n\\n    event PriceRead(\\n        uint256 indexed duelId,\\n        bytes21 feedId,\\n        uint256 value,\\n        int8 decimals,\\n        uint64 timestamp\\n    );\\n\\n    event BonusTriggered(uint256 indexed duelId, uint256 randomNumber);\\n\\n    // ============ Constructor ============\\n\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n\\n    // ============ Duel Creation ============\\n\\n    /// @notice Create a price-based duel settled by FTSO\\n    function createPriceDuel(\\n        bytes21 feedId,\\n        uint256 priceThreshold,\\n        int8 priceDecimals,\\n        uint256 deadline,\\n        bool prediction\\n    ) external payable returns (uint256 duelId) {\\n        require(msg.value >= MIN_STAKE, \\\"Stake too low\\\");\\n        require(deadline > block.timestamp, \\\"Deadline must be in the future\\\");\\n        require(deadline <= block.timestamp + MAX_DURATION, \\\"Deadline too far\\\");\\n\\n        duelId = nextDuelId++;\\n        Duel storage d = duels[duelId];\\n        d.id = duelId;\\n        d.duelType = DuelType.PRICE;\\n        d.status = DuelStatus.OPEN;\\n        d.playerA = msg.sender;\\n        d.stakeAmount = msg.value;\\n        d.deadline = deadline;\\n        d.playerAPrediction = prediction;\\n        d.feedId = feedId;\\n        d.priceThreshold = priceThreshold;\\n        d.priceDecimals = priceDecimals;\\n\\n        openDuelIds.push(duelId);\\n        playerDuels[msg.sender].push(duelId);\\n        totalDuelsCreated++;\\n\\n        emit DuelCreated(duelId, msg.sender, DuelType.PRICE, msg.value, deadline, feedId, priceThreshold, prediction);\\n    }\\n\\n    /// @notice Create a data-based duel settled by FDC Web2Json proof\\n    function createDataDuel(\\n        uint256 dataThreshold,\\n        uint256 deadline,\\n        bool prediction\\n    ) external payable returns (uint256 duelId) {\\n        require(msg.value >= MIN_STAKE, \\\"Stake too low\\\");\\n        require(deadline > block.timestamp, \\\"Deadline must be in the future\\\");\\n        require(deadline <= block.timestamp + MAX_DURATION, \\\"Deadline too far\\\");\\n\\n        duelId = nextDuelId++;\\n        Duel storage d = duels[duelId];\\n        d.id = duelId;\\n        d.duelType = DuelType.DATA;\\n        d.status = DuelStatus.OPEN;\\n        d.playerA = msg.sender;\\n        d.stakeAmount = msg.value;\\n        d.deadline = deadline;\\n        d.playerAPrediction = prediction;\\n        d.dataThreshold = dataThreshold;\\n\\n        openDuelIds.push(duelId);\\n        playerDuels[msg.sender].push(duelId);\\n        totalDuelsCreated++;\\n\\n        emit DuelCreated(duelId, msg.sender, DuelType.DATA, msg.value, deadline, bytes21(0), dataThreshold, prediction);\\n    }\\n\\n    // ============ Duel Joining ============\\n\\n    /// @notice Join an open duel (takes the opposite prediction)\\n    function joinDuel(uint256 duelId) external payable {\\n        Duel storage d = duels[duelId];\\n        require(d.status == DuelStatus.OPEN, \\\"Duel not open\\\");\\n        require(msg.sender != d.playerA, \\\"Cannot join own duel\\\");\\n        require(msg.value == d.stakeAmount, \\\"Must match stake\\\");\\n        require(block.timestamp < d.deadline, \\\"Duel expired\\\");\\n\\n        d.playerB = msg.sender;\\n        d.status = DuelStatus.ACTIVE;\\n\\n        _removeFromOpenDuels(duelId);\\n        activeDuelIds.push(duelId);\\n        playerDuels[msg.sender].push(duelId);\\n        totalVolume += d.stakeAmount * 2;\\n\\n        emit DuelJoined(duelId, msg.sender);\\n    }\\n\\n    // ============ Settlement ============\\n\\n    /// @notice Settle a price duel by reading current FTSO price\\n    function settlePriceDuel(uint256 duelId) external {\\n        Duel storage d = duels[duelId];\\n        require(d.status == DuelStatus.ACTIVE, \\\"Duel not active\\\");\\n        require(d.duelType == DuelType.PRICE, \\\"Not a price duel\\\");\\n        require(block.timestamp >= d.deadline, \\\"Too early to settle\\\");\\n\\n        // Read FTSO price\\n        TestFtsoV2Interface ftsoV2 = ContractRegistry.getTestFtsoV2();\\n        (uint256 feedValue, int8 feedDecimals, uint64 feedTimestamp) = ftsoV2.getFeedById(d.feedId);\\n\\n        emit PriceRead(duelId, d.feedId, feedValue, feedDecimals, feedTimestamp);\\n\\n        // Normalize both values to same decimal scale for comparison\\n        uint256 normalizedFeed = _normalize(feedValue, feedDecimals);\\n        uint256 normalizedThreshold = _normalize(d.priceThreshold, d.priceDecimals);\\n\\n        bool conditionMet = normalizedFeed >= normalizedThreshold;\\n        d.settledValue = feedValue;\\n\\n        _settleDuel(d, conditionMet);\\n    }\\n\\n    /// @notice Settle a data duel with a verified FDC Web2Json proof\\n    function settleDataDuel(\\n        uint256 duelId,\\n        IWeb2Json.Proof calldata proof\\n    ) external {\\n        Duel storage d = duels[duelId];\\n        require(d.status == DuelStatus.ACTIVE, \\\"Duel not active\\\");\\n        require(d.duelType == DuelType.DATA, \\\"Not a data duel\\\");\\n        require(block.timestamp >= d.deadline, \\\"Too early to settle\\\");\\n\\n        // Verify the FDC proof\\n        IFdcVerification fdcVerification = ContractRegistry.getFdcVerification();\\n        require(fdcVerification.verifyWeb2Json(proof), \\\"Invalid FDC proof\\\");\\n\\n        // Decode the attested value (expecting a single uint256 named \\\"value\\\")\\n        uint256 attestedValue = abi.decode(proof.data.responseBody.abiEncodedData, (uint256));\\n        d.settledValue = attestedValue;\\n\\n        bool conditionMet = attestedValue >= d.dataThreshold;\\n        _settleDuel(d, conditionMet);\\n    }\\n\\n    // ============ Cancellation / Expiry ============\\n\\n    /// @notice Cancel an open duel (creator only, before anyone joins)\\n    function cancelDuel(uint256 duelId) external {\\n        Duel storage d = duels[duelId];\\n        require(d.status == DuelStatus.OPEN, \\\"Duel not open\\\");\\n        require(msg.sender == d.playerA, \\\"Only creator can cancel\\\");\\n\\n        d.status = DuelStatus.CANCELLED;\\n        _removeFromOpenDuels(duelId);\\n\\n        // Refund creator\\n        payable(d.playerA).transfer(d.stakeAmount);\\n\\n        emit DuelCancelled(duelId);\\n    }\\n\\n    /// @notice Expire a duel that passed deadline + 24h without settlement\\n    function expireDuel(uint256 duelId) external {\\n        Duel storage d = duels[duelId];\\n        require(d.status == DuelStatus.ACTIVE, \\\"Duel not active\\\");\\n        require(block.timestamp > d.deadline + 1 days, \\\"Grace period not over\\\");\\n\\n        d.status = DuelStatus.EXPIRED;\\n        _removeFromActiveDuels(duelId);\\n\\n        // Refund both players\\n        payable(d.playerA).transfer(d.stakeAmount);\\n        payable(d.playerB).transfer(d.stakeAmount);\\n\\n        emit DuelExpired(duelId);\\n    }\\n\\n    // ============ View Functions ============\\n\\n    /// @notice Get current FTSO price for a feed (for UI display)\\n    function getCurrentPrice(bytes21 feedId)\\n        external view returns (uint256 value, int8 decimals, uint64 timestamp)\\n    {\\n        TestFtsoV2Interface ftsoV2 = ContractRegistry.getTestFtsoV2();\\n        return ftsoV2.getFeedById(feedId);\\n    }\\n\\n    /// @notice Get multiple FTSO prices at once (for UI ticker)\\n    function getPrices(bytes21[] calldata feedIds)\\n        external view returns (uint256[] memory values, int8[] memory decimals, uint64 timestamp)\\n    {\\n        TestFtsoV2Interface ftsoV2 = ContractRegistry.getTestFtsoV2();\\n        return ftsoV2.getFeedsById(feedIds);\\n    }\\n\\n    /// @notice Get a random number from Flare's Secure RNG\\n    function getRandomNumber()\\n        external view returns (uint256 randomNumber, bool isSecure, uint256 randomTimestamp)\\n    {\\n        RandomNumberV2Interface rng = ContractRegistry.getRandomNumberV2();\\n        return rng.getRandomNumber();\\n    }\\n\\n    /// @notice Get a single duel by ID\\n    function getDuel(uint256 duelId) external view returns (Duel memory) {\\n        return duels[duelId];\\n    }\\n\\n    /// @notice Get all open duels\\n    function getOpenDuels() external view returns (Duel[] memory) {\\n        Duel[] memory result = new Duel[](openDuelIds.length);\\n        for (uint256 i = 0; i < openDuelIds.length; i++) {\\n            result[i] = duels[openDuelIds[i]];\\n        }\\n        return result;\\n    }\\n\\n    /// @notice Get all active duels\\n    function getActiveDuels() external view returns (Duel[] memory) {\\n        Duel[] memory result = new Duel[](activeDuelIds.length);\\n        for (uint256 i = 0; i < activeDuelIds.length; i++) {\\n            result[i] = duels[activeDuelIds[i]];\\n        }\\n        return result;\\n    }\\n\\n    /// @notice Get duels for a specific player\\n    function getPlayerDuels(address player) external view returns (Duel[] memory) {\\n        uint256[] memory ids = playerDuels[player];\\n        Duel[] memory result = new Duel[](ids.length);\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            result[i] = duels[ids[i]];\\n        }\\n        return result;\\n    }\\n\\n    /// @notice Get player stats for leaderboard\\n    function getPlayerStats(address player)\\n        external view returns (uint256 wins, uint256 earnings)\\n    {\\n        return (playerWins[player], playerEarnings[player]);\\n    }\\n\\n    /// @notice Get protocol stats\\n    function getProtocolStats()\\n        external view returns (uint256 created, uint256 settled, uint256 volume, uint256 fees)\\n    {\\n        return (totalDuelsCreated, totalDuelsSettled, totalVolume, protocolFeePool);\\n    }\\n\\n    // ============ Admin ============\\n\\n    /// @notice Withdraw accumulated protocol fees\\n    function withdrawFees() external {\\n        require(msg.sender == owner, \\\"Only owner\\\");\\n        uint256 amount = protocolFeePool;\\n        protocolFeePool = 0;\\n        payable(owner).transfer(amount);\\n    }\\n\\n    // ============ Internal ============\\n\\n    function _settleDuel(Duel storage d, bool conditionMet) internal {\\n        // Determine winner\\n        // playerA predicted conditionMet (prediction = true means \\\"above\\\")\\n        // playerB automatically took the opposite\\n        address winner;\\n        if (conditionMet == d.playerAPrediction) {\\n            winner = d.playerA;\\n        } else {\\n            winner = d.playerB;\\n        }\\n\\n        uint256 totalPot = d.stakeAmount * 2;\\n        uint256 fee = (totalPot * PROTOCOL_FEE_BPS) / 10000;\\n        uint256 winnerPayout = totalPot - fee;\\n        bool bonusApplied = false;\\n\\n        // RNG bonus check (10% chance of 2x \\u2014 fee is waived for bonus)\\n        try ContractRegistry.getRandomNumberV2().getRandomNumber() returns (\\n            uint256 randomNumber, bool isSecure, uint256\\n        ) {\\n            if (isSecure && (randomNumber % 100) < BONUS_CHANCE) {\\n                // Bonus! Winner gets full pot (no fee taken)\\n                winnerPayout = totalPot;\\n                fee = 0;\\n                bonusApplied = true;\\n                emit BonusTriggered(d.id, randomNumber);\\n            }\\n        } catch {\\n            // RNG failed, proceed without bonus\\n        }\\n\\n        d.winner = winner;\\n        d.status = DuelStatus.SETTLED;\\n        d.payout = winnerPayout;\\n        d.bonusApplied = bonusApplied;\\n        protocolFeePool += fee;\\n        totalDuelsSettled++;\\n\\n        playerWins[winner]++;\\n        playerEarnings[winner] += winnerPayout;\\n\\n        _removeFromActiveDuels(d.id);\\n\\n        // Transfer winnings\\n        payable(winner).transfer(winnerPayout);\\n\\n        emit DuelSettled(d.id, winner, winnerPayout, d.settledValue, bonusApplied);\\n    }\\n\\n    /// @notice Normalize a value to 18 decimals for comparison\\n    function _normalize(uint256 value, int8 decimals) internal pure returns (uint256) {\\n        if (decimals >= 0) {\\n            uint8 d = uint8(int8(18) - decimals);\\n            return value * (10 ** d);\\n        } else {\\n            uint8 d = uint8(int8(18) + (-decimals));\\n            return value * (10 ** d);\\n        }\\n    }\\n\\n    function _removeFromOpenDuels(uint256 duelId) internal {\\n        for (uint256 i = 0; i < openDuelIds.length; i++) {\\n            if (openDuelIds[i] == duelId) {\\n                openDuelIds[i] = openDuelIds[openDuelIds.length - 1];\\n                openDuelIds.pop();\\n                return;\\n            }\\n        }\\n    }\\n\\n    function _removeFromActiveDuels(uint256 duelId) internal {\\n        for (uint256 i = 0; i < activeDuelIds.length; i++) {\\n            if (activeDuelIds[i] == duelId) {\\n                activeDuelIds[i] = activeDuelIds[activeDuelIds.length - 1];\\n                activeDuelIds.pop();\\n                return;\\n            }\\n        }\\n    }\\n\\n    receive() external payable {}\\n}\\n\",\"keccak256\":\"0x17acedb98929285e1e5b9a7754c84a4cb7b2f2ef7b8b7f3c5801bd5ec2a871b9\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a08060405234602957336080526128b8908161002f82396080518181816111210152611cec0152f35b600080fdfe608080604052600436101561001d575b50361561001b57600080fd5b005b60003560e01c90816292823b14611dbc575080630902a10814611d935780633ad38d8e14611d75578063476343ee14611cd95780634fd66eae14611c8d578063549ec61414611c6f578063565e614f14611b3c5780635f81a57c14611b1e57806368084e0e146119bc57806369f92773146119825780637409cdbd146117bd578063771aceef146117865780637f5637a9146115bb578063813b5db614611455578063859a62d01461133d5780638b31fb89146113035780638c58d6c0146112e55780638cc4b741146111505780638da5cb5b1461110b5780638fc5d90314610fbe578063a908f02114610ef8578063b1724b4614610eda578063be37822814610ebe578063cb1c2b5c14610e9c578063d2884ea714610e80578063d9c312f414610d79578063dbdff2c114610ce2578063e63f627214610a4e578063e8097b7e1461085b578063eb3323f114610709578063ed3f44dc146106bf578063f122093e146101d15763f7fbc66314610194573861000f565b346101cc5760203660031901126101cc576004356002548110156101cc576101bd602091611e08565b90549060031b1c604051908152f35b600080fd5b346101cc5760403660031901126101cc576024356001600160401b0381116101cc5780360360406003198201126101cc576004356000526001602052604060002090600182015460ff8160081c169060058210156106a957610237600160ff93146120d7565b1660028110156106a957600103610672576102586004830154421015612115565b604051602081019060208252600f60408201526e233231ab32b934b334b1b0ba34b7b760891b606082015260608152610292608082611fc6565b51902060405190630ac9aa5160e11b8252600482015260208160248173ad67fe66660fb8dfe9d6b1b4240d8650e30f60195afa90811561063757600091610643575b5060405190630aa05fe360e01b825260206004830152846004013560221984018112156101cc5785016024600482013591016001600160401b0382116101cc578160051b9182360382136101cc5760406024860152606485018190526001600160fb1b03106101cc578190608485013782019060248601359360c219018412156101cc578584019060231960848585030101604485015260048201356084840152602482013560a48401526001600160401b0361039360448401612343565b1660c48401526001600160401b036103ad60648401612343565b1660e48401526084820135600319833603019060de1982018112156101cc576004846104da92010160c06101048701526104c66104bb61049a6104796104586104376104128c6102246104008a80612357565b91909260e06101448201520191612388565b8c61042060208a018a612357565b610143198385030161016490930192909252612388565b6104446040880188612357565b610143198e8403016101848f015290612388565b6104656060870187612357565b610143198d8403016101a48e015290612388565b6104866080860186612357565b610143198c8403016101c48d015290612388565b6104a760a0850185612357565b610143198b8403016101e48c015290612388565b9160c0810190612357565b610143198884030161020489015290612388565b9260a481013591601e19018212156101cc57610522869460206105158198600489979688970101906101246083198287030191015280612357565b9190928181520191612388565b03916001600160a01b03165afa908115610637576000916105fd575b50156105c4576000920160a481013560221936839003018112156105c0576004910101803590601e19813603018212156105c057019081356001600160401b0381116105c057602083019281360384136105bc57602091810103126105b8576105b5913580600a83015560098201541115906124dc565b80f35b8280fd5b8480fd5b8380fd5b60405162461bcd60e51b815260206004820152601160248201527024b73b30b634b21023222190383937b7b360791b6044820152606490fd5b90506020813d60201161062f575b8161061860209383611fc6565b810103126101cc5761062990612301565b8461053e565b3d915061060b565b6040513d6000823e3d90fd5b610665915060203d60201161066b575b61065d8183611fc6565b8101906123a9565b846102d4565b503d610653565b60405162461bcd60e51b815260206004820152600f60248201526e139bdd08184819185d1848191d595b608a1b6044820152606490fd5b634e487b7160e01b600052602160045260246000fd5b346101cc5760403660031901126101cc576106d8611e3b565b6001600160a01b03166000908152600460205260409020805460243591908210156101cc576020916101bd91611e23565b346101cc5760203660031901126101cc5760043580600052600160205260406000206001810160ff815460081c1660058110156106a957600161074c91146120d7565b60048201546201518081018091116108455742111561080857805461ff00191661040017815561077b8361280c565b5460038201805490929160009182918291829160101c6001600160a01b03168282156107ff575bf11561063757600201549054600091829182918291906001600160a01b03168282156107f6575bf115610637577f82dca6171073e896c9a2e2206c0cf7d1499202cf0e22e05bc934dcdc5d54caae600080a2005b506108fc6107c9565b506108fc6107a2565b60405162461bcd60e51b815260206004820152601560248201527423b930b1b2903832b934b7b2103737ba1037bb32b960591b6044820152606490fd5b634e487b7160e01b600052601160045260246000fd5b60203660031901126101cc57600435806000526001602052604060002060018101805460ff8160081c1660058110156106a95761089890156122c5565b3360109190911c6001600160a01b031614610a12576003820191825434036109da5760048101544210156109a65760020180546001600160a01b03191633179055805461ff0019166101001790556108ef82612731565b600354600160401b811015610990578261091482600161092d94016003556003611e23565b90919082549060031b91821b91600019901b1916179055565b3360005260046020526109448260406000206122a2565b548060011b90808204600214901517156108455761096490600a54612220565b600a5533907f2be0d3826f37a8de3c1b301652c7dab4429fc3dfe5685e6ce0947666cb32401d600080a3005b634e487b7160e01b600052604160045260246000fd5b60405162461bcd60e51b815260206004820152600c60248201526b111d595b08195e1c1a5c995960a21b6044820152606490fd5b60405162461bcd60e51b815260206004820152601060248201526f4d757374206d61746368207374616b6560801b6044820152606490fd5b60405162461bcd60e51b815260206004820152601460248201527310d85b9b9bdd081a9bda5b881bdddb88191d595b60621b6044820152606490fd5b346101cc5760203660031901126101cc576004356001600160401b0381116101cc57366023820112156101cc578060040135906001600160401b0382116101cc573660248360051b830101116101cc57906001600160a01b03610aaf6123c8565b1690604051928391634c37574560e01b8352806024840160206004860152526024604484019201906000905b808210610cb25750505091818060009403915afa9081156106375760009081908293610b8f575b50604051916060830160608452815180915260206080850192019060005b818110610b795750505082810360208401526020808351928381520192019060005b818110610b60575050506001600160401b0382931660408301520390f35b825160000b845260209384019390920191600101610b42565b8251845260209384019390920191600101610b20565b919250503d8083833e610ba28183611fc6565b8101906060818303126105b85780516001600160401b0381116105c05781019282601f85011215610caf57835193610bd98561205c565b94610be76040519687611fc6565b80865260208087019160051b830101918583116105c057602001905b828210610c9f5750505060208201516001600160401b038111610c9b5782019280601f85011215610c9b57835191610c3a8361205c565b94610c486040519687611fc6565b83865260208087019460051b820101928311610c9b57602001925b828410610c8257505050506040610c7a9101612157565b919083610b02565b835180830b81036105b857815260209384019301610c63565b5080fd5b8151815260209182019101610c03565b80fd5b919350918335906001600160581b031982168092036101cc57602081600193829352019401920185939291610adb565b346101cc5760003660031901126101cc57600460606001600160a01b03610d076127d3565b166040519283809263dbdff2c160e01b82525afa90811561063757606091600091600090600092610d48575b50604051928352151560208301526040820152f35b915050610d6b9150823d8411610d72575b610d638183611fc6565b81019061230e565b9084610d33565b503d610d59565b346101cc5760203660031901126101cc57600435806000526001602052604060002060018101805460ff8160081c1660058110156106a957610dbb90156122c5565b60101c6001600160a01b03163303610e3b5760008080936003829461030061ff0019825416178155610dec88612731565b549101549060101c6001600160a01b0316828215610e32575bf115610637577fe6869595d58c61aa991d00acb41ac260a2d3b5a40d58255f6aad94a14c2804a7600080a2005b506108fc610e05565b60405162461bcd60e51b815260206004820152601760248201527f4f6e6c792063726561746f722063616e2063616e63656c0000000000000000006044820152606490fd5b346101cc5760003660031901126101cc576020604051600a8152f35b346101cc5760003660031901126101cc576020604051662386f26fc100008152f35b346101cc5760003660031901126101cc57602060405160648152f35b346101cc5760003660031901126101cc57602060405162093a808152f35b346101cc5760203660031901126101cc57610f11611f93565b60606001600160a01b03610f236123c8565b6040516349f4fc0360e11b81526001600160581b0319909416600485015283916024918391165afa9081156106375760609160009060008091610f82575b6001600160401b0392935060405193845260000b6020840152166040820152f35b505050610fac6001600160401b0391833d8511610fb7575b610fa48183611fc6565b81019061216b565b919250829190610f61565b503d610f9a565b60603660031901126101cc576024356044356004358115158083036101cc57610ff0662386f26fc10000341015612198565b610ffb4285116121d4565b62093a804201804211610845576110149085111561222d565b816009600054946110248661226c565b600090815586815260016020819052604090912087815580820180546001600160b01b0319163360101b62010000600160b01b0316179092179091559061108690346003840155886004840155600583019060ff801983541691151516179055565b01556110918361227b565b3360005260046020526110a88360406000206122a2565b6110b360085461226c565b60085560405191602094600184523486850152604084015260006060840152608083015260a0820152817fb320c7ddf7489cbe7ffa5dcf55b40f9a4a5603bbd4b903a38e148b37370f95c160c03393a3604051908152f35b346101cc5760003660031901126101cc576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b60a03660031901126101cc57611164611f93565b602435604435918260000b83036101cc576064359260843592831515918285036101cc5761119b662386f26fc10000341015612198565b6111a64287116121d4565b62093a804201804211610845576111bf9087111561222d565b6008600054956111ce8761226c565b600090815587815260016020819052604090912088815590810180546001600160b01b0319163360101b62010000600160b01b03161790559061122c90346003840155896004840155600583019060ff801983541691151516179055565b600681018660581c6001600160581b0360a81b825416179055836007820155019060ff198254169060ff161790556112638461227b565b33600052600460205261127a8460406000206122a2565b61128560085461226c565b6008556040519260209560008552348786015260408501526001600160581b0319166060840152608083015260a0820152817fb320c7ddf7489cbe7ffa5dcf55b40f9a4a5603bbd4b903a38e148b37370f95c160c03393a3604051908152f35b346101cc5760003660031901126101cc576020600954604051908152f35b346101cc5760203660031901126101cc576001600160a01b03611324611e3b565b1660005260056020526020604060002054604051908152f35b346101cc5760203660031901126101cc576004356000526001602052610200604060002080549060018101549060018060a01b03600282015416600382015460048301546005840154600685015460581b600786015491600887015460000b93600988015495600a8901549760ff600c600b8c01549b0154169a6113e0604080519e8f9081526113d36020820160ff8616611e51565b0160ff8360081c16611e5e565b60018060a01b039060101c1660608d015260808c015260a08b015260c08a015260ff8116151560e08a015260018060a01b039060081c166101008901526001600160581b0319166101208801526101408701526101608601526101808501526101a08401526101c083015215156101e0820152f35b346101cc5760003660031901126101cc5760035461147281612073565b9060005b81811061148f576040518061148b8582611f4e565b0390f35b61149881611dd7565b90549060031b1c60005260016020526040600020906040516114b981611faa565b82548152600183015460ff811660028110156106a957602083015260ff8160081c1660058110156106a957604083015260101c6001600160a01b039081166060830152600284015481166080830152600384015460a0830152600484015460c0830152600584015460ff818116151560e0850152600891821c909216610100840152600685015460581b6001600160581b031916610120840152600785015461014084015284015460000b6101608301526009840154610180830152600a8401546101a0830152600b8401546101c0830152600c9093015490921615156101e08301526001916115a982866120c3565b526115b481856120c3565b5001611476565b346101cc5760203660031901126101cc576004358060005260016020526040600020600181015460ff8160081c169060058210156106a957611601600160ff93146120d7565b1660028110156106a95761174e578061162260046024930154421015612115565b6001600160a01b036116326123c8565b16906060600682015460581b604051948580926349f4fc0360e11b82526001600160581b031916958660048301525afa80156106375761001b94600093849285906116f1575b6116ce949596507fac39fb998ad2f116dd95803aee3846757c502771d55ac04dd2943850cfcddf37916001600160401b036080926040519283528960208401528660000b6040840152166060820152a283612478565b6116e46007830154600884015460000b90612478565b111591600a8201556124dc565b5091506116ce9293507fac39fb998ad2f116dd95803aee3846757c502771d55ac04dd2943850cfcddf37608061173d6001600160401b039760603d606011610fb757610fa48183611fc6565b919850889796509492509050611678565b60405162461bcd60e51b815260206004820152601060248201526f139bdd0818481c1c9a58d948191d595b60821b6044820152606490fd5b346101cc5760003660031901126101cc576080600854600954600a5460075491604051938452602084015260408301526060820152f35b346101cc5760203660031901126101cc576001600160a01b036117de611e3b565b16600052600460205260406000206040518082602082945493848152019060005260206000209260005b81811061196957505061181d92500382611fc6565b6118278151612073565b9060005b815181101561195b5761183e81836120c3565b51600052600160205260406000209060405161185981611faa565b82548152600183015460ff811660028110156106a957602083015260ff8160081c1660058110156106a957604083015260101c6001600160a01b039081166060830152600284015481166080830152600384015460a0830152600484015460c0830152600584015460ff818116151560e0850152600891821c909216610100840152600685015460581b6001600160581b031916610120840152600785015461014084015284015460000b6101608301526009840154610180830152600a8401546101a0830152600b8401546101c0830152600c9093015490921615156101e083015260019161194982866120c3565b5261195481856120c3565b500161182b565b6040518061148b8582611f4e565b8454835260019485019486945060209093019201611808565b346101cc5760203660031901126101cc576001600160a01b036119a3611e3b565b1660005260066020526020604060002054604051908152f35b346101cc5760003660031901126101cc576002546119d981612073565b9060005b8181106119f2576040518061148b8582611f4e565b6119fb81611e08565b90549060031b1c6000526001602052604060002090604051611a1c81611faa565b82548152600183015460ff811660028110156106a957602083015260ff8160081c1660058110156106a957604083015260101c6001600160a01b039081166060830152600284015481166080830152600384015460a0830152600484015460c0830152600584015460ff818116151560e0850152600891821c909216610100840152600685015460581b6001600160581b031916610120840152600785015461014084015284015460000b6101608301526009840154610180830152600a8401546101a0830152600b8401546101c0830152600c9093015490921615156101e0830152600191611b0c82866120c3565b52611b1781856120c3565b50016119dd565b346101cc5760003660031901126101cc576020600a54604051908152f35b346101cc5760203660031901126101cc57611b55611fe7565b5060043560005260016020526040600020604051611b7281611faa565b81548152600182015460ff811660028110156106a957602083015260ff8160081c1660058110156106a95760408381019190915260109190911c6001600160a01b039081166060840152600284015481166080840152600384015460a0840152600484015460c0840152600584015460ff818116151560e0860152600891821c909216610100850152600685015460581b6001600160581b031916610120850152600785015461014085015284015460000b6101608401526009840154610180840152600a8401546101a0840152600b8401546101c0840152600c9093015490921615156101e0820152905161020091611c6d908290611e6b565bf35b346101cc5760003660031901126101cc576020600054604051908152f35b346101cc5760203660031901126101cc5760406001600160a01b03611cb0611e3b565b168060005260056020528160002054906000526006602052816000205482519182526020820152f35b346101cc5760003660031901126101cc577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031633819003611d43576000808080936007549082600755828215611d3a575bf11561063757005b506108fc611d32565b60405162461bcd60e51b815260206004820152600a60248201526927b7363c9037bbb732b960b11b6044820152606490fd5b346101cc5760003660031901126101cc576020600754604051908152f35b346101cc5760203660031901126101cc576004356003548110156101cc576101bd602091611dd7565b346101cc5760003660031901126101cc576020906008548152f35b600354811015611df257600360005260206000200190600090565b634e487b7160e01b600052603260045260246000fd5b600254811015611df257600260005260206000200190600090565b8054821015611df25760005260206000200190600090565b600435906001600160a01b03821682036101cc57565b9060028210156106a95752565b9060058210156106a95752565b6101e0809180518452611e8660208201516020860190611e51565b611e9860408201516040860190611e5e565b60018060a01b03606082015116606085015260018060a01b03608082015116608085015260a081015160a085015260c081015160c085015260e0810151151560e085015260018060a01b03610100820151166101008501526001600160581b03196101208201511661012085015261014081015161014085015261016081015160000b6101608501526101808101516101808501526101a08101516101a08501526101c08101516101c085015201511515910152565b602060408183019282815284518094520192019060005b818110611f725750505090565b909192602061020082611f886001948851611e6b565b019401929101611f65565b600435906001600160581b0319821682036101cc57565b61020081019081106001600160401b0382111761099057604052565b90601f801991011681019081106001600160401b0382111761099057604052565b60405190611ff482611faa565b60006101e0838281528260208201528260408201528260608201528260808201528260a08201528260c08201528260e08201528261010082015282610120820152826101408201528261016082015282610180820152826101a0820152826101c08201520152565b6001600160401b0381116109905760051b60200190565b9061207d8261205c565b61208a6040519182611fc6565b828152809261209b601f199161205c565b019060005b8281106120ac57505050565b6020906120b7611fe7565b828285010152016120a0565b8051821015611df25760209160051b010190565b156120de57565b60405162461bcd60e51b815260206004820152600f60248201526e4475656c206e6f742061637469766560881b6044820152606490fd5b1561211c57565b60405162461bcd60e51b8152602060048201526013602482015272546f6f206561726c7920746f20736574746c6560681b6044820152606490fd5b51906001600160401b03821682036101cc57565b908160609103126101cc5780519160208201518060000b81036101cc576040612195919301612157565b90565b1561219f57565b60405162461bcd60e51b815260206004820152600d60248201526c5374616b6520746f6f206c6f7760981b6044820152606490fd5b156121db57565b60405162461bcd60e51b815260206004820152601e60248201527f446561646c696e65206d75737420626520696e207468652066757475726500006044820152606490fd5b9190820180921161084557565b1561223457565b60405162461bcd60e51b815260206004820152601060248201526f2232b0b23634b732903a37b7903330b960811b6044820152606490fd5b60001981146108455760010190565b60025490600160401b821015610990576109148260016122a094016002556002611e23565b565b90815491600160401b83101561099057826109149160016122a095018155611e23565b156122cc57565b60405162461bcd60e51b815260206004820152600d60248201526c223ab2b6103737ba1037b832b760991b6044820152606490fd5b519081151582036101cc57565b908160609103126101cc57805191604061232a60208401612301565b92015190565b8181029291811591840414171561084557565b35906001600160401b03821682036101cc57565b9035601e19823603018112156101cc5701602081359101916001600160401b0382116101cc5781360383136101cc57565b908060209392818452848401376000828201840152601f01601f1916010190565b908160209103126101cc57516001600160a01b03811681036101cc5790565b6040516020810190602082526006604082015265233a39b7ab1960d11b6060820152606081526123f9608082611fc6565b51902060405190630ac9aa5160e11b8252600482015260208160248173ad67fe66660fb8dfe9d6b1b4240d8650e30f60195afa90811561063757600091612448575b506001600160a01b031690565b612461915060203d60201161066b5761065d8183611fc6565b3861243b565b60ff16604d811161084557600a0a90565b90600090810b9081126124ac5760120390607f198212607f831317610845576124a66121959260ff16612467565b90612330565b607f1981146108455760000360000b60120190607f198212607f831317610845576124a66121959260ff16612467565b6005810180549092151560ff821615150361271d57600182015460101c6001600160a01b0316925b6003830154918260011b92808404600214901517156108455760648302838104606414841517156108455761271090048084038481116108455792600092600460606001600160a01b036125566127d3565b166040519283809263dbdff2c160e01b82525afa80869287926126f8575b50612699575b5050610100600160a81b031916600888901b610100600160a81b031617905560018501805461ff001916610200179055600b8501839055600c8501805483151560ff1660ff19919091161790556001600160a01b039590951694919250906125e490600754612220565b6007556125f260095461226c565b600955836000526005602052604060002061260d815461226c565b90558360005260066020526040600020612628838254612220565b9055612634835461280c565b60008285811561268f575b600092839283928392f115610637577f4188b822aed2fe2a908f2d8372c1bc7f62b375f20b97b99647cf7fde7a45b5d591606091600a8554950154604051928352602083015215156040820152a3565b6108fc925061263f565b806126eb575b6126aa575b8061257a565b945091506125e492916001947f7bbfdbec98dcfb32fd2467c180f1f6de7288b1f166016955d566586367e2ab2f6020895492604051908152a28594936126a4565b50600a606482061061269f565b909250612714915060603d606011610d7257610d638183611fc6565b50909138612574565b60028201546001600160a01b031692612504565b60005b600254808210156127ce578261274983611e08565b90549060031b1c1461275e5750600101612734565b6000198101925082116108455761091461277a61278793611e08565b90549060031b1c91611e08565b60025480156127b857600019016127b36127a2826002611e23565b8154906000199060031b1b19169055565b600255565b634e487b7160e01b600052603160045260246000fd5b505050565b604051602081019060208252600e60408201526d2930b73237b6a73ab6b132b92b1960911b6060820152606081526123f9608082611fc6565b60005b600354808210156127ce578261282483611dd7565b90549060031b1c14612839575060010161280f565b6000198101925082116108455761091461285561286293611dd7565b90549060031b1c91611dd7565b60035480156127b8576000190161287d6127a2826003611e23565b60035556fea2646970667358221220c41f8a659572b578b90df0eeb18a52c5c611f639e5d2adda8d13a57a6178fc2264736f6c634300081e0033",
  "deployedBytecode": "0x608080604052600436101561001d575b50361561001b57600080fd5b005b60003560e01c90816292823b14611dbc575080630902a10814611d935780633ad38d8e14611d75578063476343ee14611cd95780634fd66eae14611c8d578063549ec61414611c6f578063565e614f14611b3c5780635f81a57c14611b1e57806368084e0e146119bc57806369f92773146119825780637409cdbd146117bd578063771aceef146117865780637f5637a9146115bb578063813b5db614611455578063859a62d01461133d5780638b31fb89146113035780638c58d6c0146112e55780638cc4b741146111505780638da5cb5b1461110b5780638fc5d90314610fbe578063a908f02114610ef8578063b1724b4614610eda578063be37822814610ebe578063cb1c2b5c14610e9c578063d2884ea714610e80578063d9c312f414610d79578063dbdff2c114610ce2578063e63f627214610a4e578063e8097b7e1461085b578063eb3323f114610709578063ed3f44dc146106bf578063f122093e146101d15763f7fbc66314610194573861000f565b346101cc5760203660031901126101cc576004356002548110156101cc576101bd602091611e08565b90549060031b1c604051908152f35b600080fd5b346101cc5760403660031901126101cc576024356001600160401b0381116101cc5780360360406003198201126101cc576004356000526001602052604060002090600182015460ff8160081c169060058210156106a957610237600160ff93146120d7565b1660028110156106a957600103610672576102586004830154421015612115565b604051602081019060208252600f60408201526e233231ab32b934b334b1b0ba34b7b760891b606082015260608152610292608082611fc6565b51902060405190630ac9aa5160e11b8252600482015260208160248173ad67fe66660fb8dfe9d6b1b4240d8650e30f60195afa90811561063757600091610643575b5060405190630aa05fe360e01b825260206004830152846004013560221984018112156101cc5785016024600482013591016001600160401b0382116101cc578160051b9182360382136101cc5760406024860152606485018190526001600160fb1b03106101cc578190608485013782019060248601359360c219018412156101cc578584019060231960848585030101604485015260048201356084840152602482013560a48401526001600160401b0361039360448401612343565b1660c48401526001600160401b036103ad60648401612343565b1660e48401526084820135600319833603019060de1982018112156101cc576004846104da92010160c06101048701526104c66104bb61049a6104796104586104376104128c6102246104008a80612357565b91909260e06101448201520191612388565b8c61042060208a018a612357565b610143198385030161016490930192909252612388565b6104446040880188612357565b610143198e8403016101848f015290612388565b6104656060870187612357565b610143198d8403016101a48e015290612388565b6104866080860186612357565b610143198c8403016101c48d015290612388565b6104a760a0850185612357565b610143198b8403016101e48c015290612388565b9160c0810190612357565b610143198884030161020489015290612388565b9260a481013591601e19018212156101cc57610522869460206105158198600489979688970101906101246083198287030191015280612357565b9190928181520191612388565b03916001600160a01b03165afa908115610637576000916105fd575b50156105c4576000920160a481013560221936839003018112156105c0576004910101803590601e19813603018212156105c057019081356001600160401b0381116105c057602083019281360384136105bc57602091810103126105b8576105b5913580600a83015560098201541115906124dc565b80f35b8280fd5b8480fd5b8380fd5b60405162461bcd60e51b815260206004820152601160248201527024b73b30b634b21023222190383937b7b360791b6044820152606490fd5b90506020813d60201161062f575b8161061860209383611fc6565b810103126101cc5761062990612301565b8461053e565b3d915061060b565b6040513d6000823e3d90fd5b610665915060203d60201161066b575b61065d8183611fc6565b8101906123a9565b846102d4565b503d610653565b60405162461bcd60e51b815260206004820152600f60248201526e139bdd08184819185d1848191d595b608a1b6044820152606490fd5b634e487b7160e01b600052602160045260246000fd5b346101cc5760403660031901126101cc576106d8611e3b565b6001600160a01b03166000908152600460205260409020805460243591908210156101cc576020916101bd91611e23565b346101cc5760203660031901126101cc5760043580600052600160205260406000206001810160ff815460081c1660058110156106a957600161074c91146120d7565b60048201546201518081018091116108455742111561080857805461ff00191661040017815561077b8361280c565b5460038201805490929160009182918291829160101c6001600160a01b03168282156107ff575bf11561063757600201549054600091829182918291906001600160a01b03168282156107f6575bf115610637577f82dca6171073e896c9a2e2206c0cf7d1499202cf0e22e05bc934dcdc5d54caae600080a2005b506108fc6107c9565b506108fc6107a2565b60405162461bcd60e51b815260206004820152601560248201527423b930b1b2903832b934b7b2103737ba1037bb32b960591b6044820152606490fd5b634e487b7160e01b600052601160045260246000fd5b60203660031901126101cc57600435806000526001602052604060002060018101805460ff8160081c1660058110156106a95761089890156122c5565b3360109190911c6001600160a01b031614610a12576003820191825434036109da5760048101544210156109a65760020180546001600160a01b03191633179055805461ff0019166101001790556108ef82612731565b600354600160401b811015610990578261091482600161092d94016003556003611e23565b90919082549060031b91821b91600019901b1916179055565b3360005260046020526109448260406000206122a2565b548060011b90808204600214901517156108455761096490600a54612220565b600a5533907f2be0d3826f37a8de3c1b301652c7dab4429fc3dfe5685e6ce0947666cb32401d600080a3005b634e487b7160e01b600052604160045260246000fd5b60405162461bcd60e51b815260206004820152600c60248201526b111d595b08195e1c1a5c995960a21b6044820152606490fd5b60405162461bcd60e51b815260206004820152601060248201526f4d757374206d61746368207374616b6560801b6044820152606490fd5b60405162461bcd60e51b815260206004820152601460248201527310d85b9b9bdd081a9bda5b881bdddb88191d595b60621b6044820152606490fd5b346101cc5760203660031901126101cc576004356001600160401b0381116101cc57366023820112156101cc578060040135906001600160401b0382116101cc573660248360051b830101116101cc57906001600160a01b03610aaf6123c8565b1690604051928391634c37574560e01b8352806024840160206004860152526024604484019201906000905b808210610cb25750505091818060009403915afa9081156106375760009081908293610b8f575b50604051916060830160608452815180915260206080850192019060005b818110610b795750505082810360208401526020808351928381520192019060005b818110610b60575050506001600160401b0382931660408301520390f35b825160000b845260209384019390920191600101610b42565b8251845260209384019390920191600101610b20565b919250503d8083833e610ba28183611fc6565b8101906060818303126105b85780516001600160401b0381116105c05781019282601f85011215610caf57835193610bd98561205c565b94610be76040519687611fc6565b80865260208087019160051b830101918583116105c057602001905b828210610c9f5750505060208201516001600160401b038111610c9b5782019280601f85011215610c9b57835191610c3a8361205c565b94610c486040519687611fc6565b83865260208087019460051b820101928311610c9b57602001925b828410610c8257505050506040610c7a9101612157565b919083610b02565b835180830b81036105b857815260209384019301610c63565b5080fd5b8151815260209182019101610c03565b80fd5b919350918335906001600160581b031982168092036101cc57602081600193829352019401920185939291610adb565b346101cc5760003660031901126101cc57600460606001600160a01b03610d076127d3565b166040519283809263dbdff2c160e01b82525afa90811561063757606091600091600090600092610d48575b50604051928352151560208301526040820152f35b915050610d6b9150823d8411610d72575b610d638183611fc6565b81019061230e565b9084610d33565b503d610d59565b346101cc5760203660031901126101cc57600435806000526001602052604060002060018101805460ff8160081c1660058110156106a957610dbb90156122c5565b60101c6001600160a01b03163303610e3b5760008080936003829461030061ff0019825416178155610dec88612731565b549101549060101c6001600160a01b0316828215610e32575bf115610637577fe6869595d58c61aa991d00acb41ac260a2d3b5a40d58255f6aad94a14c2804a7600080a2005b506108fc610e05565b60405162461bcd60e51b815260206004820152601760248201527f4f6e6c792063726561746f722063616e2063616e63656c0000000000000000006044820152606490fd5b346101cc5760003660031901126101cc576020604051600a8152f35b346101cc5760003660031901126101cc576020604051662386f26fc100008152f35b346101cc5760003660031901126101cc57602060405160648152f35b346101cc5760003660031901126101cc57602060405162093a808152f35b346101cc5760203660031901126101cc57610f11611f93565b60606001600160a01b03610f236123c8565b6040516349f4fc0360e11b81526001600160581b0319909416600485015283916024918391165afa9081156106375760609160009060008091610f82575b6001600160401b0392935060405193845260000b6020840152166040820152f35b505050610fac6001600160401b0391833d8511610fb7575b610fa48183611fc6565b81019061216b565b919250829190610f61565b503d610f9a565b60603660031901126101cc576024356044356004358115158083036101cc57610ff0662386f26fc10000341015612198565b610ffb4285116121d4565b62093a804201804211610845576110149085111561222d565b816009600054946110248661226c565b600090815586815260016020819052604090912087815580820180546001600160b01b0319163360101b62010000600160b01b0316179092179091559061108690346003840155886004840155600583019060ff801983541691151516179055565b01556110918361227b565b3360005260046020526110a88360406000206122a2565b6110b360085461226c565b60085560405191602094600184523486850152604084015260006060840152608083015260a0820152817fb320c7ddf7489cbe7ffa5dcf55b40f9a4a5603bbd4b903a38e148b37370f95c160c03393a3604051908152f35b346101cc5760003660031901126101cc576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b60a03660031901126101cc57611164611f93565b602435604435918260000b83036101cc576064359260843592831515918285036101cc5761119b662386f26fc10000341015612198565b6111a64287116121d4565b62093a804201804211610845576111bf9087111561222d565b6008600054956111ce8761226c565b600090815587815260016020819052604090912088815590810180546001600160b01b0319163360101b62010000600160b01b03161790559061122c90346003840155896004840155600583019060ff801983541691151516179055565b600681018660581c6001600160581b0360a81b825416179055836007820155019060ff198254169060ff161790556112638461227b565b33600052600460205261127a8460406000206122a2565b61128560085461226c565b6008556040519260209560008552348786015260408501526001600160581b0319166060840152608083015260a0820152817fb320c7ddf7489cbe7ffa5dcf55b40f9a4a5603bbd4b903a38e148b37370f95c160c03393a3604051908152f35b346101cc5760003660031901126101cc576020600954604051908152f35b346101cc5760203660031901126101cc576001600160a01b03611324611e3b565b1660005260056020526020604060002054604051908152f35b346101cc5760203660031901126101cc576004356000526001602052610200604060002080549060018101549060018060a01b03600282015416600382015460048301546005840154600685015460581b600786015491600887015460000b93600988015495600a8901549760ff600c600b8c01549b0154169a6113e0604080519e8f9081526113d36020820160ff8616611e51565b0160ff8360081c16611e5e565b60018060a01b039060101c1660608d015260808c015260a08b015260c08a015260ff8116151560e08a015260018060a01b039060081c166101008901526001600160581b0319166101208801526101408701526101608601526101808501526101a08401526101c083015215156101e0820152f35b346101cc5760003660031901126101cc5760035461147281612073565b9060005b81811061148f576040518061148b8582611f4e565b0390f35b61149881611dd7565b90549060031b1c60005260016020526040600020906040516114b981611faa565b82548152600183015460ff811660028110156106a957602083015260ff8160081c1660058110156106a957604083015260101c6001600160a01b039081166060830152600284015481166080830152600384015460a0830152600484015460c0830152600584015460ff818116151560e0850152600891821c909216610100840152600685015460581b6001600160581b031916610120840152600785015461014084015284015460000b6101608301526009840154610180830152600a8401546101a0830152600b8401546101c0830152600c9093015490921615156101e08301526001916115a982866120c3565b526115b481856120c3565b5001611476565b346101cc5760203660031901126101cc576004358060005260016020526040600020600181015460ff8160081c169060058210156106a957611601600160ff93146120d7565b1660028110156106a95761174e578061162260046024930154421015612115565b6001600160a01b036116326123c8565b16906060600682015460581b604051948580926349f4fc0360e11b82526001600160581b031916958660048301525afa80156106375761001b94600093849285906116f1575b6116ce949596507fac39fb998ad2f116dd95803aee3846757c502771d55ac04dd2943850cfcddf37916001600160401b036080926040519283528960208401528660000b6040840152166060820152a283612478565b6116e46007830154600884015460000b90612478565b111591600a8201556124dc565b5091506116ce9293507fac39fb998ad2f116dd95803aee3846757c502771d55ac04dd2943850cfcddf37608061173d6001600160401b039760603d606011610fb757610fa48183611fc6565b919850889796509492509050611678565b60405162461bcd60e51b815260206004820152601060248201526f139bdd0818481c1c9a58d948191d595b60821b6044820152606490fd5b346101cc5760003660031901126101cc576080600854600954600a5460075491604051938452602084015260408301526060820152f35b346101cc5760203660031901126101cc576001600160a01b036117de611e3b565b16600052600460205260406000206040518082602082945493848152019060005260206000209260005b81811061196957505061181d92500382611fc6565b6118278151612073565b9060005b815181101561195b5761183e81836120c3565b51600052600160205260406000209060405161185981611faa565b82548152600183015460ff811660028110156106a957602083015260ff8160081c1660058110156106a957604083015260101c6001600160a01b039081166060830152600284015481166080830152600384015460a0830152600484015460c0830152600584015460ff818116151560e0850152600891821c909216610100840152600685015460581b6001600160581b031916610120840152600785015461014084015284015460000b6101608301526009840154610180830152600a8401546101a0830152600b8401546101c0830152600c9093015490921615156101e083015260019161194982866120c3565b5261195481856120c3565b500161182b565b6040518061148b8582611f4e565b8454835260019485019486945060209093019201611808565b346101cc5760203660031901126101cc576001600160a01b036119a3611e3b565b1660005260066020526020604060002054604051908152f35b346101cc5760003660031901126101cc576002546119d981612073565b9060005b8181106119f2576040518061148b8582611f4e565b6119fb81611e08565b90549060031b1c6000526001602052604060002090604051611a1c81611faa565b82548152600183015460ff811660028110156106a957602083015260ff8160081c1660058110156106a957604083015260101c6001600160a01b039081166060830152600284015481166080830152600384015460a0830152600484015460c0830152600584015460ff818116151560e0850152600891821c909216610100840152600685015460581b6001600160581b031916610120840152600785015461014084015284015460000b6101608301526009840154610180830152600a8401546101a0830152600b8401546101c0830152600c9093015490921615156101e0830152600191611b0c82866120c3565b52611b1781856120c3565b50016119dd565b346101cc5760003660031901126101cc576020600a54604051908152f35b346101cc5760203660031901126101cc57611b55611fe7565b5060043560005260016020526040600020604051611b7281611faa565b81548152600182015460ff811660028110156106a957602083015260ff8160081c1660058110156106a95760408381019190915260109190911c6001600160a01b039081166060840152600284015481166080840152600384015460a0840152600484015460c0840152600584015460ff818116151560e0860152600891821c909216610100850152600685015460581b6001600160581b031916610120850152600785015461014085015284015460000b6101608401526009840154610180840152600a8401546101a0840152600b8401546101c0840152600c9093015490921615156101e0820152905161020091611c6d908290611e6b565bf35b346101cc5760003660031901126101cc576020600054604051908152f35b346101cc5760203660031901126101cc5760406001600160a01b03611cb0611e3b565b168060005260056020528160002054906000526006602052816000205482519182526020820152f35b346101cc5760003660031901126101cc577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031633819003611d43576000808080936007549082600755828215611d3a575bf11561063757005b506108fc611d32565b60405162461bcd60e51b815260206004820152600a60248201526927b7363c9037bbb732b960b11b6044820152606490fd5b346101cc5760003660031901126101cc576020600754604051908152f35b346101cc5760203660031901126101cc576004356003548110156101cc576101bd602091611dd7565b346101cc5760003660031901126101cc576020906008548152f35b600354811015611df257600360005260206000200190600090565b634e487b7160e01b600052603260045260246000fd5b600254811015611df257600260005260206000200190600090565b8054821015611df25760005260206000200190600090565b600435906001600160a01b03821682036101cc57565b9060028210156106a95752565b9060058210156106a95752565b6101e0809180518452611e8660208201516020860190611e51565b611e9860408201516040860190611e5e565b60018060a01b03606082015116606085015260018060a01b03608082015116608085015260a081015160a085015260c081015160c085015260e0810151151560e085015260018060a01b03610100820151166101008501526001600160581b03196101208201511661012085015261014081015161014085015261016081015160000b6101608501526101808101516101808501526101a08101516101a08501526101c08101516101c085015201511515910152565b602060408183019282815284518094520192019060005b818110611f725750505090565b909192602061020082611f886001948851611e6b565b019401929101611f65565b600435906001600160581b0319821682036101cc57565b61020081019081106001600160401b0382111761099057604052565b90601f801991011681019081106001600160401b0382111761099057604052565b60405190611ff482611faa565b60006101e0838281528260208201528260408201528260608201528260808201528260a08201528260c08201528260e08201528261010082015282610120820152826101408201528261016082015282610180820152826101a0820152826101c08201520152565b6001600160401b0381116109905760051b60200190565b9061207d8261205c565b61208a6040519182611fc6565b828152809261209b601f199161205c565b019060005b8281106120ac57505050565b6020906120b7611fe7565b828285010152016120a0565b8051821015611df25760209160051b010190565b156120de57565b60405162461bcd60e51b815260206004820152600f60248201526e4475656c206e6f742061637469766560881b6044820152606490fd5b1561211c57565b60405162461bcd60e51b8152602060048201526013602482015272546f6f206561726c7920746f20736574746c6560681b6044820152606490fd5b51906001600160401b03821682036101cc57565b908160609103126101cc5780519160208201518060000b81036101cc576040612195919301612157565b90565b1561219f57565b60405162461bcd60e51b815260206004820152600d60248201526c5374616b6520746f6f206c6f7760981b6044820152606490fd5b156121db57565b60405162461bcd60e51b815260206004820152601e60248201527f446561646c696e65206d75737420626520696e207468652066757475726500006044820152606490fd5b9190820180921161084557565b1561223457565b60405162461bcd60e51b815260206004820152601060248201526f2232b0b23634b732903a37b7903330b960811b6044820152606490fd5b60001981146108455760010190565b60025490600160401b821015610990576109148260016122a094016002556002611e23565b565b90815491600160401b83101561099057826109149160016122a095018155611e23565b156122cc57565b60405162461bcd60e51b815260206004820152600d60248201526c223ab2b6103737ba1037b832b760991b6044820152606490fd5b519081151582036101cc57565b908160609103126101cc57805191604061232a60208401612301565b92015190565b8181029291811591840414171561084557565b35906001600160401b03821682036101cc57565b9035601e19823603018112156101cc5701602081359101916001600160401b0382116101cc5781360383136101cc57565b908060209392818452848401376000828201840152601f01601f1916010190565b908160209103126101cc57516001600160a01b03811681036101cc5790565b6040516020810190602082526006604082015265233a39b7ab1960d11b6060820152606081526123f9608082611fc6565b51902060405190630ac9aa5160e11b8252600482015260208160248173ad67fe66660fb8dfe9d6b1b4240d8650e30f60195afa90811561063757600091612448575b506001600160a01b031690565b612461915060203d60201161066b5761065d8183611fc6565b3861243b565b60ff16604d811161084557600a0a90565b90600090810b9081126124ac5760120390607f198212607f831317610845576124a66121959260ff16612467565b90612330565b607f1981146108455760000360000b60120190607f198212607f831317610845576124a66121959260ff16612467565b6005810180549092151560ff821615150361271d57600182015460101c6001600160a01b0316925b6003830154918260011b92808404600214901517156108455760648302838104606414841517156108455761271090048084038481116108455792600092600460606001600160a01b036125566127d3565b166040519283809263dbdff2c160e01b82525afa80869287926126f8575b50612699575b5050610100600160a81b031916600888901b610100600160a81b031617905560018501805461ff001916610200179055600b8501839055600c8501805483151560ff1660ff19919091161790556001600160a01b039590951694919250906125e490600754612220565b6007556125f260095461226c565b600955836000526005602052604060002061260d815461226c565b90558360005260066020526040600020612628838254612220565b9055612634835461280c565b60008285811561268f575b600092839283928392f115610637577f4188b822aed2fe2a908f2d8372c1bc7f62b375f20b97b99647cf7fde7a45b5d591606091600a8554950154604051928352602083015215156040820152a3565b6108fc925061263f565b806126eb575b6126aa575b8061257a565b945091506125e492916001947f7bbfdbec98dcfb32fd2467c180f1f6de7288b1f166016955d566586367e2ab2f6020895492604051908152a28594936126a4565b50600a606482061061269f565b909250612714915060603d606011610d7257610d638183611fc6565b50909138612574565b60028201546001600160a01b031692612504565b60005b600254808210156127ce578261274983611e08565b90549060031b1c1461275e5750600101612734565b6000198101925082116108455761091461277a61278793611e08565b90549060031b1c91611e08565b60025480156127b857600019016127b36127a2826002611e23565b8154906000199060031b1b19169055565b600255565b634e487b7160e01b600052603160045260246000fd5b505050565b604051602081019060208252600e60408201526d2930b73237b6a73ab6b132b92b1960911b6060820152606081526123f9608082611fc6565b60005b600354808210156127ce578261282483611dd7565b90549060031b1c14612839575060010161280f565b6000198101925082116108455761091461285561286293611dd7565b90549060031b1c91611dd7565b60035480156127b8576000190161287d6127a2826003611e23565b60035556fea2646970667358221220c41f8a659572b578b90df0eeb18a52c5c611f639e5d2adda8d13a57a6178fc2264736f6c634300081e0033",
  "devdoc": {
    "details": "Built for ETH Oxford 2026 hackathon on Coston2 testnet",
    "kind": "dev",
    "methods": {},
    "title": "DegenDuel",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "cancelDuel(uint256)": {
        "notice": "Cancel an open duel (creator only, before anyone joins)"
      },
      "createDataDuel(uint256,uint256,bool)": {
        "notice": "Create a data-based duel settled by FDC Web2Json proof"
      },
      "createPriceDuel(bytes21,uint256,int8,uint256,bool)": {
        "notice": "Create a price-based duel settled by FTSO"
      },
      "expireDuel(uint256)": {
        "notice": "Expire a duel that passed deadline + 24h without settlement"
      },
      "getActiveDuels()": {
        "notice": "Get all active duels"
      },
      "getCurrentPrice(bytes21)": {
        "notice": "Get current FTSO price for a feed (for UI display)"
      },
      "getDuel(uint256)": {
        "notice": "Get a single duel by ID"
      },
      "getOpenDuels()": {
        "notice": "Get all open duels"
      },
      "getPlayerDuels(address)": {
        "notice": "Get duels for a specific player"
      },
      "getPlayerStats(address)": {
        "notice": "Get player stats for leaderboard"
      },
      "getPrices(bytes21[])": {
        "notice": "Get multiple FTSO prices at once (for UI ticker)"
      },
      "getProtocolStats()": {
        "notice": "Get protocol stats"
      },
      "getRandomNumber()": {
        "notice": "Get a random number from Flare's Secure RNG"
      },
      "joinDuel(uint256)": {
        "notice": "Join an open duel (takes the opposite prediction)"
      },
      "settleDataDuel(uint256,(bytes32[],(bytes32,bytes32,uint64,uint64,(string,string,string,string,string,string,string),(bytes))))": {
        "notice": "Settle a data duel with a verified FDC Web2Json proof"
      },
      "settlePriceDuel(uint256)": {
        "notice": "Settle a price duel by reading current FTSO price"
      },
      "withdrawFees()": {
        "notice": "Withdraw accumulated protocol fees"
      }
    },
    "notice": "PvP prediction duel game using all 3 Flare protocols: FTSO + FDC + RNG",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 8937,
        "contract": "contracts/DegenDuel.sol:DegenDuel",
        "label": "nextDuelId",
        "offset": 0,
        "slot": "0",
        "type": "t_uint256"
      },
      {
        "astId": 8942,
        "contract": "contracts/DegenDuel.sol:DegenDuel",
        "label": "duels",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_uint256,t_struct(Duel)8935_storage)"
      },
      {
        "astId": 8945,
        "contract": "contracts/DegenDuel.sol:DegenDuel",
        "label": "openDuelIds",
        "offset": 0,
        "slot": "2",
        "type": "t_array(t_uint256)dyn_storage"
      },
      {
        "astId": 8948,
        "contract": "contracts/DegenDuel.sol:DegenDuel",
        "label": "activeDuelIds",
        "offset": 0,
        "slot": "3",
        "type": "t_array(t_uint256)dyn_storage"
      },
      {
        "astId": 8953,
        "contract": "contracts/DegenDuel.sol:DegenDuel",
        "label": "playerDuels",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_address,t_array(t_uint256)dyn_storage)"
      },
      {
        "astId": 8957,
        "contract": "contracts/DegenDuel.sol:DegenDuel",
        "label": "playerWins",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 8961,
        "contract": "contracts/DegenDuel.sol:DegenDuel",
        "label": "playerEarnings",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 8977,
        "contract": "contracts/DegenDuel.sol:DegenDuel",
        "label": "protocolFeePool",
        "offset": 0,
        "slot": "7",
        "type": "t_uint256"
      },
      {
        "astId": 8979,
        "contract": "contracts/DegenDuel.sol:DegenDuel",
        "label": "totalDuelsCreated",
        "offset": 0,
        "slot": "8",
        "type": "t_uint256"
      },
      {
        "astId": 8981,
        "contract": "contracts/DegenDuel.sol:DegenDuel",
        "label": "totalDuelsSettled",
        "offset": 0,
        "slot": "9",
        "type": "t_uint256"
      },
      {
        "astId": 8983,
        "contract": "contracts/DegenDuel.sol:DegenDuel",
        "label": "totalVolume",
        "offset": 0,
        "slot": "10",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)dyn_storage": {
        "base": "t_uint256",
        "encoding": "dynamic_array",
        "label": "uint256[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes21": {
        "encoding": "inplace",
        "label": "bytes21",
        "numberOfBytes": "21"
      },
      "t_enum(DuelStatus)8900": {
        "encoding": "inplace",
        "label": "enum DegenDuel.DuelStatus",
        "numberOfBytes": "1"
      },
      "t_enum(DuelType)8894": {
        "encoding": "inplace",
        "label": "enum DegenDuel.DuelType",
        "numberOfBytes": "1"
      },
      "t_int8": {
        "encoding": "inplace",
        "label": "int8",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_array(t_uint256)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256[])",
        "numberOfBytes": "32",
        "value": "t_array(t_uint256)dyn_storage"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_struct(Duel)8935_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct DegenDuel.Duel)",
        "numberOfBytes": "32",
        "value": "t_struct(Duel)8935_storage"
      },
      "t_struct(Duel)8935_storage": {
        "encoding": "inplace",
        "label": "struct DegenDuel.Duel",
        "members": [
          {
            "astId": 8902,
            "contract": "contracts/DegenDuel.sol:DegenDuel",
            "label": "id",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 8905,
            "contract": "contracts/DegenDuel.sol:DegenDuel",
            "label": "duelType",
            "offset": 0,
            "slot": "1",
            "type": "t_enum(DuelType)8894"
          },
          {
            "astId": 8908,
            "contract": "contracts/DegenDuel.sol:DegenDuel",
            "label": "status",
            "offset": 1,
            "slot": "1",
            "type": "t_enum(DuelStatus)8900"
          },
          {
            "astId": 8910,
            "contract": "contracts/DegenDuel.sol:DegenDuel",
            "label": "playerA",
            "offset": 2,
            "slot": "1",
            "type": "t_address"
          },
          {
            "astId": 8912,
            "contract": "contracts/DegenDuel.sol:DegenDuel",
            "label": "playerB",
            "offset": 0,
            "slot": "2",
            "type": "t_address"
          },
          {
            "astId": 8914,
            "contract": "contracts/DegenDuel.sol:DegenDuel",
            "label": "stakeAmount",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 8916,
            "contract": "contracts/DegenDuel.sol:DegenDuel",
            "label": "deadline",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 8918,
            "contract": "contracts/DegenDuel.sol:DegenDuel",
            "label": "playerAPrediction",
            "offset": 0,
            "slot": "5",
            "type": "t_bool"
          },
          {
            "astId": 8920,
            "contract": "contracts/DegenDuel.sol:DegenDuel",
            "label": "winner",
            "offset": 1,
            "slot": "5",
            "type": "t_address"
          },
          {
            "astId": 8922,
            "contract": "contracts/DegenDuel.sol:DegenDuel",
            "label": "feedId",
            "offset": 0,
            "slot": "6",
            "type": "t_bytes21"
          },
          {
            "astId": 8924,
            "contract": "contracts/DegenDuel.sol:DegenDuel",
            "label": "priceThreshold",
            "offset": 0,
            "slot": "7",
            "type": "t_uint256"
          },
          {
            "astId": 8926,
            "contract": "contracts/DegenDuel.sol:DegenDuel",
            "label": "priceDecimals",
            "offset": 0,
            "slot": "8",
            "type": "t_int8"
          },
          {
            "astId": 8928,
            "contract": "contracts/DegenDuel.sol:DegenDuel",
            "label": "dataThreshold",
            "offset": 0,
            "slot": "9",
            "type": "t_uint256"
          },
          {
            "astId": 8930,
            "contract": "contracts/DegenDuel.sol:DegenDuel",
            "label": "settledValue",
            "offset": 0,
            "slot": "10",
            "type": "t_uint256"
          },
          {
            "astId": 8932,
            "contract": "contracts/DegenDuel.sol:DegenDuel",
            "label": "payout",
            "offset": 0,
            "slot": "11",
            "type": "t_uint256"
          },
          {
            "astId": 8934,
            "contract": "contracts/DegenDuel.sol:DegenDuel",
            "label": "bonusApplied",
            "offset": 0,
            "slot": "12",
            "type": "t_bool"
          }
        ],
        "numberOfBytes": "416"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}